---
title: Arrow 2.2.0
category: articles
image: /img/arrow-release-ftr.jpg
no_image_on_post: true
tags: [core, articles]
---

# Arrow 2.2.0

Arrow 2.2.0 is out, with improved and new functionality.
This release builds on top of several [new features in Kotlin 2.2](https://kotlinlang.org/docs/whatsnew22.html),
in its self-imposed role of _perfect companion for your Kotlin journey_.

**`Raise` with context parameters.**
The new package `arrow.core.raise.context` provides the same API as `arrow.core.raise`,
but using context parameters instead of extension functions.
This package is intended to be a full 1-1 replacement.

Unfortunately, currently mixing `Raise` functions using extension-style and
context-style doesn't lead to the better experience. Our advice is to fully migrate
to the context-style API if possible, or stay completely within the extension style.

```kotlin
// extension-style
fun Raise<PersonValidationError>.buildPerson(name: String, age: Int): Person { ... }

// context-style, "fake" constructor
context(Raise<PersonValidationError>)
fun Person(name: String, age: Int): Person { ... }
```

:::info Enabling context parameters

In order to define functions with context parameters, you need to enable the
corresponding language feature, as described in the
[Kotlin documentation](https://kotlinlang.org/docs/whatsnew22.html#preview-of-context-parameters).

:::

**New `Racing` DSL for concurrency.**
Arrow Fx provides [high-level concurrency combinators](/learn/coroutines/parallel/)
to succinctly describe how tasks should be interleaved in a computation.
Albeit useful, those combinators require nesting and writing your code in a
particular way. In Arrow 2.2.0 we introduce a new 
[`Racing` DSL](/learn/coroutines/dsl/#racing).
Combined with the already existing
[`AwaitAll` DSL](/learn/coroutines/dsl/#await-all--parallelism),
you can write your coroutines code with little to no changes, while using as
much concurrency as possible during execution.

**`validate` for error values.**
We have introduced a small utility function to bridge the world of validation functions
working on `Raise`, and chained style using `Either` or `Option`. This function is
called `validate`, and it should be commonly used in conjunction with `ensure` and similar functions.

```kotlin
fun failOnMoreConditionsWithBindMap(): Either<String, Int> =
    randomNumber()
        .validate { ensure(it != 10) { "Number 10 also not allowed" } }
        .map { it + 100 }
```

This new function provides no functionality you could not get before.
For example, here is the code equivalent to the one above, but using the `Either` DSL.

```kotlin
fun failOnMoreConditionsWithBindMap(): Either<String, Int> = either {
    val random = randomNumber().bind()
    ensure(random != 10) { "Number 10 also not allowed" }
    random + 100
}
```

We acknowledge that the chain-of-calls style is a common one, and we want the Arrow API
to appeal to users using their preferred style.

**"At most once" for `Eval`.**
Arrow provides the `Eval` type for [fine-grained control over evaluation](https://arrow-kt.io/learn/collections-functions/eval/).
This is similar to `lazy` in the standard library, but you can choose
between eager, lazy, and repeated (computed every time) evaluation strategies.
However, there was no (easy) way to ensure that a computation was evaluated
at most once.

The new `Eval.atMostOnce` function (alongside `SuspendEval.atMostOnce`)
provides this new behavior. You should be aware, though, that this means
that getting the value of an `Eval` built this way may block (or suspend)
if more than one thread does so concurrently.

**Changes to `toString` for non-empty collections.**
After a [long discussion in Slack](https://kotlinlang.slack.com/archives/C5UPMM0A0/p1757410910270849)
it became clear that the behavior of `toString` for non-empty collections
should just reflect that of the wrapped collection. Until now, using
`NonEmptyList` or `NonEmptySet` added a prefix — from now on, we treat
non-emptiness as simply a property of the collection, no different than other
such as their size, that are not reflected when turning into a string.

**New `arrow-core-result4k` module.**
[Result4k](https://github.com/fork-handles/forkhandles/tree/trunk/result4k)
is a popular library for computation that may succeed or fail.
We now provide support for it as part of [typed errors](/learn/typed-errors/working-with-typed-errors/).
You can either consume them — that is, `.bind()` a `Result` value —
or produce them — use the `result4k` builder in a similar way to `either`.

**Migration to new plug-ins.** 
Following our _eager dependency update policy_, we have moved to the new recommended
plug-ins in the ecosystem.

- We now use [KSP2](https://github.com/google/ksp/blob/main/docs/ksp2.md),
- Android now uses the [Android Gradle Library Plugin for KMP](https://developer.android.com/kotlin/multiplatform/plugin),
- Binary validation is done using the [experimental built-in support](https://kotlinlang.org/docs/gradle-binary-compatibility-validation.html),
- We now publish a [version catalog](https://docs.gradle.org/current/userguide/version_catalogs.html#sec:importing-published-catalog)
  for consistent versioning of Arrow dependencies.
- The [Arrow plug-in for IntelliJ IDEs](https://plugins.jetbrains.com/plugin/24550-arrow)
  now supports up to 2025.3, and understand code using context parameters.
