"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[8680],{62808:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var t=n(85893),i=n(11151);const o={id:"either-and-ior",title:"Either & Ior",description:"Use cases for Either and Ior.",sidebar_position:3},s="Either & Ior",a={id:"learn/typed-errors/either-and-ior",title:"Either & Ior",description:"Use cases for Either and Ior.",source:"@site/content/docs/learn/typed-errors/either_ior.md",sourceDirName:"learn/typed-errors",slug:"/learn/typed-errors/either-and-ior",permalink:"/learn/typed-errors/either-and-ior",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/typed-errors/either_ior.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"either-and-ior",title:"Either & Ior",description:"Use cases for Either and Ior.",sidebar_position:3},sidebar:"learnSidebar",previous:{title:"Why nullable types & Option?",permalink:"/learn/typed-errors/nullable-and-option"},next:{title:"Validation",permalink:"/learn/typed-errors/validation"}},c={},d=[{value:"Using builders",id:"using-builders",level:2},{value:"Combining Ior errors",id:"combining-ior-errors",level:3},{value:"Without builders",id:"without-builders",level:2},{value:"Either for validation",id:"either-for-validation",level:2}];function l(e){const r={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{id:"either--ior",children:"Either & Ior"}),"\n",(0,t.jsxs)(r.p,{children:["Both ",(0,t.jsx)(r.a,{href:"https://apidocs.arrow-kt.io/arrow-core/arrow.core/-either/index.html",children:(0,t.jsx)(r.code,{children:"Either<E, A>"})}),"\nand ",(0,t.jsx)(r.a,{href:"https://apidocs.arrow-kt.io/arrow-core/arrow.core/-ior/index.html",children:(0,t.jsx)(r.code,{children:"Ior<E, A>"})}),"\nhold values that may be of type ",(0,t.jsx)(r.code,{children:"E"})," or ",(0,t.jsx)(r.code,{children:"A"}),".\nBy convention, the type ",(0,t.jsx)(r.code,{children:"E"})," represents ",(0,t.jsx)(r.em,{children:"errors"})," and the type ",(0,t.jsx)(r.code,{children:"A"})," represents\n",(0,t.jsx)(r.em,{children:"success"}),". For example, ",(0,t.jsx)(r.code,{children:"Either<DbError, User>"})," could be a good result type for\na function that accesses a database and returns a ",(0,t.jsx)(r.code,{children:"User"})," but may also fail\nwith a ",(0,t.jsx)(r.code,{children:"DbError"}),". Another point of view is that both types ",(0,t.jsx)(r.em,{children:"extend"})," the capabilities\nof the built-in ",(0,t.jsx)(r.a,{href:"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/",children:(0,t.jsx)(r.code,{children:"Result"})}),"\ntype, but no longer constraining the potential errors to be ",(0,t.jsx)(r.code,{children:"Throwable"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"Either<E, A>"})," only admits these two possibilities: a ",(0,t.jsx)(r.code,{children:"Left"})," holding a value of\ntype ",(0,t.jsx)(r.code,{children:"E"})," or a ",(0,t.jsx)(r.code,{children:"Right"})," holding a value of type ",(0,t.jsx)(r.code,{children:"A"}),". On the other hand, ",(0,t.jsx)(r.code,{children:"Ior<E, A>"}),"\nprovides a third option, namely ",(0,t.jsx)(r.code,{children:"Both"}),". Using ",(0,t.jsx)(r.code,{children:"Both"}),", you can represent states\nthat are considered successful but with some potential errors during execution;\nlike a compiler that finishes successfully but has some warnings. Nevertheless,\n",(0,t.jsx)(r.code,{children:"Ior"})," is not used very often."]}),"\n",(0,t.jsx)(r.h2,{id:"using-builders",children:"Using builders"}),"\n",(0,t.jsxs)(r.p,{children:["The preferred way to work with ",(0,t.jsx)(r.code,{children:"Either"})," and ",(0,t.jsx)(r.code,{children:"Ior"})," is to use ",(0,t.jsx)(r.a,{href:"../../typed-errors/working-with-typed-errors/#running-and-inspecting-results",children:"builders"}),".\nThose start with a call to ",(0,t.jsx)(r.code,{children:"either"})," or ",(0,t.jsx)(r.code,{children:"ior"})," followed by a lambda; inside that\nblock, we can access the uniform typed errors API with functions like ",(0,t.jsx)(r.code,{children:"raise"}),",\n",(0,t.jsx)(r.code,{children:"ensure"}),", and ",(0,t.jsx)(r.code,{children:"recover"}),"."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-kotlin",children:'import arrow.core.raise.either\nimport arrow.core.raise.ensure\n\ndata class MyError(val message: String)\n\nfun isPositive(i: Int): Either<MyError, Int> = either {\n  ensure(i > 0) { MyError("$i is not positive") }\n  i\n}\n\nsuspend fun example() {\n  isPositive(-1) shouldBe MyError("-1 is not positive").left()\n  isPositive(1)  shouldBe 1.right()\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["To give you the complete picture, inside those blocks, the potential errors are\nrepresented by a receiver of type ",(0,t.jsx)(r.code,{children:"Raise<E>"}),". Functions with that receiver can\nbe transformed into a variety of types; not only ",(0,t.jsx)(r.code,{children:"Either"})," and ",(0,t.jsx)(r.code,{children:"Ior"}),", but also\n",(0,t.jsx)(r.code,{children:"Result"}),", ",(0,t.jsx)(r.code,{children:"Option"}),", or a nullable type."]}),"\n",(0,t.jsxs)(r.p,{children:["A common scenario is to have an ",(0,t.jsx)(r.code,{children:"Either"})," or ",(0,t.jsx)(r.code,{children:"Ior"})," value that we want to execute\nas part of the block. That is, we want potential errors in those values to bubble\nas errors of the entire block or keep the execution if the value represents\nsuccess. In those cases, we need to call ",(0,t.jsx)(r.code,{children:".bind()"})," over the value of type ",(0,t.jsx)(r.code,{children:"Either"}),"\nor ",(0,t.jsx)(r.code,{children:"Ior"}),"."]}),"\n",(0,t.jsx)(r.mermaid,{value:'graph LR;\n  raise{{"Raise&lt;E&gt;.() -> A"}};\n  other{{"Either&lt;E, A&gt; / Ior&lt;E, A&gt;"}};\n  raise--\x3e|either / ior|other;\n  other--\x3e|".bind()"|raise;'}),"\n",(0,t.jsx)(r.admonition,{type:"tip",children:(0,t.jsxs)(r.p,{children:["We recommend using the ",(0,t.jsxs)(r.a,{href:"https://github.com/woltapp/arrow-detekt-rules#noeffectscopebindablevalueasstatement",children:["custom ",(0,t.jsx)(r.code,{children:"NoEffectScopeBindableValueAsStatement"})," rule"]}),"\nfor ",(0,t.jsx)(r.a,{href:"https://detekt.dev/",children:"Detekt"})," to prevent forgetting ",(0,t.jsx)(r.code,{children:".bind()"})," inside\nan ",(0,t.jsx)(r.code,{children:"either"})," or ",(0,t.jsx)(r.code,{children:"ior"})," block."]})}),"\n",(0,t.jsx)(r.h3,{id:"combining-ior-errors",children:"Combining Ior errors"}),"\n",(0,t.jsxs)(r.p,{children:["The flow in an ",(0,t.jsx)(r.code,{children:"Either"})," block is simple: we execute each step; if at some point\nwe ",(0,t.jsx)(r.code,{children:"bind()"})," a ",(0,t.jsx)(r.code,{children:"Left"})," or find a ",(0,t.jsx)(r.code,{children:"raise"}),", we stop and return that value; if we get\nto the end, we wrap the result in ",(0,t.jsx)(r.code,{children:"Right"}),". ",(0,t.jsx)(r.code,{children:"ior"})," blocks are a bit more complicated,\nsince we may end up in a situation in which we have errors to be reported, yet\nwe also have a value to continue the execution. This brings up a question: what\nshould we do if ",(0,t.jsx)(r.em,{children:"several"})," steps in the block are ",(0,t.jsx)(r.code,{children:"Both"}),"? The current API leaves\nthe answer open to the developer. The ",(0,t.jsx)(r.code,{children:"ior"})," builder has\nan additional parameter that specifies how to combine several errors."]}),"\n",(0,t.jsx)(r.h2,{id:"without-builders",children:"Without builders"}),"\n",(0,t.jsxs)(r.p,{children:["In some scenarios, builders may be overkill for the task at hand. For those cases,\nwe provide functions that create or operate directly on ",(0,t.jsx)(r.code,{children:"Either"})," and ",(0,t.jsx)(r.code,{children:"Ior"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["On the generation front, extension functions like ",(0,t.jsx)(r.code,{children:".left()"})," and ",(0,t.jsx)(r.code,{children:".right()"}),"\nprovide another way to write expressions that won't obscure the inner contents\nas much as a constructor. Validations are often written in that style."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-kotlin",children:"// this is the type we want to construct\n@JvmInline value class Age(val age: Int)\n\n// these are the potential problems\nsealed interface AgeProblem {\n  object InvalidAge: AgeProblem\n  object NotLegalAdult: AgeProblem\n}\n\n// validation returns either problems or the constructed value\nfun validAdult(age: Int): Either<AgeProblem, Age> = when {\n  age < 0  -> AgeProblem.InvalidAge.left()\n  age < 18 -> AgeProblem.NotLegalAdult.left()\n  else     -> Age(age).right()\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Another way to obtain an ",(0,t.jsx)(r.code,{children:"Either"})," is using ",(0,t.jsx)(r.code,{children:"Either.catch"}),", which wraps a\ncomputation that may throw exceptions and returns a ",(0,t.jsx)(r.code,{children:"Left"})," if that's the case.\nEssentially, ",(0,t.jsxs)(r.a,{href:"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run-catching.html",children:[(0,t.jsx)(r.code,{children:"runCatching"})," from the standard library"]}),",\nbut replacing ",(0,t.jsx)(r.code,{children:"Result"})," with ",(0,t.jsx)(r.code,{children:"Either"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["The rest of the API closely follows the one from ",(0,t.jsx)(r.a,{href:"../../typed-errors/",children:"typed errors"}),".\nFor example, you can call ",(0,t.jsx)(r.code,{children:"recover"})," or ",(0,t.jsx)(r.code,{children:"zipOrAccumulate"})," directly on ",(0,t.jsx)(r.code,{children:"Either"}),"\nwithout the need for an additional ",(0,t.jsx)(r.code,{children:"either { }"})," block. One potentially useful\nfunction not part of builders is ",(0,t.jsx)(r.a,{href:"https://apidocs.arrow-kt.io/arrow-core/arrow.core/-either/map-left.html",children:(0,t.jsx)(r.code,{children:"mapLeft"})}),",\nwhich applies a function when the value represents an error. This scenario often\narises when your code has a hierarchy of different error types."]}),"\n",(0,t.jsx)(r.h2,{id:"either-for-validation",children:"Either for validation"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"Either"})," has a double face: it can be used to model problems in a piece of code,\npretty much like exceptions, but also to define validations over some input data.\nThe difference between these two scenarios is how we react to ",(0,t.jsx)(r.em,{children:"several"})," problems\narising in a piece of code."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["When we think of exceptions, we have a ",(0,t.jsx)(r.em,{children:"fail-fast"})," or ",(0,t.jsx)(r.em,{children:"fail-first"})," approach:\nOnce we discover a problem, we want to stop execution and immediately report\nto the caller. In those scenarios, steps ",(0,t.jsx)(r.em,{children:"depend"})," on one another, so it makes\nno sense to keep trying."]}),"\n",(0,t.jsxs)(r.li,{children:["When we think of validation, we want to be as comprehensive as possible with\npotential problems with the input data. In other words, if the given name\nand age are wrong, we want to report both, not just the first one.\nThis approach is called ",(0,t.jsx)(r.em,{children:"accumulation"})," and arises when the code is computations\nwhose failure is ",(0,t.jsx)(r.em,{children:"independent"})," of each other."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["By default, an ",(0,t.jsx)(r.code,{children:"either"})," block follows the first approach. If you want to accumulate\nerrors instead, you should use ",(0,t.jsx)(r.a,{href:"https://apidocs.arrow-kt.io/arrow-core/arrow.core/-either/-companion/zip-or-accumulate.html",children:(0,t.jsx)(r.code,{children:"zipOrAccumulate"})}),",\nor ",(0,t.jsx)(r.a,{href:"https://apidocs.arrow-kt.io/arrow-core/arrow.core/map-or-accumulate.html",children:(0,t.jsx)(r.code,{children:"mapOrAccumulate"})}),".\nThe difference is that the former takes the different computations as arguments,\nand they can return different types, whereas the latter applies the same computation\nuniformly to elements of an ",(0,t.jsx)(r.code,{children:"Iterable"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["One common pattern when describing validations is to have an ",(0,t.jsx)(r.code,{children:"Either"})," with\n",(0,t.jsx)(r.code,{children:"List<Problem>"})," as the error type. Arrow provides a more refined version\nwhere we ensure that we never end up in an awkward situation in which we have\na ",(0,t.jsx)(r.code,{children:"Left"})," value, but the list of problems is empty."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-kotlin",children:"public typealias EitherNel<E, A> = Either<NonEmptyList<E>, A>\n"})}),"\n",(0,t.jsxs)(r.p,{children:["In Arrow 1.x series, a different type called ",(0,t.jsx)(r.code,{children:"Validation"})," embodied\nthe accumulation strategy for errors. However, the API was almost identical, and\nsometimes code became flooded with conversion back and forth between ",(0,t.jsx)(r.code,{children:"Either"})," and ",(0,t.jsx)(r.code,{children:"Validation"}),".\nArrow 2.x provides a single ",(0,t.jsx)(r.code,{children:"Either"})," type instead, but we encourage you to use\nthe ",(0,t.jsx)(r.code,{children:"EitherNel"})," type alias if you are describing a validation."]})]})}function h(e={}){const{wrapper:r}={...(0,i.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},11151:(e,r,n)=>{n.d(r,{Z:()=>a,a:()=>s});var t=n(67294);const i={},o=t.createContext(i);function s(e){const r=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:r},e.children)}}}]);