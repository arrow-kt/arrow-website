"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([["4411"],{76179:function(e,n,r){r.r(n),r.d(n,{metadata:()=>i,default:()=>d,frontMatter:()=>s,contentTitle:()=>a,toc:()=>c,assets:()=>l});var i=JSON.parse('{"id":"learn/typed-errors/from-either-to-raise","title":"From Either to Raise","description":"Learning about Raise from other FP ecosystems.","source":"@site/content/docs/learn/typed-errors/from-either-to-raise.md","sourceDirName":"learn/typed-errors","slug":"/learn/typed-errors/from-either-to-raise","permalink":"/learn/typed-errors/from-either-to-raise","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"From Either to Raise","sidebar_position":3,"description":"Learning about Raise from other FP ecosystems."},"sidebar":"learnSidebar","previous":{"title":"Validation","permalink":"/learn/typed-errors/validation"},"next":{"title":"Why nullable types & Option?","permalink":"/learn/typed-errors/nullable-and-option"}}'),o=r(74848),t=r(28453);let s={title:"From Either to Raise",sidebar_position:3,description:"Learning about Raise from other FP ecosystems."},a="From Either to Raise",l={},c=[{value:"Sequential composition",id:"sequential-composition",level:2},{value:"Returning with logical error",id:"returning-with-logical-error",level:2},{value:"Transforming the error values",id:"transforming-the-error-values",level:2},{value:"More than one failure",id:"more-than-one-failure",level:2},{value:"<code>Either</code> and <code>bind</code> no more",id:"either-and-bind-no-more",level:2}];function h(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsxs)(n.h1,{id:"from-either-to-raise",children:["From ",(0,o.jsx)(n.code,{children:"Either"})," to ",(0,o.jsx)(n.code,{children:"Raise"})]})}),"\n",(0,o.jsxs)(n.p,{children:["Typed errors in other functional ecosystems usually revolve around\ndedicated types like ",(0,o.jsx)(n.code,{children:"Either"}),", which provide the ability to describe\ncomputations that are successful or end in error. This style is\nfully supported by Arrow, but the DSL based around ",(0,o.jsx)(n.code,{children:"Raise"})," usually\nresults in a nicer code. This small guide describes common patterns\nin the ",(0,o.jsx)(n.code,{children:"Either"})," style and how they translate into ",(0,o.jsx)(n.code,{children:"Raise"}),"."]}),"\n",(0,o.jsx)(n.admonition,{title:"Working with typed errors",type:"note",children:(0,o.jsxs)(n.p,{children:["For a more general introduction to typed errors, without assuming\nany prior knowledge on the topic, check ",(0,o.jsx)(n.a,{href:"/learn/typed-errors/working-with-typed-errors",children:"this tutorial"}),"."]})}),"\n",(0,o.jsx)(n.p,{children:"In the following discussion, we assume the following functions:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun f(n: Int): Either<Error, String>\nfun g(s: String): Either<Error, Thing>\nfun h(s: String): Either<Boo, Thing>\nfun Thing.summarize(): String\n"})}),"\n",(0,o.jsx)(n.h2,{id:"sequential-composition",children:"Sequential composition"}),"\n",(0,o.jsxs)(n.p,{children:["The basic way to compose computations that may error out is by\nsequentially executing each of them, and finishing early if\nan error appears. This is done using ",(0,o.jsx)(n.code,{children:"flatMap"})," \u2014 if the next\ncomputation may also fail \u2014 or ",(0,o.jsx)(n.code,{children:"map"})," \u2014 if you need to apply\na pure computation to the result, if available."]}),"\n",(0,o.jsx)(n.p,{children:"Consider this possible combination of the aforementioned functions:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun foo(n: Int): Either<Error, String> =\n  f(n).flatMap { s ->\n    g(s).map { t ->\n      t.summarize()\n    }\n  }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The translation into the ",(0,o.jsx)(n.code,{children:"Raise"})," DSL describes the same sequence\nof steps, but using a more sequential style:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun foo(n: Int): Either<Error, String> = either {\n  val s = f(n).bind()\n  val t = g(s).bind()\n  t.summarize()\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["There are two important steps in this translation. At the beginning of\nthe function, we have the ",(0,o.jsx)(n.code,{children:"either"})," builder, which (1) indicates that\nthe result of the function is ",(0,o.jsx)(n.code,{children:"Either"})," of some error type and (2)\ncreates a new scope in which you can use the ",(0,o.jsx)(n.code,{children:"Raise"})," DSL."]}),"\n",(0,o.jsxs)(n.p,{children:["The second step is that every time that you have an ",(0,o.jsx)(n.code,{children:"Either"})," value\nresulting from another computation (like ",(0,o.jsx)(n.code,{children:"f"})," and ",(0,o.jsx)(n.code,{children:"g"})," above), you need\nto call ",(0,o.jsx)(n.code,{children:"bind"}),". This short-circuits the current calculation in case\nof error and continues with normal execution otherwise.\nIn this style you don't need to use any function to compose computations,\nyou use regular Kotlin idioms with some ",(0,o.jsx)(n.code,{children:"bind"}),"s sprinkled. In fact,\nyou could have written the previous code in one single line:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun foo(n: Int): Either<Error, String> = either {\n  g(f(n).bind()).bind().summarize()\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["How you split your code into local values no longer depends on the\nstructure of your functions, as is the case with ",(0,o.jsx)(n.code,{children:"flatMap"}),", but rather\non the logical decomposition you want to achieve in your code."]}),"\n",(0,o.jsxs)(n.p,{children:["Arrow provides different builders for different return types\n(",(0,o.jsx)(n.code,{children:"either"}),", ",(0,o.jsx)(n.code,{children:"option"}),", ",(0,o.jsx)(n.code,{children:"result"}),"), but regardless of which one you choose\nyou always use ",(0,o.jsx)(n.code,{children:"bind"})," at every step where potential failure is possible."]}),"\n",(0,o.jsxs)(n.admonition,{title:'Why "Raise DSL"?',type:"info",children:[(0,o.jsxs)(n.p,{children:["At this point, you may be surprised that we haven't used the word ",(0,o.jsx)(n.code,{children:"Raise"}),"\nat all in the code, only ",(0,o.jsx)(n.code,{children:"either"})," and ",(0,o.jsx)(n.code,{children:"bind"}),'. To understand why we use\n"',(0,o.jsx)(n.code,{children:"Raise"}),' DSL" to refer to this coding style, we need to dig a bit into\nthe type of the ',(0,o.jsx)(n.code,{children:"either"})," declaration itself."]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun <E, A> either(block: Raise<E>.() -> A): Either<E, A>\n"})}),(0,o.jsxs)(n.p,{children:["The fact that ",(0,o.jsx)(n.code,{children:"Raise<E>"})," appears at the front of the function type\nof ",(0,o.jsx)(n.code,{children:"block"})," (formally, as an ",(0,o.jsx)(n.a,{href:"https://kotlinlang.org/docs/lambdas.html#function-literals-with-receiver",children:"extension receiver"}),")\nmeans that all the functions from the ",(0,o.jsx)(n.code,{children:"Raise<E>"})," interface are available\nimplicitly in the scope of ",(0,o.jsx)(n.code,{children:"block"}),". The function ",(0,o.jsx)(n.code,{children:"bind"})," (alongside\n",(0,o.jsx)(n.code,{children:"raise"}),", ",(0,o.jsx)(n.code,{children:"ensure"}),", ",(0,o.jsx)(n.code,{children:"mapOrAccumulate"}),", and others) lives in that interface."]}),(0,o.jsxs)(n.p,{children:["The pattern of having a parameter with a functional type with receiver\nis not alien to Kotlin, either. Quite the contrary, it is\n",(0,o.jsx)(n.a,{href:"https://kotlinlang.org/docs/type-safe-builders.html",children:"described in the documentation"}),".\nOther well-known libraries in the ecosystem, like ",(0,o.jsx)(n.code,{children:"kotlinx.coroutines"}),"\nalso follow this pattern (in ",(0,o.jsx)(n.code,{children:"coroutineScope"})," or ",(0,o.jsx)(n.code,{children:"flow"}),", for example)."]})]}),"\n",(0,o.jsx)(n.h2,{id:"returning-with-logical-error",children:"Returning with logical error"}),"\n",(0,o.jsxs)(n.p,{children:["Using wrapper types you often have a specific constructor that represents\nthe error case. For example, ",(0,o.jsx)(n.code,{children:"Left"})," signals failure when using ",(0,o.jsx)(n.code,{children:"Either"}),".\nUsing the ",(0,o.jsx)(n.code,{children:"Raise"})," DSL you no longer need to remember each of them,\nfailure is always signaled using ",(0,o.jsx)(n.code,{children:"raise"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun fooThatRaises(n: Int): Either<Error, String> = either {\n  if (n < 0) raise(Error.NegativeInput)\n  val s = f(n).bind()\n  val t = g(s).bind()\n  t.summarize()\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Calling ",(0,o.jsx)(n.code,{children:"raise"})," immediately ends the execution of the current block. In the example\nabove, calling ",(0,o.jsx)(n.code,{children:"fooThatRaises(-1)"})," ends up in ",(0,o.jsx)(n.code,{children:"raise"}),", which in the case of an ",(0,o.jsx)(n.code,{children:"either"})," block\nmeans resulting in ",(0,o.jsx)(n.code,{children:"Either.Left(Error.NegativeInput)"}),"."]}),"\n",(0,o.jsxs)(n.admonition,{title:'Somebody said "exceptions"?',type:"info",children:[(0,o.jsxs)(n.p,{children:["The propagation and early return of the ",(0,o.jsx)(n.code,{children:"Raise"})," scope look similar to exceptions.\nThat is deliberate, for familiarity.  However, they serve a different purpose from exceptions.\nTyped errors should be used for ",(0,o.jsx)(n.em,{children:"logical"})," errors \u2014 problems that have\na place in your domain model \u2014 as opposed to ",(0,o.jsx)(n.em,{children:"exceptional"})," cases \u2014 which represent\ncircumstances that are difficult to recover from."]}),(0,o.jsxs)(n.p,{children:["For a more concrete example, ",(0,o.jsx)(n.code,{children:"Raise"}),' is a good tool to signal problems like\n"user not found in a database". On the other hand, "database connection suddenly dropped"\nshould rather be modeled via exceptions (perhaps combined with ',(0,o.jsx)(n.a,{href:"/learn/resilience",children:"resilience"}),")."]})]}),"\n",(0,o.jsx)(n.p,{children:"By the way, the Raise DSL provides several utility functions for common patterns.\nChecking an assertion and raising if false is one of those; so the most idiomatic\nway to write the code above is:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun fooThatRaises(n: Int): Either<Error, String> = either {\n  ensure(n >= 0) { Error.NegativeInput }\n  val s = f(n).bind()\n  val t = g(s).bind()\n  t.summarize()\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"transforming-the-error-values",children:"Transforming the error values"}),"\n",(0,o.jsxs)(n.p,{children:["The fact that both ",(0,o.jsx)(n.code,{children:"f"})," and ",(0,o.jsx)(n.code,{children:"g"})," share the same ",(0,o.jsx)(n.code,{children:"Error"})," type is key for\nthe previous code blocks to compile. In every ",(0,o.jsx)(n.code,{children:"Raise"})," scope, we have one ",(0,o.jsx)(n.em,{children:"single"}),"\nerror type which you can ",(0,o.jsx)(n.code,{children:"raise"})," or ",(0,o.jsx)(n.code,{children:"bind"})," in the whole block of code.\nIf this is not the case, you have to ",(0,o.jsx)(n.em,{children:"bridge"})," the different error types to each other, which\nis done using functions like ",(0,o.jsx)(n.code,{children:"mapLeft"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun bar(n: Int): Either<Error, String> =\n  f(n).flatMap { s ->\n    h(s).mapLeft { \n      it.toString()\n    }.map { t ->\n      t.summarize()\n    }\n  }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Within the ",(0,o.jsx)(n.code,{children:"Raise"})," DSL, the corresponding function is called ",(0,o.jsx)(n.code,{children:"withError"}),".\nFollowing the discussion above, the ",(0,o.jsx)(n.code,{children:"withError"})," function creates a new\nscope in which the error type is different. The first argument to\n",(0,o.jsx)(n.code,{children:"withError"})," describes how to transform failure values from the inner\nscope error type into the error type of the outer scope."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun bar(n: Int): Either<Error, String> = either {\n  val s = f(n).bind()\n  val t = withError({ boo -> boo.toError() }) { h(s).bind() }\n  t.summarize()\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"more-than-one-failure",children:"More than one failure"}),"\n",(0,o.jsxs)(n.p,{children:['Sometimes you have not one, but many values for which you\nwant to run a potentially-failing computation. Almost every library\nprovides an "effectful map" (usually called ',(0,o.jsx)(n.code,{children:"traverse"}),") to cover those cases."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun foos(xs: List<Int>) = xs.traverse { foo(it) }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Another advantage of the ",(0,o.jsx)(n.code,{children:"Raise"})," DSL is that you don't need all of those\nnew combinators. The regular ",(0,o.jsx)(n.code,{children:"map"})," on lists is enough \u2014 although you\nneed to remember to ",(0,o.jsx)(n.code,{children:"bind"})," each of the values."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun foos(xs: List<Int>) = either {\n  xs.map { foo(it).bind() }\n  // alternatively\n  xs.map { foo(it) }.bindAll()\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This advantage is bigger than just dropping a few function names. Since\nyou don't need specific effectful combinators, you are free to use any\nfunction operating on collections of elements, without restriction."}),"\n",(0,o.jsx)(n.admonition,{title:"Error accumulation",type:"tip",children:(0,o.jsxs)(n.p,{children:["By default ",(0,o.jsx)(n.code,{children:"Raise"})," operates on a fail-first basis: once a failure is ",(0,o.jsx)(n.code,{children:"raise"}),"d,\nthe whole block comes to a halt. If you are operating on a collection, this\nmeans that only the first error is reported. If you need to ",(0,o.jsx)(n.em,{children:"accumulate"}),"\nall errors that arise in some block, you need to switch to ",(0,o.jsx)(n.code,{children:"mapOrAccumulate"}),".\nMore information can be found in the\n",(0,o.jsx)(n.a,{href:"/learn/typed-errors/working-with-typed-errors#accumulating-errors",children:"Working with typed errors"})," page."]})}),"\n",(0,o.jsxs)(n.h2,{id:"either-and-bind-no-more",children:[(0,o.jsx)(n.code,{children:"Either"})," and ",(0,o.jsx)(n.code,{children:"bind"})," no more"]}),"\n",(0,o.jsxs)(n.p,{children:["Until this point, we were using the ",(0,o.jsx)(n.code,{children:"Raise"})," DSL to combine different ",(0,o.jsx)(n.code,{children:"Either"}),"\ncomputations, with the goal of producing yet another ",(0,o.jsx)(n.code,{children:"Either"}),". The frontier\nbetween both styles requires the use of ",(0,o.jsx)(n.code,{children:"bind"}),"; but if you go full-on with\n",(0,o.jsx)(n.code,{children:"Raise"}),", we can even remove those. In that case, the error type appears\nas the extension receiver, instead of wrapping the return type."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun Raise<Error>.f(n: Int): String\nfun Raise<Error>.g(s: String): Thing\nfun Raise<Boo>.h(s: String): Thing\nfun Thing.summarize(): String\n"})}),"\n",(0,o.jsxs)(n.p,{children:['As a consequence of return types being "bare", we can use them directly,\nwithout the mediation of ',(0,o.jsx)(n.code,{children:"bind"}),". The last of our examples reads now as:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun Raise<Error>.bar(n: Int): String {\n  val s = f(n)\n  val t = withError({ boo -> boo.toError() }) { h(s) }\n  return t.summarize()\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We encourage you to use this style, especially for non-public parts of your\ncode, instead of continuously using ",(0,o.jsx)(n.code,{children:"either"})," and ",(0,o.jsx)(n.code,{children:"bind"}),". Apart from the\nstylistic improvement, it also avoids wrapping and unwrapping\n",(0,o.jsx)(n.code,{children:"Right"})," and ",(0,o.jsx)(n.code,{children:"Left"})," values."]}),"\n",(0,o.jsxs)(n.admonition,{title:"More than one receiver",type:"warning",children:[(0,o.jsx)(n.p,{children:"Unfortunately, the current Kotlin language does not allow for more than\none receiver. That means that you cannot easily turn a function like this:"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun Thing.problematic(): Either<Error, String>\n"})}),(0,o.jsxs)(n.p,{children:["into a similar version but with ",(0,o.jsx)(n.code,{children:"Raise<Error>"})," as a receiver. There is\nan ongoing proposal, ",(0,o.jsx)(n.a,{href:"https://github.com/Kotlin/KEEP/blob/context-parameters/proposals/context-parameters.md",children:"context parameters"}),",\nwhich shall hopefully drop this restriction. Until then though, your best resort\nis to move the original receiver into an argument."]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun Raise<Error>.problematic(thing: Thing): String\n"})})]})]})}function d(e={}){let{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},28453:function(e,n,r){r.d(n,{R:()=>s,x:()=>a});var i=r(96540);let o={},t=i.createContext(o);function s(e){let n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);