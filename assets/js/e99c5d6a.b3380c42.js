"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([["7594"],{35786:function(e,n,t){t.r(n),t.d(n,{metadata:()=>a,default:()=>h,frontMatter:()=>i,contentTitle:()=>o,toc:()=>c,assets:()=>l});var a=JSON.parse('{"id":"learn/immutable-data/traversal","title":"Traversals","description":"The framework laid out by optics extends very nicely to values like lists, which","source":"@site/content/docs/learn/immutable-data/traversal.md","sourceDirName":"learn/immutable-data","slug":"/learn/immutable-data/traversal","permalink":"/learn/immutable-data/traversal","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"learnSidebar","previous":{"title":"Optionals","permalink":"/learn/immutable-data/optional"},"next":{"title":"Prisms & Isos","permalink":"/learn/immutable-data/prism-iso"}}'),s=t(74848),r=t(28453);let i={sidebar_position:4},o="Traversals",l={},c=[{value:"<code>Every</code> element in a collection",id:"every-element-in-a-collection",level:2},{value:"More than <code>getAll</code>",id:"more-than-getall",level:2}];function d(e){let n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"traversals",children:"Traversals"})}),"\n",(0,s.jsx)(n.p,{children:"The framework laid out by optics extends very nicely to values like lists, which\nmay contain any potential number of elements. Traversals is the name of that kind of\noptic."}),"\n",(0,s.jsx)(n.admonition,{title:"In a rush?",type:"info",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Traversals focus on an indefinite number of values."}),"\n",(0,s.jsxs)(n.li,{children:["To access all the values, use ",(0,s.jsx)(n.code,{children:"getAll"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Traversals provide an API similar to those of collections."}),"\n",(0,s.jsxs)(n.li,{children:["To modify every value focused by the traversal, use ",(0,s.jsx)(n.code,{children:"modify"}),"."]}),"\n"]})}),"\n",(0,s.jsxs)(n.h2,{id:"every-element-in-a-collection",children:[(0,s.jsx)(n.code,{children:"Every"})," element in a collection"]}),"\n",(0,s.jsxs)(n.p,{children:["As with other kinds of optics, ",(0,s.jsx)(n.code,{children:"Traversal<T, A>"})," represents a reference to elements\nof type ",(0,s.jsx)(n.code,{children:"A"})," within a larger structure of type ",(0,s.jsx)(n.code,{children:"T"}),". As hinted above, most\ntraversals arise from focusing on elements in a collection; in Arrow Optics,\nthose basic traversals live in the ",(0,s.jsx)(n.code,{children:"Every"})," object."]}),"\n",(0,s.jsx)(n.p,{children:"Let's introduce a small data class for our examples:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"@optics data class Person(val name: String, val age: Int, val friends: List<Person>) {\n  companion object\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If we want to update the age of every ",(0,s.jsx)(n.code,{children:"Person"})," in a list, the usual way is to\nuse the ",(0,s.jsx)(n.code,{children:"map"})," function from the standard library."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun List<Person>.happyBirthdayMap(): List<Person> =\n  map { Person.age.modify(it) { age -> age + 1 } }\n"})}),"\n",(0,s.jsx)(n.p,{children:"The same code can be rewritten using only optics by leveraging a traversal for\nlists."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun List<Person>.happyBirthdayOptics(): List<Person> =\n  Every.list<Person>().age.modify(this) { age -> age + 1 }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Traversals become more useful when composed with other optics. Imagine that we\nwant to update the age of all the friends of a ",(0,s.jsx)(n.code,{children:"Person"}),"; the usual implementation\nwith ",(0,s.jsx)(n.code,{children:"map"})," and ",(0,s.jsx)(n.code,{children:"copy"})," becomes quite complex."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun Person.happyBirthdayFriends(): Person =\n  copy(\n    friends = friends.map { friend -> friend.copy(age = friend.age + 1) }\n  )\n"})}),"\n",(0,s.jsx)(n.p,{children:"The implementation using optics hides all the complexity related to mapping\nand copying, and simply focuses on the path to access the values."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun Person.happyBirthdayFriendsOptics(): Person =\n  Person.friends.every.age.modify(this) { it + 1 }\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"Every(List)",type:"note",children:(0,s.jsxs)(n.p,{children:["In versions prior to 2.0, ",(0,s.jsx)(n.code,{children:".every"})," required an additional argument specifying\nthe type of traversal. So one would write ",(0,s.jsx)(n.code,{children:"Person.friends.every(Every.list())"}),".\nThis problem was related to ",(0,s.jsx)(n.a,{href:"https://kotlinlang.org/docs/generics.html#type-erasure",children:"type erasure"}),",\nbut fortunately, a new encoding was found without this caveat."]})}),"\n",(0,s.jsxs)(n.h2,{id:"more-than-getall",children:["More than ",(0,s.jsx)(n.code,{children:"getAll"})]}),"\n",(0,s.jsxs)(n.p,{children:["The counterpart to ",(0,s.jsx)(n.code,{children:"get"})," and ",(0,s.jsx)(n.code,{children:"getOrNull"})," when speaking about traversals is called\n",(0,s.jsx)(n.code,{children:"getAll"}),", and returns a list of focused elements. But you don't always have to\ngo through an intermediate list to obtain information about the elements focused\nby a ",(0,s.jsx)(n.code,{children:"Traversal"}),", we provide a ",(0,s.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-optics/arrow.optics/-getter/index.html",children:"large API"}),"\nbased on Kotlin's collections in the standard library."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, you can call ",(0,s.jsx)(n.code,{children:"isEmpty"})," to check whether the traversal matches any\nelement. Or, more generally, you can call ",(0,s.jsx)(n.code,{children:"size"}),' to obtain the number of elements\nit matches. Note that, in any case, these operations are "optics-first", so\nyou need to provide the value they operate on as an argument.']})]})}function h(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:function(e,n,t){t.d(n,{R:()=>i,x:()=>o});var a=t(96540);let s={},r=a.createContext(s);function i(e){let n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);