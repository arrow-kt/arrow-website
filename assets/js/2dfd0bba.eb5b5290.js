"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[9601],{11802:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});var t=s(85893),o=s(11151);const a={sidebar_position:2},r="Lenses",i={id:"learn/immutable-data/lens",title:"Lenses",description:"Lenses are the most common type of optic you work with. This section discusses",source:"@site/content/docs/learn/immutable-data/lens.md",sourceDirName:"learn/immutable-data",slug:"/learn/immutable-data/lens",permalink:"/learn/immutable-data/lens",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/immutable-data/lens.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"learnSidebar",previous:{title:"Introduction",permalink:"/learn/immutable-data/intro"},next:{title:"Optionals",permalink:"/learn/immutable-data/optional"}},l={},d=[{value:"The <code>Lens</code> type",id:"the-lens-type",level:2},{value:"Operations",id:"operations",level:2},{value:"Composition",id:"composition",level:3},{value:"More powerful <code>copy</code>",id:"more-powerful-copy",level:3},{value:"Sealed class hierarchies",id:"sealed-class-hierarchies",level:2},{value:"Integration with Compose",id:"integration-with-compose",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"lenses",children:"Lenses"}),"\n",(0,t.jsx)(n.p,{children:"Lenses are the most common type of optic you work with. This section discusses\nthem at length."}),"\n",(0,t.jsx)(n.admonition,{title:"In a rush?",type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Lenses represent references to fields."}),"\n",(0,t.jsxs)(n.li,{children:["To access the value, use ",(0,t.jsx)(n.code,{children:"get"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["To modify the value, use ",(0,t.jsx)(n.code,{children:"set"})," and ",(0,t.jsx)(n.code,{children:"modify"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["To modify several elements at once, use ",(0,t.jsx)(n.code,{children:"copy"}),"."]}),"\n"]})}),"\n",(0,t.jsxs)(n.h2,{id:"the-lens-type",children:["The ",(0,t.jsx)(n.code,{children:"Lens"})," type"]}),"\n",(0,t.jsxs)(n.p,{children:["We've mentioned in the ",(0,t.jsx)(n.a,{href:"../intro",children:"introduction"})," that optics are ",(0,t.jsx)(n.em,{children:"values"})," that\nrepresent access to data. You can draw parallels with how function values\nrepresent behavior."]}),"\n",(0,t.jsxs)(n.p,{children:["Let's introduce a few data classes and kindly ask the Arrow Optics plug-in to\ngenerate lenses for every field by having an ",(0,t.jsx)(n.code,{children:"@optics"})," annotation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"import arrow.optics.*\n\n@optics data class Person(val name: String, val age: Int, val address: Address) {\n  companion object\n}\n@optics data class Address(val street: Street, val city: City) {\n  companion object\n}\n@optics data class Street(val name: String, val number: Int?) {\n  companion object\n}\n@optics data class City(val name: String, val country: String) {\n  companion object\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The lenses are generated in the companion object, so you can think of your\n",(0,t.jsx)(n.code,{children:"Person"})," being extended as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"data class Person(val name: String, val age: Int, val address: Address) {\n  companion object {\n    val name: Lens<Person, String> = TODO()\n    val age: Lens<Person, Int> = TODO()\n    val address: Lens<Person, Address> = TODO()\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Notice that lenses in Arrow are ",(0,t.jsx)(n.em,{children:"typed"}),', which means that they "know"\nboth the type of the larger value and the type of the element we focus on.']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plain",children:"                  \u21b1 this lens operates on 'Person'\nval address: Lens<Person, Address>\n                          \u21b3 this lens gives access to an 'Address' value\n"})}),"\n",(0,t.jsx)(n.h2,{id:"operations",children:"Operations"}),"\n",(0,t.jsx)(n.p,{children:"Lenses provide three primary operations:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"get"})," obtains the elements focused on a lens."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"set"})," changes the value of the focus to a new one."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"modify"})," transforms the value of the focus by applying a given function."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Code speaks louder than words (well, sometimes). Here's a small snippet showcasing\nthe three operations applied to an instance of our ",(0,t.jsx)(n.code,{children:"Person"})," class. Notice how\nthe three operations live on the lens and get the value they operate on as an\nargument."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'fun example() {\n  val me = Person(\n    "Alejandro", 35, \n    Address(Street("Kotlinstraat", 1), City("Hilversum", "Netherlands"))\n  )\n\n  Person.name.get(me) shouldBe "Alejandro"\n  \n  val meAfterBirthdayParty = Person.age.modify(me) { it + 1 }\n  Person.age.get(meAfterBirthdayParty) shouldBe 36\n\n  val newAddress = Address(Street("Kotlinplein", null), City("Amsterdam", "Netherlands"))\n  val meAfterMoving = Person.address.set(me, newAddress)\n  Person.address.get(meAfterMoving) shouldBe newAddress\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"composition",children:"Composition"}),"\n",(0,t.jsxs)(n.p,{children:["The power of lenses (and optics in general) lies in the ability to ",(0,t.jsx)(n.em,{children:"compose"}),"\nthem to get to nested values. The type parameters in ",(0,t.jsx)(n.code,{children:"Lens"})," ensure that the\ncomposition accesses values that are really there. For example, here's a lens\nthat focuses on the city where a ",(0,t.jsx)(n.code,{children:"Person"})," lives:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'val personCity: Lens<Person, String> =\n  Person.address compose Address.city compose City.name\n\nfun example() {\n  val me = Person(\n    "Alejandro", 35, \n    Address(Street("Kotlinstraat", 1), City("Hilversum", "Netherlands"))\n  )\n\n  personCity.get(me) shouldBe "Hilversum"\n  val meAtTheCapital = personCity.set(me, "Amsterdam")\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"compose"})," infix function is an integral part of the library, but you almost\nnever see it mentioned explicitly. As part of its job, the Arrow Optics compiler\nplug-in introduces additional extension functions that allow you to use the\nregular dot operation to access composed lenses. The code above can be rewritten\nin that form:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'fun example() {\n  val me = Person(\n    "Alejandro", 35, \n    Address(Street("Kotlinstraat", 1), City("Hilversum", "Netherlands"))\n  )\n\n  Person.address.city.name.get(me) shouldBe "Hilversum"\n  val meAtTheCapital = Person.address.city.name.set(me, "Amsterdam")\n}\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"more-powerful-copy",children:["More powerful ",(0,t.jsx)(n.code,{children:"copy"})]}),"\n",(0,t.jsxs)(n.p,{children:["Everything we've discussed to this point is enough to make the transformation\nof nested data much nicer without the nesting of nested ",(0,t.jsx)(n.code,{children:"copy"})," calls. However,\nif we need to modify more than one field, we must nest calls to ",(0,t.jsx)(n.code,{children:"set"})," or ",(0,t.jsx)(n.code,{children:"modify"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'fun Person.moveToAmsterdamModify(): Person =\n  Person.address.city.name.set(\n    Person.address.city.country.set(this, "Netherlands"),\n    "Amsterdam"\n  )\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Arrow Optics provides a ",(0,t.jsx)(n.code,{children:"copy"})," function that replicates the\nbuilt-in ",(0,t.jsx)(n.code,{children:"copy"})," ability to modify more than one field. The syntax is slightly different,\nthough. After the ",(0,t.jsx)(n.code,{children:"copy"}),", you need to start a block. And within that block, you\ncan use the name of a lens to perform an operation."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'fun Person.moveToAmsterdamCopy(): Person = copy {\n  Person.address.city.name set "Amsterdam"\n  Person.address.city.country set "Netherlands"\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Another nicety is that you can condense those operations that share\npart of the journey to their focus. In our case, we are modifying two elements\nin ",(0,t.jsx)(n.code,{children:"address.city"}),", which we can join using ",(0,t.jsx)(n.code,{children:"inside"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'fun Person.moveToAmsterdamInside(): Person = copy {\n  inside(Person.address.city) {\n    City.name set "Amsterdam"\n    City.country set "Netherlands"\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"sealed-class-hierarchies",children:"Sealed class hierarchies"}),"\n",(0,t.jsx)(n.p,{children:"If you have a set of classes with a common sealed parent, then lenses\ncan be generated for those properties shared by all of them.\nThose properties must appear already in the common parent."}),"\n",(0,t.jsxs)(n.p,{children:["For example, the plug-in generates a lens of the ",(0,t.jsx)(n.code,{children:"name"})," field given\nthe code below. This lens complements the ",(0,t.jsx)(n.a,{href:"../prism-iso",children:"prisms"}),"\nthat are generated to focus on each of the two subclasses."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"@optics sealed interface SUser {\n  val name: String\n\n  companion object\n}\n\n@optics data class SPerson(\n  override val name: String,\n  val age: Int\n): SUser {\n  companion object\n}\n\n@optics data class SCompany(\n  override val name: String,\n  val vat: VATNumber\n): SUser {\n  companion object\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"integration-with-compose",children:"Integration with Compose"}),"\n",(0,t.jsxs)(n.p,{children:["If you are using Compose, either in ",(0,t.jsx)(n.a,{href:"https://developer.android.com/jetpack/compose",children:"Android"}),"\nor ",(0,t.jsx)(n.a,{href:"https://www.jetbrains.com/lp/compose-multiplatform/",children:"Multiplaftorm"}),"\nflavors, you often need to update a ",(0,t.jsx)(n.a,{href:"https://developer.android.com/jetpack/compose/state",children:(0,t.jsx)(n.code,{children:"MutableState"})}),"\nby applying some modification to the previous value.\nThe ",(0,t.jsx)(n.code,{children:"arrow-optics-compose"})," package provides a version of\n",(0,t.jsx)(n.code,{children:"copy"})," useful in those situations."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"class AppViewModel: ViewModel() {\n  private val _personData = mutableStateOf<Person>(...)\n\n  fun updatePersonalData(\n    newName: String, newAge: Int\n  ) {\n    _personData.updateCopy {\n      Person.name set newName\n      Person.age set newAge\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{title:"Compose and Snapshots",type:"note",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"updateCopy"})," uses the ",(0,t.jsx)(n.a,{href:"https://dev.to/zachklipp/introduction-to-the-compose-snapshot-system-19cn",children:"snapshot system"}),"\nin Compose to ensure that all the modifications in the\nblock happen atomically."]})})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>i,a:()=>r});var t=s(67294);const o={},a=t.createContext(o);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);