"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[334],{23450:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var s=i(85893),t=i(11151);const o={title:"Domain modeling",sidebar_position:1},a=void 0,r={id:"learn/design/domain-modeling",title:"Domain modeling",description:"The goal of functional domain modeling is to describe your business domain as accurately as possible to achieve more type-safety, maximize the use of the compiler with our domain and, thus, prevent bugs and reduce unit testing. Additionally, it makes communicating about the domain easier since the domain is the touchpoint with the real world. Kotlin is a good fit for functional domain modeling. It offers us data class, sealed class, enum class, and value class. And we have Arrow, which provides some interesting generic data types such as Either and Ior.",source:"@site/content/docs/learn/design/domain-modeling.md",sourceDirName:"learn/design",slug:"/learn/design/domain-modeling",permalink:"/learn/design/domain-modeling",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/design/domain-modeling.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Domain modeling",sidebar_position:1},sidebar:"learnSidebar",previous:{title:"Design",permalink:"/learn/design/"},next:{title:"Effects and contexts",permalink:"/learn/design/effects-contexts"}},l={},d=[];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components},{Head:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i,{children:(0,s.jsx)("link",{rel:"canonical",href:"https://www.47deg.com/blog/functional-domain-modeling/"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.mdxAdmonitionTitle,{children:["This article was originally published in the ",(0,s.jsx)(n.a,{href:"https://www.47deg.com/blog/functional-domain-modeling/",children:"47 Degrees blog"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["The goal of functional domain modeling is to describe your business domain as accurately as possible to achieve more type-safety, maximize the use of the compiler with our domain and, thus, prevent bugs and reduce unit testing. Additionally, it makes communicating about the domain easier since the domain is the touchpoint with the real world. Kotlin is a good fit for functional domain modeling. It offers us ",(0,s.jsx)(n.code,{children:"data class"}),", ",(0,s.jsx)(n.code,{children:"sealed class"}),", ",(0,s.jsx)(n.code,{children:"enum class"}),", and ",(0,s.jsx)(n.code,{children:"value class"}),". And we have Arrow, which provides some interesting generic data types such as ",(0,s.jsx)(n.code,{children:"Either"})," and ",(0,s.jsx)(n.code,{children:"Ior"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In some codebases, you can find the following primitive type-based implementation of an ",(0,s.jsx)(n.code,{children:"Event"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"data class Event(\n  val id: Long,\n  val title: String,\n  val organizer: String,\n  val description: String,\n  val date: LocalDate\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The types used here have little or no meaning since ",(0,s.jsx)(n.code,{children:"title"}),", ",(0,s.jsx)(n.code,{children:"organizer"}),", and ",(0,s.jsx)(n.code,{children:"description"})," all share the same type. This makes our code prone to subtle bugs where we might rely on ",(0,s.jsx)(n.code,{children:"title"})," instead of ",(0,s.jsx)(n.code,{children:"description"}),", and the compiler would not be able to help us. Let's look at an example where things go wrong without the compiler being able to help us."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'Event(\n  0L,\n  "Simon Vergauwen",\n  "In this blogpost we dive into functional DDD...",\n  "Functional Domain Modeling",\n  LocalDate.now()\n)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Here, we have mixed up ",(0,s.jsx)(n.code,{children:"organizer"}),"and ",(0,s.jsx)(n.code,{children:"description"}),", but the compiler is happy and constructs the ",(0,s.jsx)(n.code,{children:"Event"})," object. There are more cases where you can fall into this trap; for example, when destructuring."]}),"\n",(0,s.jsxs)(n.p,{children:["So how do we prevent this from happening, or how can we improve our domain model to be better typed? We use ",(0,s.jsx)(n.code,{children:"value class"}),", Kotlin's feature to disguise an already-existing type under a new name. Doing this causes no additional overhead since ",(0,s.jsx)(n.code,{children:"value class"})," is erased at runtime. At the moment of writing, every appearance of ",(0,s.jsx)(n.code,{children:"value class"})," requires a corresponding ",(0,s.jsx)(n.code,{children:"@JvmInline"})," annotation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"@JvmInline value class EventId(val value: Long)\n@JvmInline value class Organizer(val value: String)\n@JvmInline value class Title(val value: String)\n@JvmInline value class Description(val value: String)\n\ndata class Event(\n  val id: EventId,\n  val title: Title,\n  val organizer: Organizer,\n  val description: Description,\n  val date: LocalDate\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If we go back to our previous example, the compiler now fails to compile since we pass ",(0,s.jsx)(n.code,{children:"Organizer "})," where ",(0,s.jsx)(n.code,{children:"Title"})," is expected, ",(0,s.jsx)(n.code,{children:"Description"})," where ",(0,s.jsx)(n.code,{children:"Organizer"})," is expected, and so on."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'Event(\n  EventId(0L),\n  Organizer("Simon Vergauwen"),\n  Description("In this blogpost we dive into functional DDD..."),\n  Title("Functional Domain Modeling"),\n  LocalDate.now()\n)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In functional programming, this type of data composition is also known as a ",(0,s.jsx)(n.strong,{children:"product type"})," or a ",(0,s.jsx)(n.strong,{children:"record"}),", which models an ",(0,s.jsx)(n.em,{children:"and"})," relationship.\nSo we can say that an ",(0,s.jsx)(n.code,{children:"Event"})," exists out of an ",(0,s.jsx)(n.code,{children:"EventId"})," ",(0,s.jsx)(n.em,{children:"and"})," a ",(0,s.jsx)(n.code,{children:"Title"})," ",(0,s.jsx)(n.em,{children:"and"})," an ",(0,s.jsx)(n.code,{children:"Organizer"})," ",(0,s.jsx)(n.em,{children:"and"})," a ",(0,s.jsx)(n.code,{children:"Description"})," ",(0,s.jsx)(n.em,{children:"and"})," a ",(0,s.jsx)(n.code,{children:"LocalDate"}),", which tells us much more than an ",(0,s.jsx)(n.code,{children:"Event"})," that exists out of a ",(0,s.jsx)(n.code,{children:"Long"})," ",(0,s.jsx)(n.em,{children:"and"})," a ",(0,s.jsx)(n.code,{children:"String"})," ",(0,s.jsx)(n.em,{children:"and"})," a ",(0,s.jsx)(n.code,{children:"String"})," ",(0,s.jsx)(n.em,{children:"and"})," a ",(0,s.jsx)(n.code,{children:"String"})," ",(0,s.jsx)(n.em,{children:"and"})," a ",(0,s.jsx)(n.code,{children:"LocalDate"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's say we must evolve our ",(0,s.jsx)(n.code,{children:"Event"})," model to keep track of any age restrictions. We could model this with ",(0,s.jsx)(n.code,{children:"String"})," again, but that would only worsen our original problem. So let's say we follow the ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Motion_Picture_Association_film_rating_system",children:"MPAA film ratings"}),", which is an enumeration of 5 different cases. Since we're clearly talking about a ",(0,s.jsx)(n.em,{children:"fixed set"})," of cases, or enumeration, we use an ",(0,s.jsx)(n.code,{children:"enum class"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'enum class AgeRestriction(val description: String) {\n  General("All ages admitted. Nothing that would offend parents for viewing by children."),\n  PG("Some material may not be suitable for children. Parents urged to give \\"parental guidance\\""),\n  PG13("Some material may be inappropriate for children under 13. Parents are urged to be cautious."),\n  Restricted("Under 17 requires accompanying parent or adult guardian. Contains some adult material."),\n  NC17("No One 17 and Under Admitted. Clearly adult.")\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Using an ",(0,s.jsx)(n.code,{children:"enum class"})," is much more powerful than ",(0,s.jsx)(n.code,{children:"String"})," for reasons beyond the problems we already explained above. A ",(0,s.jsx)(n.code,{children:"String"})," has infinite possible values, but now we only have five possible ones.\nSo it's much easier to reason about ",(0,s.jsx)(n.code,{children:"AgeRestriction"})," than to reason and work with ",(0,s.jsx)(n.code,{children:"String"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In functional programming, this type of data composition is also known as a ",(0,s.jsx)(n.strong,{children:"sum type"}),", which models an ",(0,s.jsx)(n.em,{children:"or"})," relationship.\nSo we can say that an ",(0,s.jsx)(n.code,{children:"AgeRestriction "}),"is either ",(0,s.jsx)(n.code,{children:"General"})," ",(0,s.jsx)(n.em,{children:"or"})," ",(0,s.jsx)(n.code,{children:"PG"})," ",(0,s.jsx)(n.em,{children:"or"})," ",(0,s.jsx)(n.code,{children:"PG13"})," ",(0,s.jsx)(n.em,{children:"or"})," ",(0,s.jsx)(n.code,{children:"Restricted"})," ",(0,s.jsx)(n.em,{children:"or"})," ",(0,s.jsx)(n.code,{children:"NC17"}),".\nThis tells us much more than if it was just a ",(0,s.jsx)(n.code,{children:"String"}),". A ",(0,s.jsx)(n.code,{children:"String"})," would have infinite values, while ",(0,s.jsx)(n.code,{children:"AgeRestriction"})," modeled as an ",(0,s.jsx)(n.code,{children:"enum class"})," only has five different values.\nSo using sum types can drastically reduce the complexity of our types."]}),"\n",(0,s.jsxs)(n.p,{children:["With online events on the rise, we have a different kind of event that doesn't occur at an ",(0,s.jsx)(n.code,{children:"Address"}),", but rather at a certain ",(0,s.jsx)(n.code,{children:"Url"}),". So, depending on what kind of ",(0,s.jsx)(n.code,{children:"Event"})," it is, the data inside will be slightly different. Naively we could implement this as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"@JvmInline value class Url(val value: String)\n\n@JvmInline value class City(val value: String)\n@JvmInline value class Street(val value: String)\ndata class Address(val city: City, val street: Street)\n\ndata class Event(\n  val id: EventId,\n  val title: Title,\n  val organizer: Organizer,\n  val description: Description,\n  val date: LocalDate,\n  val ageRestriction: AgeRestriction,\n  val isOnline: Boolean,\n  val url: Url?,\n  val address: Address?\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is a common encoding, but it can be pretty problematic. If ",(0,s.jsx)(n.code,{children:"isOnline"})," is ",(0,s.jsx)(n.code,{children:"true"}),", ",(0,s.jsx)(n.code,{children:"url"})," will be non-",(0,s.jsx)(n.code,{children:"null"})," and vice-versa for ",(0,s.jsx)(n.code,{children:"address"}),". However, after checking ",(0,s.jsx)(n.code,{children:"isOnline"}),", both ",(0,s.jsx)(n.code,{children:"url"})," and ",(0,s.jsx)(n.code,{children:"address"})," is still null, so we'll end up with code like this."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun printLocation(event: Event): Unit =\n  if(event.isOnline) {\n    event.url?.value?.let(::println)\n  } else {\n    event.address?.let(::println)\n  }\n"})}),"\n",(0,s.jsx)(n.p,{children:"But, even worse, we can also easily break the intended contract, like in the example below."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'Event(\n\tId(0L),\n\tTitle("Functional Domain Modeling"),\n\tOrganizer("47 Degrees"),\n\tDescription("Building software with functional DDD..."),\n\tLocalDate.now(),\n\tAgeRestriction.General,\n\ttrue,\n\tnull,\n\tnull\n)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The compiler is happy with the below definition, even though our intended contract said that, if it's ",(0,s.jsx)(n.code,{children:"isOnline"}),", then ",(0,s.jsx)(n.code,{children:"url"})," would be non-",(0,s.jsx)(n.code,{children:"null"}),".\nWe can prevent this issue by introducing a ",(0,s.jsx)(n.code,{children:"sealed class"})," to combine ",(0,s.jsx)(n.code,{children:"Event.Online"})," and ",(0,s.jsx)(n.code,{children:"Event.AtAddress"})," in a typed way."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"sealed class Event {\n  abstract val id: EventId\n  abstract val title: Title\n  abstract val organizer: Organizer\n  abstract val description: Description\n  abstract val ageRestriction: AgeRestriction\n  abstract val date: LocalDate\n\n  data class Online(\n    override val id: EventId,\n    override val title: Title,\n    override val organizer: Organizer,\n    override val description: Description,\n    override val ageRestriction: AgeRestriction,\n    override val date: LocalDate,\n    val url: Url\n  ) : Event()\n\n  data class AtAddress(\n    override val id: EventId,\n    override val title: Title,\n    override val organizer: Organizer,\n    override val description: Description,\n    override val ageRestriction: AgeRestriction,\n    override val date: LocalDate,\n    val address: Address\n  ) : Event()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This solves our previous issue, where we can instantiate an online ",(0,s.jsx)(n.code,{children:"Event"})," without an ",(0,s.jsx)(n.code,{children:"Url"}),", and offers a much nicer way of working with the data. Instead of ",(0,s.jsx)(n.code,{children:"if(event.isOnline)"}),", we can now use an exhaustive ",(0,s.jsx)(n.code,{children:"when"})," to pattern match on ",(0,s.jsx)(n.code,{children:"Event"}),", and due to Kotlin's smart casting, we can safely access ",(0,s.jsx)(n.code,{children:"url"})," in the case that it's ",(0,s.jsx)(n.code,{children:"Event.Online"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'fun printLocation(event: Event): Unit =\n  when(event) {\n  \tis Online -> println(event.url.value)\n  \tis AtAddress -> println("${event.address.city}: ${event.address.street}")\n  }\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This type of data composition is also known as a ",(0,s.jsx)(n.strong,{children:"sum type"}),", which models an ",(0,s.jsx)(n.em,{children:"or"})," relationship, but ",(0,s.jsx)(n.code,{children:"sealed class"})," offers us more powerful capabilities than ",(0,s.jsx)(n.code,{children:"enum class"}),".\nA ",(0,s.jsx)(n.code,{children:"sealed class"})," allows ",(0,s.jsx)(n.em,{children:"cases"})," to exist out of ",(0,s.jsx)(n.code,{children:"object"}),", ",(0,s.jsx)(n.code,{children:"data class"}),", or even another ",(0,s.jsx)(n.code,{children:"sealed class"}),". An ",(0,s.jsx)(n.code,{children:"enum class"})," cannot extend another class, so it cannot be a ",(0,s.jsx)(n.em,{children:"case"})," of a ",(0,s.jsx)(n.code,{children:"sealed class"}),".\nHere, our ",(0,s.jsx)(n.code,{children:"sealed class"})," exists out of 2 ",(0,s.jsx)(n.em,{children:"cases"}),", an ",(0,s.jsx)(n.code,{children:"Online"})," ",(0,s.jsx)(n.em,{children:"or"})," ",(0,s.jsx)(n.code,{children:"AtAddress"})," ",(0,s.jsx)(n.code,{children:"Event"}),", where ",(0,s.jsx)(n.code,{children:"Online"})," and ",(0,s.jsx)(n.code,{children:"AtAddress"})," are ",(0,s.jsx)(n.strong,{children:"product types"})," of several other types.\nA rule of thumb in Kotlin is to use an ",(0,s.jsx)(n.code,{children:"enum class"})," when the ",(0,s.jsx)(n.em,{children:"cases"})," don't contain any data or, in other words, if all ",(0,s.jsx)(n.em,{children:"cases"})," can be modeled as ",(0,s.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"As we've already seen in the examples above, modeling your domain precisely has many benefits. It can eliminate specific bugs, such as instantiating data incorrectly. It makes our code/model easier to reason about by eliminating invalid values, and it can improve code relying on our models."}),"\n",(0,s.jsxs)(n.p,{children:["Let's look at how we can use Arrow's data types to clarify our code's domain problems further. Our program has some ",(0,s.jsx)(n.code,{children:"EventService"})," that can fetch an upcoming ",(0,s.jsx)(n.code,{children:"Event"})," based on an ",(0,s.jsx)(n.code,{children:"EventId"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"interface EventService {\n  suspend fun fetchUpcomingEvent(id: EventId): Event\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["What is completely missing from our ",(0,s.jsx)(n.code,{children:"EventService"})," is the different kinds of error scenarios we could encounter. It's only modeled through ",(0,s.jsx)(n.code,{children:"Throwable"})," in ",(0,s.jsx)(n.code,{children:"suspend"}),". So if we'd want to model the error domain explicitly, we could use any of the techniques we've already seen above."]}),"\n",(0,s.jsx)(n.p,{children:"Here, we model 2 different cases:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"An event is not found."}),"\n",(0,s.jsx)(n.li,{children:"An event is no longer upcoming but has already happened."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"sealed class Error {\n  data class EventNotFound(val id: EventId): Error()\n  data class EventPassed(val event: Event): Error()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We can compose these separate domains, ",(0,s.jsx)(n.code,{children:"Error"})," and ",(0,s.jsx)(n.code,{children:"Event"}),", using ",(0,s.jsx)(n.code,{children:"Either"})," from ",(0,s.jsx)(n.code,{children:"Arrow Core"}),". This allows us to model an ",(0,s.jsx)(n.em,{children:"or"})," relationship, meaning that ",(0,s.jsx)(n.code,{children:"fetchUpcomingEvent"})," ",(0,s.jsx)(n.em,{children:"either"})," returns an ",(0,s.jsx)(n.code,{children:"Error"})," ",(0,s.jsx)(n.em,{children:"or"})," an ",(0,s.jsx)(n.code,{children:"Event"}),", but never both. So ",(0,s.jsx)(n.code,{children:"Either"})," is a ",(0,s.jsx)(n.strong,{children:"generic"})," sum type, which allows us to generically compose two separate domains with each other in an ",(0,s.jsx)(n.em,{children:"or"})," relationship."]}),"\n",(0,s.jsxs)(n.p,{children:["So, if we update our ",(0,s.jsx)(n.code,{children:"EventService"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"interface EventService {\n  suspend fun fetchUpcomingEvent(id: EventId): Either<Error, Event>\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"Either"})," is defined as a ",(0,s.jsx)(n.code,{children:"sealed class"})," in ",(0,s.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-core/index.html",children:"Arrow Core"}),", we can use the same technique we used above with ",(0,s.jsx)(n.code,{children:"when"})," to extract the ",(0,s.jsx)(n.code,{children:"Error"})," or ",(0,s.jsx)(n.code,{children:"Event"})," in a safe way."]}),"\n",(0,s.jsx)(n.p,{children:"In this article, we've seen how we can improve our domain by:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Eliminating primitive types in our domain definition and using ",(0,s.jsx)(n.code,{children:"value class"})," to prevent runtime overhead."]}),"\n",(0,s.jsxs)(n.li,{children:["Using ",(0,s.jsx)(n.code,{children:"enum class"})," and ",(0,s.jsx)(n.code,{children:"sealed class"})," to model disjunctions in our domain, such as certain data being available depending on the type of ",(0,s.jsx)(n.code,{children:"Event"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Utilizing Arrow's ",(0,s.jsx)(n.code,{children:"Either"})," to compose two different domains with an ",(0,s.jsx)(n.em,{children:"or"})," relationship."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>r,a:()=>a});var s=i(67294);const t={},o=s.createContext(t);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);