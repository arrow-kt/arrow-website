"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[5600],{82606:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var i=r(85893),t=r(11151);const o={sidebar_position:4},c="Concurrency primitives",s={id:"learn/coroutines/concurrency-primitives",title:"Concurrency primitives",description:"These types are not usually found in application code, but provide essential",source:"@site/content/docs/learn/coroutines/concurrency-primitives.md",sourceDirName:"learn/coroutines",slug:"/learn/coroutines/concurrency-primitives",permalink:"/learn/coroutines/concurrency-primitives",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/coroutines/concurrency-primitives.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"learnSidebar",previous:{title:"Transactional memory (STM)",permalink:"/learn/coroutines/stm"},next:{title:"Resilience",permalink:"/learn/resilience/"}},a={},l=[{value:"Atomic",id:"atomic",level:2},{value:"CountDownLatch",id:"countdownlatch",level:2},{value:"CyclicBarrier",id:"cyclicbarrier",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"concurrency-primitives",children:"Concurrency primitives"}),"\n",(0,i.jsx)(n.p,{children:"These types are not usually found in application code, but provide essential\nfoundation blocks for larger patterns. They are also helpful during testing\nto simulate synchronization between different systems."}),"\n",(0,i.jsx)(n.admonition,{title:"Multiplatform-ready",type:"info",children:(0,i.jsxs)(n.p,{children:["The Arrow Fx library is Multiplatform-ready, so you can use it in all of your\n",(0,i.jsx)(n.a,{href:"https://kotlinlang.org/docs/multiplatform.html",children:"KMP"})," projects. In most cases,\nthe API provided by Arrow Fx follows the one for similar concepts in the JVM."]})}),"\n",(0,i.jsx)(n.admonition,{title:"Structured concurrency",type:"tip",children:(0,i.jsxs)(n.p,{children:["One key topic to understand concurrency in Kotlin is ",(0,i.jsx)(n.em,{children:"Structured Concurrency"}),".\nThe ",(0,i.jsx)(n.a,{href:"https://kotlinlang.org/docs/coroutines-guide.html",children:"official coroutines guide"}),"\ngoes into quite some length to explain how coroutines should behave, especially\nin the events of exceptions and cancellations. Most of this complexity is hidden\naway when you use Arrow Fx ",(0,i.jsx)(n.a,{href:"../parallel",children:"high-level operations"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"atomic",children:"Atomic"}),"\n",(0,i.jsxs)(n.p,{children:["The separate ",(0,i.jsxs)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-atomic/arrow.atomic/index.html",children:[(0,i.jsx)(n.code,{children:"arrow-atomic"})," library"]}),"\nprovides Multiplatform-ready atomic references.\nIn particular, their ",(0,i.jsx)(n.code,{children:"getAndSet"}),", ",(0,i.jsx)(n.code,{children:"getAndUpdate"}),", and ",(0,i.jsx)(n.code,{children:"compareAndSet"})," operations\nare guaranteed to happen atomically; there's no possibility of two computations\nperforming these operations and getting an inconsistent state at the end."]}),"\n",(0,i.jsx)(n.admonition,{title:"Atomic primitive types",type:"warning",children:(0,i.jsxs)(n.p,{children:["You should not use generic ",(0,i.jsx)(n.code,{children:"Atomic"})," references with primitive types like\n",(0,i.jsx)(n.code,{children:"Int"})," or ",(0,i.jsx)(n.code,{children:"Boolean"}),", as they break in unexpected ways in Kotlin Native. Instead, use\nthe provided ",(0,i.jsx)(n.code,{children:"AtomicInt"}),", ",(0,i.jsx)(n.code,{children:"AtomicBoolean"}),", and so forth."]})}),"\n",(0,i.jsx)(n.h2,{id:"countdownlatch",children:"CountDownLatch"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-fx-coroutines/arrow.fx.coroutines/-count-down-latch/index.html",children:(0,i.jsx)(n.code,{children:"CountDownLatch"})}),"\nallows for awaiting a given number of countdown signals."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["This type models the behavior of ",(0,i.jsx)(n.a,{href:"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html",children:(0,i.jsx)(n.code,{children:"java.util.concurrent.CountDownLatch"})}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"cyclicbarrier",children:"CyclicBarrier"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-fx-coroutines/arrow.fx.coroutines/-cyclic-barrier/index.html",children:(0,i.jsx)(n.code,{children:"CyclicBarrier"})}),"\nis a synchronization mechanism that allows a set of coroutines to wait for each\nother to reach a certain point before continuing execution. It is called ",(0,i.jsx)(n.em,{children:"cyclic"}),"\nbecause it can be reused after all coroutines have reached the barrier and been released."]}),"\n",(0,i.jsxs)(n.p,{children:["To use a ",(0,i.jsx)(n.code,{children:"CyclicBarrier"}),", each coroutine must call the ",(0,i.jsx)(n.code,{children:"await"})," method on the\nbarrier object, which will cause the coroutine to suspend until the required\nnumber of coroutines have reached the barrier.\nOnce all coroutines have reached the barrier, they resume execution."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["This type models the behavior of ",(0,i.jsx)(n.a,{href:"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html",children:(0,i.jsx)(n.code,{children:"java.util.concurrent.CyclicBarrier"})}),"."]})})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>s,a:()=>c});var i=r(67294);const t={},o=i.createContext(t);function c(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);