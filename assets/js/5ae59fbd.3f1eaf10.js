"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[2989],{8669:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>c});var s=r(85893),o=r(11151);const t={id:"from-fp",title:"From other FP languages",sidebar_position:2},i="From other FP languages",a={id:"learn/quickstart/from-fp",title:"From other FP languages",description:"Arrow is heavily influenced by functional programming. If you're used to working",source:"@site/content/docs/learn/quickstart/from-fp.md",sourceDirName:"learn/quickstart",slug:"/learn/quickstart/from-fp",permalink:"/learn/quickstart/from-fp",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/quickstart/from-fp.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"from-fp",title:"From other FP languages",sidebar_position:2},sidebar:"learnSidebar",previous:{title:"Overview of libraries",permalink:"/learn/quickstart/libs"},next:{title:"Serialization",permalink:"/learn/quickstart/serialization"}},l={},c=[{value:"Computation blocks",id:"computation-blocks",level:2},{value:"<code>suspend</code> instead of <code>IO</code>",id:"suspend-instead-of-io",level:2},{value:"Higher-kinded abstractions",id:"higher-kinded-abstractions",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"from-other-fp-languages",children:"From other FP languages"}),"\n",(0,s.jsx)(n.p,{children:"Arrow is heavily influenced by functional programming. If you're used to working\nwith those concepts, the journey to Arrow should be a pleasant one. In this\nsection, we review the most important differences with other ecosystems."}),"\n",(0,s.jsx)(n.admonition,{title:"scala",type:"note",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://www.scala-lang.org/api/current/scala/index.html",children:"Scala Standard Library"})," contains\nmany of the types provided by Arrow like ",(0,s.jsx)(n.a,{href:"https://www.scala-lang.org/api/current/scala/util/Either.html",children:(0,s.jsx)(n.code,{children:"Either"})}),".\nThere's also a vibrant community which brings even more functional features,\nlike the ",(0,s.jsx)(n.a,{href:"https://typelevel.org/",children:"Typelevel ecosystem"}),"."]})}),"\n",(0,s.jsx)(n.admonition,{title:"haskell",type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://www.haskell.org/",children:"Haskell"})," is often considered the prime example of a\npure functional programming language. Most of the utilities in Arrow are\nfound in ",(0,s.jsxs)(n.a,{href:"https://hackage.haskell.org/package/base",children:["their ",(0,s.jsx)(n.code,{children:"base"})," library"]}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"computation-blocks",children:"Computation blocks"}),"\n",(0,s.jsx)(n.admonition,{title:"From Either to Raise",type:"note",children:(0,s.jsxs)(n.p,{children:["You may be interested in our ",(0,s.jsx)(n.a,{href:"/learn/typed-errors/from-either-to-raise",children:"tutorial"}),"\nfocusing specifically on transitioning from wrapper types\nfor errors, like ",(0,s.jsx)(n.code,{children:"Either"}),", to the ",(0,s.jsx)(n.code,{children:"Raise"})," DSL."]})}),"\n",(0,s.jsxs)(n.p,{children:["Both Scala and Haskell have special support for types which define a\n",(0,s.jsx)(n.code,{children:"flatMap"})," or bind operation, namely\n",(0,s.jsxs)(n.a,{href:"https://docs.scala-lang.org/tour/for-comprehensions.html",children:[(0,s.jsx)(n.code,{children:"for"})," comprehensions"]}),"\nand ",(0,s.jsxs)(n.a,{href:"https://en.wikibooks.org/wiki/Haskell/do_notation",children:[(0,s.jsx)(n.code,{children:"do"})," notation"]}),".\n",(0,s.jsx)(n.code,{children:"Either"})," is one such type, so you can use ",(0,s.jsx)(n.code,{children:"for"})," or ",(0,s.jsx)(n.code,{children:"do"})," to perform validation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"def mkPerson(name: String, age: Int): Either[Problem, Person] = for {\n  name_ <- validName(name)\n  age_  <- validAge(age)\n} yield Person(name_, age_)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"mkPerson :: String -> Int -> Either Problem Person\nmkPerson name age = do\n  name_ <- validName name\n  age_  <- validAge age\n  pure (Person name_ age_)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In Haskell you can get closer to this style using ",(0,s.jsx)(n.code,{children:"Applicative"})," operators.\nThe code still looks different than its pure counterpart, since you need\nto sprinkle ",(0,s.jsx)(n.code,{children:"(<$>)"})," and ",(0,s.jsx)(n.code,{children:"(<*>)"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"mkPerson name age = Person <$> validName name <*> validAge age\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Kotlin doesn't provide such a generic construct. However, Arrow provides a similar\nsyntax for ",(0,s.jsx)(n.a,{href:"../../typed-errors/working-with-typed-errors/",children:"error types"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["You must explicitly request to work with an error type, using ",(0,s.jsx)(n.code,{children:"either"}),",\n",(0,s.jsx)(n.code,{children:"result"}),", or ",(0,s.jsx)(n.code,{children:"nullable"}),", instead of ",(0,s.jsx)(n.code,{children:"for"}),". Those functions live in\nthe ",(0,s.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-core/arrow.core.raise/index.html",children:(0,s.jsx)(n.code,{children:"arrow.core.raise"})})," package."]}),"\n",(0,s.jsxs)(n.li,{children:["Every usage of ",(0,s.jsx)(n.code,{children:"<-"})," translates into a call to ",(0,s.jsx)(n.code,{children:".bind()"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun mkPerson(name: String, age: Int): Either<Problem, Person> = either {\n  val name_ = validName(name).bind()\n  val age_  = validAge(age).bind()\n  Person(name_, age_)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Furthermore, the result of ",(0,s.jsx)(n.code,{children:".bind()"})," is just of regular type, so you can\ncompletely inline the calls if desired. This style is very similar to\nHaskell's use of ",(0,s.jsx)(n.code,{children:"Applicative"})," operators, except that operators appear\nat the level of arguments, instead of at the level of functions."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun mkPerson(name: String, age: Int): Either<Problem, Person> = either {\n  Person(validName(name).bind(), validAge(age).bind())\n}\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"No zip",type:"tip",children:(0,s.jsxs)(n.p,{children:["It's common to use functions like ",(0,s.jsx)(n.code,{children:"zip"})," to combine values inside a\nwrapper, instead of a ",(0,s.jsx)(n.code,{children:"for"})," comprehension. In Haskell this often takes\nthe form of ",(0,s.jsx)(n.code,{children:"(<$>)"})," and ",(0,s.jsx)(n.code,{children:"(<*>)"}),". In Arrow we prefer to use blocks,\nexcept when ",(0,s.jsx)(n.a,{href:"../../coroutines/parallel/",children:"dealing with concurrency"}),"."]})}),"\n",(0,s.jsx)(n.admonition,{title:"No traverse",type:"tip",children:(0,s.jsxs)(n.p,{children:["If you want to apply an effectful operation to every element of a collection,\nyou need to use a function different from ",(0,s.jsx)(n.code,{children:"map"}),", usually called ",(0,s.jsx)(n.code,{children:"traverse"}),".\nThis split does not exist in Arrow: you can use the same functions you know\nand love from the collections API inside one of these blocks."]})}),"\n",(0,s.jsxs)(n.h2,{id:"suspend-instead-of-io",children:[(0,s.jsx)(n.code,{children:"suspend"})," instead of ",(0,s.jsx)(n.code,{children:"IO"})]}),"\n",(0,s.jsxs)(n.p,{children:["The utilities provided by Arrow for working with side effects are based on\n",(0,s.jsx)(n.a,{href:"https://kotlinlang.org/docs/coroutines-guide.html",children:"coroutines"}),", that is,\nfunctions marked as ",(0,s.jsx)(n.code,{children:"suspend"}),". In contrast,\nHaskell introduces a special ",(0,s.jsx)(n.code,{children:"IO"})," wrapper\ntype to mark side-effects, as done by\npopular Scala libraries like\n",(0,s.jsx)(n.a,{href:"https://typelevel.org/cats-effect/",children:"Cats Effect"}),"."]}),"\n",(0,s.jsx)(n.admonition,{title:"Read more",type:"info",children:(0,s.jsxs)(n.p,{children:["Our ",(0,s.jsx)(n.a,{href:"../../design/",children:(0,s.jsx)(n.em,{children:"Design"})})," section includes a ",(0,s.jsx)(n.a,{href:"../../design/receivers-flatmap/",children:"post"}),"\ncomparing the different approaches for effect handling."]})}),"\n",(0,s.jsx)(n.h2,{id:"higher-kinded-abstractions",children:"Higher-kinded abstractions"}),"\n",(0,s.jsxs)(n.p,{children:["Both Scala and Haskell allow abstractions that operate at the level of\ntype constructors. For example, a function like ",(0,s.jsx)(n.code,{children:"flatMap"})," which always has\nthe form of ",(0,s.jsx)(n.code,{children:"F<A>.flatMap(next: (A) -> F<B>): F<B>"})," is a part of an interface /\ntype class called ",(0,s.jsx)(n.code,{children:"Monad"}),". Kotlin doesn't provide this feature, but Arrow\nstill follows the naming convention for consistency. The following list\nrelates the names to abstractions in ",(0,s.jsx)(n.a,{href:"https://typelevel.org/cats/",children:"Cats"}),"\nand ",(0,s.jsxs)(n.a,{href:"https://hackage.haskell.org/package/base",children:["Haskell's ",(0,s.jsx)(n.code,{children:"base"})]}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"map"})," comes from ",(0,s.jsx)(n.a,{href:"https://typelevel.org/cats/typeclasses/functor.html",children:(0,s.jsx)(n.code,{children:"Functor"})}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"contramap"})," comes from ",(0,s.jsx)(n.a,{href:"https://typelevel.org/cats/typeclasses/contravariant.html",children:(0,s.jsx)(n.code,{children:"Contravariant"})})," functors."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fold"})," comes from ",(0,s.jsx)(n.a,{href:"https://typelevel.org/cats/typeclasses/foldable.html",children:(0,s.jsx)(n.code,{children:"Foldable"})}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"zip"})," comes from ",(0,s.jsx)(n.a,{href:"https://typelevel.org/cats/typeclasses/applicative.html",children:(0,s.jsx)(n.code,{children:"Applicative"})}),",\nalthough it's called ",(0,s.jsx)(n.code,{children:"product"})," or ",(0,s.jsx)(n.code,{children:"(&&)"})," in other languages."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"traverse"})," and ",(0,s.jsx)(n.code,{children:"sequence"})," come from ",(0,s.jsx)(n.a,{href:"https://typelevel.org/cats/typeclasses/traverse.html",children:(0,s.jsx)(n.code,{children:"Traversable"})}),",\nbut those functions are being ",(0,s.jsx)(n.strong,{children:"deprecated"}),", because the same behavior can\nbe achieved with regular list functions and computation blocks."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"Semigroup and Monoid",type:"danger",children:(0,s.jsxs)(n.p,{children:["Arrow Core contains ",(0,s.jsx)(n.code,{children:"Semigroup"})," and ",(0,s.jsx)(n.code,{children:"Monoid"})," as interfaces. They are, however,\nmarked as deprecated, and due for removal in Arrow 2.0. Functions that required\na ",(0,s.jsx)(n.code,{children:"Semigroup"})," or ",(0,s.jsx)(n.code,{children:"Monoid"})," argument have been replaced by variants which take\nthe combination function, and the corresponding empty element. This design\nfits better with other parts of the Kotlin ecosystem, like the ",(0,s.jsx)(n.a,{href:"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/fold.html",children:(0,s.jsx)(n.code,{children:"fold"})}),"\nfunction in ",(0,s.jsx)(n.code,{children:"kotlin.collections"}),"."]})})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>a,a:()=>i});var s=r(67294);const o={},t=s.createContext(o);function i(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);