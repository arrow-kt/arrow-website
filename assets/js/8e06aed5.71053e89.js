"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([["216"],{76922:function(e,n,t){t.r(n),t.d(n,{metadata:()=>o,default:()=>d,frontMatter:()=>a,contentTitle:()=>s,toc:()=>c,assets:()=>l});var o=JSON.parse('{"id":"learn/typed-errors/validation","title":"Validation","description":"Worked out example of validation.","source":"@site/content/docs/learn/typed-errors/validation.md","sourceDirName":"learn/typed-errors","slug":"/learn/typed-errors/validation","permalink":"/learn/typed-errors/validation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"validation","title":"Validation","description":"Worked out example of validation.","sidebar_position":2},"sidebar":"learnSidebar","previous":{"title":"Working with typed errors","permalink":"/learn/typed-errors/working-with-typed-errors"},"next":{"title":"From Either to Raise","permalink":"/learn/typed-errors/from-either-to-raise"}}'),i=t(74848),r=t(28453);let a={id:"validation",title:"Validation",description:"Worked out example of validation.",sidebar_position:2},s="Validation",l={},c=[{value:"Smart constructors",id:"smart-constructors",level:2},{value:"Fail-first vs. accumulation",id:"fail-first-vs-accumulation",level:2},{value:"Validating a list",id:"validating-a-list",level:2},{value:"Variants of map + accumulation",id:"variants-of-map--accumulation",level:3}];function h(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"validation",children:"Validation"})}),"\n",(0,i.jsx)(n.p,{children:"This tutorial shows a concrete example of using typed errors to implement\ndomain validation. In particular, we begin with the following domain:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"data class Author(val name: String)\ndata class Book(val title: String, val authors: NonEmptyList<Author>)\n"})}),"\n",(0,i.jsx)(n.p,{children:"over which we want to implement the following rules:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The given title should not be empty,"}),"\n",(0,i.jsxs)(n.li,{children:["The list of authors should ",(0,i.jsx)(n.a,{href:"../../collections-functions/non-empty/",children:"not be empty"}),","]}),"\n",(0,i.jsx)(n.li,{children:"None of the author names should be empty."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"We want to accumulate as many error as possible."}),"\n",(0,i.jsx)(n.h2,{id:"smart-constructors",children:"Smart constructors"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Author"})," class exposes its constructor, so we cannot prevent the user from creating\nit with wrong values. One could introduce a ",(0,i.jsx)(n.code,{children:"require"})," in the constructor, but we prefer\nto use the typed error mechanism instead. A common pattern in this case is to\n",(0,i.jsx)(n.em,{children:"hide"})," the constructor, and provide a ",(0,i.jsx)(n.em,{children:"smart constructor"})," by adding an ",(0,i.jsx)(n.code,{children:"invoke"}),"\noperator inside the companion object."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"object EmptyAuthorName\n\ndata class Author private constructor(val name: String) {\n  companion object {\n    operator fun invoke(name: String): Either<EmptyAuthorName, Author> = TODO()\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This way the users of this class still use ",(0,i.jsx)(n.code,{children:'Author("me")'})," to create a new name,\nin the same way one would use a constructor, but actually our ",(0,i.jsx)(n.code,{children:"invoke"})," function\nis called. This allows us to refine the type to an ",(0,i.jsx)(n.code,{children:"Either"}),", which can return\nan error. The implementation uses the ",(0,i.jsx)(n.code,{children:"either"})," computation block, with ",(0,i.jsx)(n.code,{children:"ensure"}),"\ndescribing the constraint #3."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"data class Author private constructor(val name: String) {\n  companion object {\n    operator fun invoke(name: String): Either<EmptyAuthorName, Author> = either {\n      ensure(name.isNotEmpty()) { EmptyAuthorName }\n      Author(name)\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"fail-first-vs-accumulation",children:"Fail-first vs. accumulation"}),"\n",(0,i.jsxs)(n.p,{children:["We are going to use a similar approach for ",(0,i.jsx)(n.code,{children:"Book"}),", introducing a smart\nconstructor. We have several different errors, though, which we define as\na sealed hierarchy. Note that ",(0,i.jsx)(n.code,{children:"EmptyAuthor"})," is a different type than before,\nsince we want to store the index of the author."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"sealed interface BookValidationError\nobject EmptyTitle: BookValidationError\nobject NoAuthors: BookValidationError\ndata class EmptyAuthor(val index: Int): BookValidationError\n\ndata class Book private constructor(\n  val title: String, val authors: NonEmptyList<Author>\n) {\n  companion object {\n    operator fun invoke(\n      title: String, authors: Iterable<String>\n    ): Either<BookValidationError, Book> = TODO()\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's forget about validating each author for a moment, and just implement the\nemptiness checks for the title and the authors list. Note that in the latter\ncase we perform both the check and the conversion to ",(0,i.jsx)(n.code,{children:"NonEmptyList"})," in a single\ngo using ",(0,i.jsx)(n.code,{children:"ensureNotNull"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"data class Book private constructor(\n  val title: String, val authors: NonEmptyList<Author>\n) {\n  companion object {\n    operator fun invoke(\n      title: String, authors: Iterable<String>\n    ): Either<BookValidationError, Book> = either {\n      ensure(title.isNotEmpty()) { EmptyTitle }\n      ensureNotNull(authors.toNonEmptyListOrNull()) { NoAuthors }\n      Book(title, TODO())\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This code has a problem, though: it only returns ",(0,i.jsx)(n.em,{children:"one"})," error, even if there were\ntwo problems with the data of the ",(0,i.jsx)(n.code,{children:"Book"}),". We would rather use an ",(0,i.jsx)(n.em,{children:"accumulation"}),"\napproach, so we can give back as much information as possible to the user.\nThis requires two changes to the code:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The result type is now a ",(0,i.jsx)(n.code,{children:"NonEmptyList"})," of problems,"]}),"\n",(0,i.jsxs)(n.li,{children:["We need to wrap the different validations in ",(0,i.jsx)(n.code,{children:"zipOrAccumulate"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"data class Book private constructor(\n  val title: String, val authors: NonEmptyList<Author>\n) {\n  companion object {\n    operator fun invoke(\n      title: String, authors: Iterable<String>\n    ): Either<NonEmptyList<BookValidationError>, Book> = either {\n      zipOrAccumulate(\n        { ensure(title.isNotEmpty()) { EmptyTitle } },\n        { ensureNotNull(authors.toNonEmptyListOrNull()) { NoAuthors } }\n      ) { _, _ ->\n          Unit\n      }\n      Book(title, TODO())\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The result of each of the arguments of ",(0,i.jsx)(n.code,{children:"zipOrAccumulate"})," are available in the\ntrailing lambda. In this case we are not using them: we have the ",(0,i.jsx)(n.code,{children:"title"}),"\nalready available, and for the list of authors we still need to perform the\nconversion from ",(0,i.jsx)(n.code,{children:"String"})," to ",(0,i.jsx)(n.code,{children:"Author"}),"."]}),"\n",(0,i.jsx)(n.admonition,{title:"Arguments to zipOrAccumulate",type:"tip",children:(0,i.jsxs)(n.p,{children:["All but the last argument to ",(0,i.jsx)(n.code,{children:"zipOrAccumulate"})," represent the different\nvalidations we want to run aggregating their output. Those arguments are\noften ",(0,i.jsx)(n.em,{children:"blocks"})," wrapped in ",(0,i.jsx)(n.code,{children:"{"})," curly braces ",(0,i.jsx)(n.code,{children:"}"}),", which is a bit unusual for\nmost Kotliners."]})}),"\n",(0,i.jsx)(n.h2,{id:"validating-a-list",children:"Validating a list"}),"\n",(0,i.jsxs)(n.p,{children:["The next step is turning the given ",(0,i.jsx)(n.code,{children:"authors"}),", which is a list of ",(0,i.jsx)(n.code,{children:"String"}),"s, into\na list of ",(0,i.jsx)(n.code,{children:"Author"}),"s. We need to run the smart constructor, thus, but at the same\ntime we should accumulate any potential problems. Since this is related to\nauthor checks, we'll include this as part of the second validation."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"data class Book private constructor(\n  val title: String, val authors: NonEmptyList<Author>\n) {\n  companion object {\n    operator fun invoke(\n      title: String, authors: Iterable<String>\n    ): Either<NonEmptyList<BookValidationError>, Book> = either {\n      zipOrAccumulate(\n        { ensure(title.isNotEmpty()) { EmptyTitle } },\n        { \n          val validatedAuthors = mapOrAccumulate(authors.withIndex()) { nameAndIx ->\n            Author(nameAndIx.value)\n              .recover { _ -> raise(EmptyAuthor(nameAndIx.index)) }\n              .bind()\n          }\n          ensureNotNull(validatedAuthors.toNonEmptyListOrNull()) { NoAuthors }\n        }\n      ) { _, authorsNel ->\n        Book(title, authorsNel)\n      }\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This additional check is quite complex, so let's unravel it step by step:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["We use ",(0,i.jsx)(n.code,{children:"authors.withIndex()"})," to create an iterable containing the values\nin conjunction with the index they live in, this is necessary to create\nthe right ",(0,i.jsx)(n.code,{children:"EmptyAuthor"})," error value."]}),"\n",(0,i.jsxs)(n.li,{children:["With ",(0,i.jsx)(n.code,{children:"mapOrAccumulate"})," we state that we want to perform some validation over\na collection of elements, accumulating each possible error."]}),"\n",(0,i.jsxs)(n.li,{children:["The call to ",(0,i.jsx)(n.code,{children:"Author(it.value)"})," returns an ",(0,i.jsx)(n.code,{children:"Either"})," with the wrong error type\n(",(0,i.jsx)(n.code,{children:"EmptyAuthorName"})," instead of ",(0,i.jsx)(n.code,{children:"EmptyAuthor"}),"). To transform this value we\nuse the ",(0,i.jsx)(n.code,{children:"recover"})," extension function."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{title:"Recover vs. Map Left",type:"tip",children:(0,i.jsxs)(n.p,{children:["Another possibility would be to use ",(0,i.jsx)(n.code,{children:"mapLeft { EmptyAuthor(it.index) }"}),".\nThe difference between ",(0,i.jsx)(n.code,{children:"recover"})," and ",(0,i.jsx)(n.code,{children:"mapLeft"})," is that the latter only transforms\nthe error value, whereas in the former you can use any typed error computation."]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Finally, we use ",(0,i.jsx)(n.code,{children:".bind()"})," to embed the ",(0,i.jsx)(n.code,{children:"Either"})," into the computation block.\nEssentially, every time you are using a value of type ",(0,i.jsx)(n.code,{children:"Either"})," inside an\n",(0,i.jsx)(n.code,{children:"either"})," (or any other ",(0,i.jsx)(n.code,{children:"Raise"})," block), such a call is required."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The result of the mapping is a ",(0,i.jsx)(n.code,{children:"List<Author>"}),", that we can now use to create the\nfinal ",(0,i.jsx)(n.code,{children:"Book"}),". This value is available in the last lambda of ",(0,i.jsx)(n.code,{children:"zipOrAccumulate"}),",\nthat we've called ",(0,i.jsx)(n.code,{children:"validatedAuthors"})," in the code above."]}),"\n",(0,i.jsx)(n.h3,{id:"variants-of-map--accumulation",children:"Variants of map + accumulation"}),"\n",(0,i.jsx)(n.p,{children:"In the code above there's one section which can be written in several different\nways, namely the mapping over a list while accumulating any errors raised\nduring the processing of each of the elements."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"val validatedAuthors = mapOrAccumulate(authors.withIndex()) { nameAndIx ->\n  Author(nameAndIx.value)\n    .mapLeft { EmptyAuthor(nameAndIx.index) }\n    .bind()\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This first version uses the variant of ",(0,i.jsx)(n.code,{children:"mapOrAccumulate"})," which lives in\n",(0,i.jsx)(n.code,{children:"Raise"})," and takes the collection to work on as first argument. This variant\nprovides ",(0,i.jsx)(n.code,{children:"Raise"})," inside the block (hence the need to call ",(0,i.jsx)(n.code,{children:".bind()"}),"), and\n",(0,i.jsx)(n.code,{children:"raise"}),"s automatically if any error is found."]}),"\n",(0,i.jsxs)(n.p,{children:["Another way to write the code above is by creating a list of ",(0,i.jsx)(n.code,{children:"Either"})," using\n",(0,i.jsx)(n.code,{children:"map"}),", and then using ",(0,i.jsx)(n.code,{children:".bindAll()"})," at the very end. This often turns into\nsimpler code when your validations use wrapper types, as we do here, since\nyou don't need to call the intermediate ",(0,i.jsx)(n.code,{children:".bind()"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"val validatedAuthors = authors.withIndex().map { nameAndIx ->\n  Author(nameAndIx.value)\n    .mapLeft { EmptyAuthor(nameAndIx.index) }\n}.bindAll()\n"})}),"\n",(0,i.jsx)(n.p,{children:"Any of these approaches are equivalent, given that the function that validates\neach of the elements doesn't perform any side effects."})]})}function d(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:function(e,n,t){t.d(n,{R:()=>a,x:()=>s});var o=t(96540);let i={},r=o.createContext(i);function a(e){let n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);