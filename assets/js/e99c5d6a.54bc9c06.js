"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[5418],{56682:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var a=t(85893),s=t(11151);const r={sidebar_position:4},i="Traversals",o={id:"learn/immutable-data/traversal",title:"Traversals",description:"The framework laid out by optics extends very nicely to values like lists, which",source:"@site/content/docs/learn/immutable-data/traversal.md",sourceDirName:"learn/immutable-data",slug:"/learn/immutable-data/traversal",permalink:"/learn/immutable-data/traversal",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/immutable-data/traversal.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"learnSidebar",previous:{title:"Optionals",permalink:"/learn/immutable-data/optional"},next:{title:"Prisms & Isos",permalink:"/learn/immutable-data/prism-iso"}},l={},c=[{value:"<code>Every</code> element in a collection",id:"every-element-in-a-collection",level:2},{value:"More than <code>getAll</code>",id:"more-than-getall",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"traversals",children:"Traversals"}),"\n",(0,a.jsx)(n.p,{children:"The framework laid out by optics extends very nicely to values like lists, which\nmay contain any potential number of elements. Traversals is the name of that kind of\noptic."}),"\n",(0,a.jsx)(n.admonition,{title:"In a rush?",type:"info",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Traversals focus on an indefinite number of values."}),"\n",(0,a.jsxs)(n.li,{children:["To access all the values, use ",(0,a.jsx)(n.code,{children:"getAll"}),"."]}),"\n",(0,a.jsx)(n.li,{children:"Traversals provide an API similar to those of collections."}),"\n",(0,a.jsxs)(n.li,{children:["To modify every value focused by the traversal, use ",(0,a.jsx)(n.code,{children:"modify"}),"."]}),"\n"]})}),"\n",(0,a.jsxs)(n.h2,{id:"every-element-in-a-collection",children:[(0,a.jsx)(n.code,{children:"Every"})," element in a collection"]}),"\n",(0,a.jsxs)(n.p,{children:["As with other kinds of optics, ",(0,a.jsx)(n.code,{children:"Traversal<T, A>"})," represents a reference to elements\nof type ",(0,a.jsx)(n.code,{children:"A"})," within a larger structure of type ",(0,a.jsx)(n.code,{children:"T"}),". As hinted above, most\ntraversals arise from focusing on elements in a collection; in Arrow Optics,\nthose basic traversals live in the ",(0,a.jsx)(n.code,{children:"Every"})," object."]}),"\n",(0,a.jsx)(n.p,{children:"Let's introduce a small data class for our examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"@optics data class Person(val name: String, val age: Int, val friends: List<Person>) {\n  companion object\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If we want to update the age of every ",(0,a.jsx)(n.code,{children:"Person"})," in a list, the usual way is to\nuse the ",(0,a.jsx)(n.code,{children:"map"})," function from the standard library."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun List<Person>.happyBirthdayMap(): List<Person> =\n  map { Person.age.modify(it) { age -> age + 1 } }\n"})}),"\n",(0,a.jsx)(n.p,{children:"The same code can be rewritten using only optics by leveraging a traversal for\nlists."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun List<Person>.happyBirthdayOptics(): List<Person> =\n  Every.list<Person>().age.modify(this) { age -> age + 1 }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Traversals become more useful when composed with other optics. Imagine that we\nwant to update the age of all the friends of a ",(0,a.jsx)(n.code,{children:"Person"}),"; the usual implementation\nwith ",(0,a.jsx)(n.code,{children:"map"})," and ",(0,a.jsx)(n.code,{children:"copy"})," becomes quite complex."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun Person.happyBirthdayFriends(): Person =\n  copy(\n    friends = friends.map { friend -> friend.copy(age = friend.age + 1) }\n  )\n"})}),"\n",(0,a.jsx)(n.p,{children:"The implementation using optics hides all the complexity related to mapping\nand copying, and simply focuses on the path to access the values."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun Person.happyBirthdayFriendsOptics(): Person =\n  Person.friends.every.age.modify(this) { it + 1 }\n"})}),"\n",(0,a.jsx)(n.admonition,{title:"Every(List)",type:"note",children:(0,a.jsxs)(n.p,{children:["In versions prior to 2.0, ",(0,a.jsx)(n.code,{children:".every"})," required an additional argument specifying\nthe type of traversal. So one would write ",(0,a.jsx)(n.code,{children:"Person.friends.every(Every.list())"}),".\nThis problem was related to ",(0,a.jsx)(n.a,{href:"https://kotlinlang.org/docs/generics.html#type-erasure",children:"type erasure"}),",\nbut fortunately, a new encoding was found without this caveat."]})}),"\n",(0,a.jsxs)(n.h2,{id:"more-than-getall",children:["More than ",(0,a.jsx)(n.code,{children:"getAll"})]}),"\n",(0,a.jsxs)(n.p,{children:["The counterpart to ",(0,a.jsx)(n.code,{children:"get"})," and ",(0,a.jsx)(n.code,{children:"getOrNull"})," when speaking about traversals is called\n",(0,a.jsx)(n.code,{children:"getAll"}),", and returns a list of focused elements. But you don't always have to\ngo through an intermediate list to obtain information about the elements focused\nby a ",(0,a.jsx)(n.code,{children:"Traversal"}),", we provide a ",(0,a.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-optics/arrow.optics/-getter/index.html",children:"large API"}),"\nbased on Kotlin's collections in the standard library."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, you can call ",(0,a.jsx)(n.code,{children:"isEmpty"})," to check whether the traversal matches any\nelement. Or, more generally, you can call ",(0,a.jsx)(n.code,{children:"size"}),' to obtain the number of elements\nit matches. Note that, in any case, these operations are "optics-first", so\nyou need to provide the value they operate on as an argument.']})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>i});var a=t(67294);const s={},r=a.createContext(s);function i(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);