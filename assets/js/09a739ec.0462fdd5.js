"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[1868],{7816:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var t=i(85893),o=i(11151);const r={description:"Writing your own DSLs with Raise.",sidebar_position:5},s="Creating your own error wrappers",a={id:"learn/typed-errors/own-error-types",title:"Creating your own error wrappers",description:"Writing your own DSLs with Raise.",source:"@site/content/docs/learn/typed-errors/own-error-types.md",sourceDirName:"learn/typed-errors",slug:"/learn/typed-errors/own-error-types",permalink:"/learn/typed-errors/own-error-types",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/typed-errors/own-error-types.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{description:"Writing your own DSLs with Raise.",sidebar_position:5},sidebar:"learnSidebar",previous:{title:"Validation",permalink:"/learn/typed-errors/validation"},next:{title:"Coroutines",permalink:"/learn/coroutines/"}},c={},l=[{value:"Basic functionality",id:"basic-functionality",level:2},{value:"Reflections on <code>Failure</code>",id:"reflections-on-failure",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"creating-your-own-error-wrappers",children:"Creating your own error wrappers"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Raise"})," is a powerful tool that allows us to create our own DSLs to raise typed errors.\nIt easily allows integration with existing libraries and frameworks that offer similar data types like ",(0,t.jsx)(n.code,{children:"Either"})," or even your own custom types.\nFor example, let's take a popular ADT often used in the front end, a type that models ",(0,t.jsx)(n.code,{children:"Loading"}),", ",(0,t.jsx)(n.code,{children:"Content"}),", or ",(0,t.jsx)(n.code,{children:"Failure"}),", often abbreviated as ",(0,t.jsx)(n.code,{children:"LCE"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"sealed interface Lce<out E, out A> {\n  object Loading : Lce<Nothing, Nothing>\n  data class Content<A>(val value: A) : Lce<Nothing, A>\n  data class Failure<E>(val error: E) : Lce<E, Nothing>\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"basic-functionality",children:"Basic functionality"}),"\n",(0,t.jsxs)(n.p,{children:["Let's say that once a ",(0,t.jsx)(n.code,{children:"Failure"})," or ",(0,t.jsx)(n.code,{children:"Loading"})," case is encountered, we want to short-circuit and not continue with the computation.\nIt's easy to define a ",(0,t.jsx)(n.code,{children:"Raise"})," instance for ",(0,t.jsx)(n.code,{children:"Lce"})," that does just that. We'll use the composition pattern to do this ",(0,t.jsx)(n.strong,{children:"without"})," context receivers.\nSince we need to ",(0,t.jsx)(n.em,{children:"raise"})," both ",(0,t.jsx)(n.code,{children:"Lce.Loading"})," and ",(0,t.jsx)(n.code,{children:"Lce.Failure"}),", our ",(0,t.jsx)(n.code,{children:"Raise"})," instance will need to be able to ",(0,t.jsx)(n.code,{children:"raise"})," ",(0,t.jsx)(n.code,{children:"Lce<E, Nothing>"}),", and we wrap that in a ",(0,t.jsx)(n.code,{children:"LceRaise"})," class.\nWithin that class, a ",(0,t.jsx)(n.code,{children:"bind"})," function can be defined to short-circuit any encountered ",(0,t.jsx)(n.code,{children:"Failure"})," or ",(0,t.jsx)(n.code,{children:"Loading"})," case or otherwise return the ",(0,t.jsx)(n.code,{children:"Content"})," value."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"@JvmInline\nvalue class LceRaise<E>(val raise: Raise<Lce<E, Nothing>>) : Raise<Lce<E, Nothing>> by raise {\n  fun <A> Lce<E, A>.bind(): A =  when (this) {\n    is Lce.Content -> value\n    is Lce.Failure -> raise.raise(this)\n    Lce.Loading -> raise.raise(Lce.Loading)\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["All that is required now is a DSL function. We can use the ",(0,t.jsx)(n.code,{children:"recover"})," or ",(0,t.jsx)(n.code,{children:"fold"})," function to summon an instance of ",(0,t.jsx)(n.code,{children:"RaiseLce<E, Nothing>"})," from the ",(0,t.jsx)(n.code,{children:"Raise"})," type class.\nWe wrap the ",(0,t.jsx)(n.code,{children:"block"})," in an ",(0,t.jsx)(n.code,{children:"Lce.Content"})," value and return any encountered ",(0,t.jsx)(n.code,{children:"Lce<E, Nothing>"})," value. We can call ",(0,t.jsx)(n.code,{children:"block"})," by wrapping ",(0,t.jsx)(n.code,{children:"Raise<Lce<E, Nothing>>"})," in ",(0,t.jsx)(n.code,{children:"LceRaise"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"@OptIn(ExperimentalTypeInference::class)\ninline fun <E, A> lce(@BuilderInference block: LceRaise<E>.() -> A): Lce<E, A> =\n  recover({ Lce.Content(block(LceRaise(this))) }) { e: Lce<E, Nothing> -> e }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We can now use this DSL to compose our computations and ",(0,t.jsx)(n.code,{children:"Lce"})," values in the same way as we've discussed above in this document.\nFurthermore, since this DSL is built on top of ",(0,t.jsx)(n.code,{children:"Raise"}),", we can use all the functions we've discussed above."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'fun example() {\n  lce {\n    val a = Lce.Content(1).bind()\n    val b = Lce.Content(1).bind()\n    a + b\n  } shouldBe Lce.Content(2)\n\n  lce {\n    val a = Lce.Content(1).bind()\n    ensure(a > 1) { Lce.Failure("a is not greater than 1") }\n    a + 1\n  } shouldBe Lce.Failure("a is not greater than 1")\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If we'd used ",(0,t.jsx)(n.em,{children:"context receivers"}),", defining this DSL would be even more straightforward, and we could use the ",(0,t.jsx)(n.code,{children:"Raise"})," type class directly."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"context(Raise<Lce<E, Nothing>>)\nfun <E, A> Lce<E, A>.bind(): A =  when (this) {\n  is Lce.Content -> value\n  is Lce.Failure -> raise(this)\n  Lce.Loading -> raise(Lce.Loading)\n}\n\ninline fun <E, A> lce(@BuilderInference block: Raise<Lce<E, Nothing>>.() -> A): Lce<E, A> =\n  recover({ Lce.Content(block(this)) }) { e: Lce<E, Nothing> -> e }\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"reflections-on-failure",children:["Reflections on ",(0,t.jsx)(n.code,{children:"Failure"})]}),"\n",(0,t.jsxs)(n.p,{children:["The reason to choose ",(0,t.jsx)(n.code,{children:"Lce<E, Nothing>"})," as type for ",(0,t.jsx)(n.code,{children:"Failure"})," allows for a DSL that has multiple errors.\nLet's consider now a type similar to ",(0,t.jsx)(n.code,{children:"Lce"}),", but with additional states which are not considered success."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"DialogResult<out T>\n \u251c Positive<out T>(value: T) : DialogResult<T>\n \u251c Neutral : DialogResult<Nothing>\n \u251c Negative : DialogResult<Nothing>\n \u2514 Cancelled: DialogResult<Nothing>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We can now not really conveniently provide ",(0,t.jsx)(n.code,{children:"Raise"})," over the ",(0,t.jsx)(n.em,{children:"flat"})," type ",(0,t.jsx)(n.code,{children:"DialogResult"}),", and are kind-of forced to use ",(0,t.jsx)(n.code,{children:"DialogResult<Nothing>"}),". However, if we stratify our type differently,"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"DialogResult<out T>\n \u251c Positive<out T>(value: T) : DialogResult<T>\n \u2514 Error : DialogResult<Nothing>\n    \u251c Neutral : Error\n    \u251c Negative : Error\n    \u2514 Cancelled: Error\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We can again benefit from ",(0,t.jsx)(n.code,{children:"Raise<DialogResult.Error>"}),", and the reason that this is ",(0,t.jsx)(n.strong,{children:"much"})," more desirable, it that you can now also interop with ",(0,t.jsx)(n.code,{children:"Either"}),"!"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"dialogResult {\n  val x: DialogResult.Positive(1).bind()\n  val y: Int = DialogResult.Error.left().bind()\n  x + y\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["That can be useful if you need to for example want to ",(0,t.jsx)(n.em,{children:"accumulate errors"}),", you can now benefit from the default behavior in Kotlin."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"fun dialog(int: Int): DialogResult<Int> =\n  if(int % 2 == 0) DialogResult.Positive(it) else Dialog.Neutral\n\nval res: Either<NonEmptyList<DialogResult.Error>, NonEmptyList<Int>> =\n  listOf(1, 2, 3).mapOrAccumulate { i: Int ->\n    dialog(it).getOrElse { raise(it) }\n  }\n\ndialogResult {\n  res.mapLeft { ... }.bind()\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{title:"Further discussion",type:"info",children:(0,t.jsxs)(n.p,{children:["This section was created as a response to\n",(0,t.jsx)(n.a,{href:"https://github.com/arrow-kt/arrow-website/issues/161",children:"this issue in our repository"}),".\nLet's create great docs for Arrow together!"]})})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>s});var t=i(67294);const o={},r=t.createContext(o);function s(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);