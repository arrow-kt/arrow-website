"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([["203"],{97962:function(e,n,i){i.r(n),i.d(n,{metadata:()=>o,default:()=>u,frontMatter:()=>s,contentTitle:()=>c,toc:()=>l,assets:()=>a});var o=JSON.parse('{"id":"learn/collections-functions/memoize","title":"Memoization","description":"Avoiding duplicate work for pure functions","source":"@site/content/docs/learn/collections-functions/memoize.md","sourceDirName":"learn/collections-functions","slug":"/learn/collections-functions/memoize","permalink":"/learn/collections-functions/memoize","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"description":"Avoiding duplicate work for pure functions"},"sidebar":"learnSidebar","previous":{"title":"Recursive functions","permalink":"/learn/collections-functions/recursive"},"next":{"title":"Control over evaluation","permalink":"/learn/collections-functions/eval"}}'),t=i(74848),r=i(28453);let s={sidebar_position:4,description:"Avoiding duplicate work for pure functions"},c="Memoization",a={},l=[{value:"Simple memoization",id:"simple-memoization",level:2},{value:"Recursion",id:"recursion",level:2}];function d(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"memoization",children:"Memoization"})}),"\n",(0,t.jsxs)(n.p,{children:["Say that your function is pure, that is, given the same inputs it always\nproduces the same outputs, and it doesn't produce any other effects like printing\nto the screen. Then, once you execute the function for a given input, you could\nsave (or cache) the result, so the next time you need it you don't have to compute it\nagain. The general technique of saving outputs to avoid double computation of\npure functions is known as ",(0,t.jsx)(n.em,{children:"memoization"}),"."]}),"\n",(0,t.jsxs)(n.admonition,{type:"warning",children:[(0,t.jsxs)(n.mdxAdmonitionTitle,{children:[(0,t.jsx)(n.code,{children:"MemoizedDeepRecursiveFunction"})," recommended"]}),(0,t.jsxs)(n.p,{children:["The techniques in this section are quite low-level, and require careful\nattention when used in recursive functions.\n",(0,t.jsx)(n.a,{href:"../recursive/#memoized-recursive-functions",children:(0,t.jsx)(n.code,{children:"MemoizedDeepRecursiveFunction"})}),"\nis an easier-to-use alternative, which also provides more options for\nconfiguring the caching policy."]})]}),"\n",(0,t.jsx)(n.h2,{id:"simple-memoization",children:"Simple memoization"}),"\n",(0,t.jsxs)(n.p,{children:["Arrow Core contains a small utility called\n",(0,t.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-functions/arrow.core/memoize.html",children:(0,t.jsx)(n.code,{children:"memoize"})}),"\nwhich transforms any function into one that keeps a cache of computed results."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"import arrow.core.memoize\n\nfun expensive(x: Int): Int {\n  // fake it by sleeping the thread\n  Thread.sleep(x * 100L)\n  return x\n}\n\nval memoizedExpensive = ::expensive.memoize()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The first time you call ",(0,t.jsx)(n.code,{children:"memoizeExpensive"}),", it needs to compute the value.\nFrom that moment on, the call returns immediately."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"fun example() {\n  val result1 = memoizedExpensive(3)\n  val result2 = memoizedExpensive(3)\n  result1 shouldBe result2\n}\n"})}),"\n",(0,t.jsxs)(n.admonition,{title:"Memoization takes memory",type:"caution",children:[(0,t.jsxs)(n.p,{children:["If you define the memoized version of your function as a ",(0,t.jsx)(n.code,{children:"val"}),", as we've done\nabove, the cache is shared among ",(0,t.jsx)(n.strong,{children:"all"})," calls to your function. In the worst\ncase, this may result in memory which cannot be reclaimed throughout the whole\nexecution, so you should apply this technique carefully."]}),(0,t.jsxs)(n.p,{children:["There's some literature about ",(0,t.jsx)(n.a,{href:"https://otee.dev/2021/08/18/cache-replacement-policy.html",children:"eviction policies for memoization"}),",\nbut at the moment of writing memoize doesn't offer any type of control over the\ncached values. ",(0,t.jsx)(n.a,{href:"https://github.com/sksamuel/aedile",children:"Aedile"})," is a Kotlin-first\ncaching library which you can use to manually tweak your memoization."]})]}),"\n",(0,t.jsx)(n.h2,{id:"recursion",children:"Recursion"}),"\n",(0,t.jsxs)(n.p,{children:["The technique outlined above can be applied to any function, regardless of its\nprovenance. However, one needs to be aware of the limitations of ",(0,t.jsx)(n.code,{children:"memoize"})," with\nrespect to recursive functions."]}),"\n",(0,t.jsxs)(n.p,{children:["Let's say we define a recursive Fibonacci function, and call ",(0,t.jsx)(n.code,{children:"memoize"})," with the\nintention of avoiding computing the same values over and over."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"fun fibonacciWorker(n: Int): Int = when (n) {\n  0 -> 0\n  1 -> 1\n  else -> fibonacciWorker(n - 1) + fibonacciWorker(n - 2)\n}\n\nval fibonacci = ::fibonacciWorker.memoize()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This solution falls short, though, because recursion goes through\n",(0,t.jsx)(n.code,{children:"fibonacciWorker"}),", which is ",(0,t.jsx)(n.strong,{children:"not"})," memoized."]}),"\n",(0,t.jsxs)(n.p,{children:["One way to avoid this problem is making ",(0,t.jsx)(n.code,{children:"fibonacciWorker"})," call ",(0,t.jsx)(n.code,{children:"fibonacci"}),"\ninstead. Our recommendation, however, is to use\n",(0,t.jsx)(n.a,{href:"../recursive/#memoized-recursive-functions",children:(0,t.jsx)(n.code,{children:"MemoizedDeepRecursiveFunction"})}),",\nwhich avoids the weird mutually-recursive definition, and has the additional\nbenefit of avoiding stack overflows."]})]})}function u(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:function(e,n,i){i.d(n,{R:()=>s,x:()=>c});var o=i(96540);let t={},r=o.createContext(t);function s(e){let n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);