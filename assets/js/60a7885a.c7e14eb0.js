"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([["264"],{92697:function(e,n,s){s.r(n),s.d(n,{metadata:()=>i,default:()=>h,frontMatter:()=>t,contentTitle:()=>o,toc:()=>c,assets:()=>l});var i=JSON.parse('{"id":"learn/immutable-data/prism-iso","title":"Prisms & Isos","description":"Prisms extend the capabilities of optics from merely inspecting or modifying","source":"@site/content/docs/learn/immutable-data/prism-iso.md","sourceDirName":"learn/immutable-data","slug":"/learn/immutable-data/prism-iso","permalink":"/learn/immutable-data/prism-iso","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"learnSidebar","previous":{"title":"Traversals","permalink":"/learn/immutable-data/traversal"},"next":{"title":"Reflection","permalink":"/learn/immutable-data/reflection"}}'),r=s(74848),a=s(28453);let t={sidebar_position:5},o="Prisms & Isos",l={},c=[{value:"(Sealed) class hierarchies",id:"sealed-class-hierarchies",level:2},{value:"Constructing values",id:"constructing-values",level:3},{value:"Isomorphisms",id:"isomorphisms",level:2},{value:"Value classes",id:"value-classes",level:3}];function d(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"prisms--isos",children:"Prisms & Isos"})}),"\n",(0,r.jsxs)(n.p,{children:["Prisms extend the capabilities of optics from merely inspecting or modifying\nvalues to ",(0,r.jsx)(n.em,{children:"constructing"})," them. This is very useful when using sealed hierarchies\nor value classes."]}),"\n",(0,r.jsx)(n.admonition,{title:"In a rush?",type:"info",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Prisms extend optionals to represent class hierarchies."}),"\n",(0,r.jsxs)(n.li,{children:["Isos extend prisms (and lenses) to represent lossless conversion between types.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"One important case is given by value classes."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["To build a value use ",(0,r.jsx)(n.code,{children:"reverseGet"}),"."]}),"\n"]})}),"\n",(0,r.jsx)(n.h2,{id:"sealed-class-hierarchies",children:"(Sealed) class hierarchies"}),"\n",(0,r.jsxs)(n.p,{children:["The following is an example of ",(0,r.jsx)(n.code,{children:"User"})," where\nwe have two options: a person or a company."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"import arrow.optics.*\n\n@optics sealed interface User {\n  companion object\n}\n@optics data class Person(val name: String, val age: Int): User {\n  companion object\n}\n@optics data class Company(val name: String, val country: String): User {\n  companion object\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The Arrow Optics plug-in generates two optics within ",(0,r.jsx)(n.code,{children:"User"}),", namely\n",(0,r.jsx)(n.code,{children:"User.person"})," and ",(0,r.jsx)(n.code,{children:"User.company"}),". These optics only focus on a value when\nit has the corresponding type. This is often used to modify a value only\nfor a specific type in the hierarchy, leaving the rest untouched. This is\nprecisely what happens in the function below:\n",(0,r.jsx)(n.code,{children:"Person"}),"s get their age incremented, but ",(0,r.jsx)(n.code,{children:"Company"}),"s remains unchanged."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"fun List<User>.happyBirthday() =\n  map { User.person.age.modify(it) { age -> age + 1 } }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Several of the types in Arrow Core fit this pattern of sealed hierarchy, and\nArrow Optics contains optics matching those. One example is ",(0,r.jsx)(n.code,{children:"Either"}),", with\nthe corresponding ",(0,r.jsx)(n.code,{children:"left"})," and ",(0,r.jsx)(n.code,{children:"right"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"constructing-values",children:"Constructing values"}),"\n",(0,r.jsxs)(n.p,{children:["The optics we're discussing in this section provide an added feature: they can\nbe used to ",(0,r.jsx)(n.em,{children:"create"})," new values in addition to inspecting or modifying existing\nones. Optionals with this power are called ",(0,r.jsx)(n.strong,{children:"prisms"}),", and this power is\navailable as the ",(0,r.jsx)(n.code,{children:"reverseGet"})," operation."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, we can build a ",(0,r.jsx)(n.code,{children:"Left"})," value using the corresponding prism\ninstead of the constructor."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"fun example() {\n  val x = Prism.left<Int, String>().reverseGet(5)\n  x shouldBe Either.Left(5)\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"isomorphisms",children:"Isomorphisms"}),"\n",(0,r.jsxs)(n.p,{children:["Prisms allow you to construct values, but still the top of the hierarchy\nmay have different subclasses, so access still required as optional.\nFor example, you can construct an ",(0,r.jsx)(n.code,{children:"Either"})," from ",(0,r.jsx)(n.code,{children:"Right"}),", but when you\ninspect an ",(0,r.jsx)(n.code,{children:"Either"}),", ",(0,r.jsx)(n.code,{children:"Left"})," is also a possibility. There are some cases\nwhen the conversion between two types is lossless: we can go back and forth\nwithout any chance of failure on inspection. We say that there is an\n",(0,r.jsx)(n.em,{children:"isomorphism"})," between those types; for that reason the corresponding optic\nis called an ",(0,r.jsx)(n.strong,{children:"iso"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, we can move between ",(0,r.jsx)(n.code,{children:"Option<String>"})," and ",(0,r.jsx)(n.code,{children:"Either<Unit, String>"}),"\nwithout loss of information. We convert from ",(0,r.jsx)(n.code,{children:"Some"})," to ",(0,r.jsx)(n.code,{children:"Right"}),", and from\n",(0,r.jsx)(n.code,{children:"None"})," to ",(0,r.jsx)(n.code,{children:"Left"}),", and vice versa. There's no loss of information because\n",(0,r.jsx)(n.code,{children:"Unit"})," is an ",(0,r.jsx)(n.code,{children:"object"}),", so there's a single instance which may appear in the\n",(0,r.jsx)(n.code,{children:"Left"})," value."]}),"\n",(0,r.jsx)(n.admonition,{title:"Iso = Prism + Lens",type:"tip",children:(0,r.jsxs)(n.p,{children:["You can see an iso as a prism where ",(0,r.jsx)(n.code,{children:"get"})," always succeeds,\nor as a lens which also supports the ",(0,r.jsx)(n.code,{children:"reverseGet"})," operation."]})}),"\n",(0,r.jsx)(n.h3,{id:"value-classes",children:"Value classes"}),"\n",(0,r.jsxs)(n.p,{children:["One important case in which lossless conversion is possible is given\nby ",(0,r.jsx)(n.a,{href:"https://kotlinlang.org/docs/inline-classes.html",children:"value (or inline) classes"}),",\nwhich wrap a single value as a distinct type. This kind of classes are\nvery useful to ",(0,r.jsx)(n.a,{href:"../../design/domain-modeling/",children:"model your domain accurately"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"@optics data class Person(val name: String, val age: Age) {\n  companion object\n}\n\n@JvmInline @optics value class Age(val age: Int) {\n  companion object\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Since isos are also lenses, you can still use the syntax from ",(0,r.jsx)(n.a,{href:"../lens/",children:"the latter"}),"\nto access the value contained in the class."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'fun Person.happyBirthday(): Person =\n  Person.age.age.modify(this) { it + 1 }\n\nfun example() {\n  val p = Person("me", Age(29))\n  p.happyBirthday().age shouldBe Age(30)\n}\n'})})]})}function h(e={}){let{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:function(e,n,s){s.d(n,{R:()=>t,x:()=>o});var i=s(96540);let r={},a=i.createContext(r);function t(e){let n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);