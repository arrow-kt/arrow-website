"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[9863],{60811:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>t,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var o=i(85893),c=i(11151);const r={sidebar_position:3,description:"Making functions stack-safe and efficient"},t="Recursive functions",a={id:"learn/collections-functions/recursive",title:"Recursive functions",description:"Making functions stack-safe and efficient",source:"@site/content/docs/learn/collections-functions/recursive.md",sourceDirName:"learn/collections-functions",slug:"/learn/collections-functions/recursive",permalink:"/learn/collections-functions/recursive",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/collections-functions/recursive.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,description:"Making functions stack-safe and efficient"},sidebar:"learnSidebar",previous:{title:"Collectors",permalink:"/learn/collections-functions/collectors"},next:{title:"Memoization",permalink:"/learn/collections-functions/memoize"}},s={},l=[{value:"Stack-safe deep recursive functions",id:"stack-safe-deep-recursive-functions",level:2},{value:"Memoized recursive functions",id:"memoized-recursive-functions",level:2},{value:"Memoization takes memory",id:"memoization-takes-memory",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",...(0,c.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"recursive-functions",children:"Recursive functions"}),"\n",(0,o.jsxs)(n.p,{children:["Algorithms with a functional flavor tend to favor recursion over looping.\nThis is often hidden in higher-level functions like ",(0,o.jsx)(n.code,{children:"map"})," and ",(0,o.jsx)(n.code,{children:"filter"}),",\nso you don't often see it on your code. However, when the time comes, some\nplatforms (including the JVM) can make your life quite difficult: deep\nrecursion means a deep stack, so you can easily get a ",(0,o.jsx)(n.code,{children:"StackOverflowError"}),",\neven for not-so-big values."]}),"\n",(0,o.jsx)(n.admonition,{title:"Where to find it",type:"note",children:(0,o.jsxs)(n.p,{children:["Support for memoized deep recursive functions is available in the ",(0,o.jsx)(n.code,{children:"arrow-core"})," library. Integration with cache4k is provided in its own ",(0,o.jsx)(n.code,{children:"arrow-cache4k"})," library."]})}),"\n",(0,o.jsx)(n.h2,{id:"stack-safe-deep-recursive-functions",children:"Stack-safe deep recursive functions"}),"\n",(0,o.jsxs)(n.p,{children:["Kotlin comes with a built-in ",(0,o.jsx)(n.a,{href:"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-deep-recursive-function/",children:(0,o.jsx)(n.code,{children:"DeepRecursiveFunction"})}),"\nwhich solves this problem by keeping the call stack in the heap, which usually\nhas a much bigger memory space allocated to it."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Fibonacci_sequence",children:"Fibonacci sequence"})," is\nan all-time favorite example of a recursive operation which requires a deep stack\neven for small values. The function is only defined for non-negative ",(0,o.jsx)(n.code,{children:"n"}),",\nso we split the actual worker function from the top-level one, which checks the\nconstraint over the argument."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun fibonacciWorker(n: Int): Int = when (n) {\n  0 -> 0\n  1 -> 1\n  else -> fibonacciWorker(n - 1) + fibonacciWorker(n - 2)\n}\n\nfun fibonacci(n: Int): Int {\n  require(n >= 0)\n  return fibonacciWorker(n)\n}\n\nfun example() {\n  fibonacci(6) shouldBe 8\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To make this function stack-safe we move the worker from being a regular\nfunction into being a ",(0,o.jsx)(n.code,{children:"DeepRecursiveFunction"}),". The latter takes a block which\ndefines the function, very similar to a regular one. The key change is that\ninstead of calling ",(0,o.jsx)(n.code,{children:"fibonacciWorker"}),", we use ",(0,o.jsx)(n.code,{children:"callRecursive"})," every time we\nneed recursion."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"val fibonacciWorker = DeepRecursiveFunction<Int, Int> { n ->\n  when (n) {\n    0 -> 0\n    1 -> 1\n    else -> callRecursive(n - 1) + callRecursive(n - 2)\n  }\n}\n"})}),"\n",(0,o.jsx)(n.admonition,{title:"Function in a val",type:"caution",children:(0,o.jsxs)(n.p,{children:["Note that we've used ",(0,o.jsx)(n.code,{children:"val"})," to save the ",(0,o.jsx)(n.code,{children:"DeepRecursiveFunction"}),", instead of\n",(0,o.jsx)(n.code,{children:"fun"}),". However, since that type overloads the ",(0,o.jsx)(n.code,{children:"invoke"})," operator, we still\ncan call it as if it was a function, so no changes are required for ",(0,o.jsx)(n.code,{children:"fibonacci"}),"."]})}),"\n",(0,o.jsx)(n.h2,{id:"memoized-recursive-functions",children:"Memoized recursive functions"}),"\n",(0,o.jsxs)(n.p,{children:["There's an enormous amount of duplicate work being done in a call to ",(0,o.jsx)(n.code,{children:"fibonacci"}),".\nHere is the call tree of ",(0,o.jsx)(n.code,{children:"fibonacciWorker(4)"}),", you can see that we end up in\n",(0,o.jsx)(n.code,{children:"fibonacci(2)"})," a couple of times. Not only that: we can see that in the recursive\ncall for ",(0,o.jsx)(n.code,{children:"n - 1"})," we eventually require the value for ",(0,o.jsx)(n.code,{children:"n - 2"})," too. Could we make\nthis function a bit less wasteful?"]}),"\n",(0,o.jsx)(n.mermaid,{value:"graph TD;\n  4--\x3e3a;\n  3a[3];\n  3a--\x3e2a;\n  3a--\x3e1a;\n  2a[2];\n  1a[1];\n  2a--\x3e1b;\n  1b[1];\n  2a--\x3e0b;\n  0b[0]\n  4--\x3e2b;\n  2b[2];\n  2b--\x3e1c;\n  1c[1];\n  2b--\x3e0c;\n  0c[0];"}),"\n",(0,o.jsx)(n.admonition,{title:"Fibonacci \ud83e\udd2f",type:"info",children:(0,o.jsx)(n.p,{children:"The number of calls required to compute Fibonacci is also given by the Fibonacci\nsequence!"})}),"\n",(0,o.jsxs)(n.p,{children:["Fibonacci is a pure function, in other words, given the same argument we always\nobtain the same result. This means that once we've computed a value, we can just\n",(0,o.jsx)(n.em,{children:"record"})," in some cache, so later invocations only have to look there. This\ntechnique is known as ",(0,o.jsx)(n.strong,{children:"memoization"}),", and Arrow provides an implementation\nin the form of ",(0,o.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-core/arrow.core/-memoized-deep-recursive-function.html",children:(0,o.jsx)(n.code,{children:"MemoizedDeepRecursiveFunction"})}),".\nNo changes other than the outer call are required."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"import arrow.core.MemoizedDeepRecursiveFunction\n\nval fibonacciWorker = MemoizedDeepRecursiveFunction<Int, Int> { n ->\n  when (n) {\n    0 -> 0\n    1 -> 1\n    else -> callRecursive(n - 1) + callRecursive(n - 2)\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"memoization-takes-memory",children:"Memoization takes memory"}),"\n",(0,o.jsxs)(n.p,{children:["If you define the memoized version of your function as a ",(0,o.jsx)(n.code,{children:"val"})," as we've done\nabove, the cache is shared among ",(0,o.jsx)(n.strong,{children:"all"})," calls to your function. In the worst\ncase, this may result in memory which cannot be reclaimed throughout the whole\nexecution. If this may pose a problem in your application, you should\nconsider a better ",(0,o.jsx)(n.a,{href:"https://otee.dev/2021/08/18/cache-replacement-policy.html",children:"eviction policy for the cache"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["You can tweak ",(0,o.jsx)(n.code,{children:"MemoizedDeepRecursiveFunction"}),"'s caching mechanism using\nthe ",(0,o.jsx)(n.code,{children:"cache"})," parameter. Apart from the built-in options, we provide integration\nwith ",(0,o.jsx)(n.a,{href:"https://reactivecircus.github.io/cache4k/",children:"cache4k"}),", a Multiplatform-ready\nlibrary that covers all your desired caching options, in the form of\n",(0,o.jsx)(n.code,{children:"arrow-cache4k"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"import arrow.core.MemoizedDeepRecursiveFunction\nimport arrow.core.Cache4kMemoizationCache\nimport arrow.core.buildCache4K\n\nval cache = buildCache4K<Int, Int> { maximumCacheSize(100) }\n\nval fibonacciWorker = MemoizedDeepRecursiveFunction<Int, Int>(\n  Cache4kMemoizationCache(cache)\n) { n ->\n  when (n) {\n    0 -> 0\n    1 -> 1\n    else -> callRecursive(n - 1) + callRecursive(n - 2)\n  }\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,c.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>t});var o=i(67294);const c={},r=o.createContext(c);function t(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:t(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);