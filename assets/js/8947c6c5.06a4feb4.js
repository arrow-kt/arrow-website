"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([["5151"],{12259:function(e,n,r){r.r(n),r.d(n,{metadata:()=>t,default:()=>p,frontMatter:()=>l,contentTitle:()=>c,toc:()=>h,assets:()=>d});var t=JSON.parse('{"id":"learn/typed-errors/working-with-typed-errors","title":"Working with typed errors","description":"Working, recovering, and accumulating errors in a typed and concise way.","source":"@site/content/docs/learn/typed-errors/working-with-typed-errors.md","sourceDirName":"learn/typed-errors","slug":"/learn/typed-errors/working-with-typed-errors","permalink":"/learn/typed-errors/working-with-typed-errors","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"description":"Working, recovering, and accumulating errors in a typed and concise way.","sidebar_position":1},"sidebar":"learnSidebar","previous":{"title":"Typed Errors","permalink":"/learn/typed-errors/"},"next":{"title":"Validation","permalink":"/learn/typed-errors/validation"}}'),i=r(74848),o=r(28453),s=r(78010),a=r(57250);let l={description:"Working, recovering, and accumulating errors in a typed and concise way.",sidebar_position:1},c="Working with typed errors",d={},h=[{value:"Concepts and types",id:"concepts-and-types",level:2},{value:"Defining the success / happy path",id:"defining-the-success--happy-path",level:2},{value:"Raising an error",id:"raising-an-error",level:2},{value:"Running and inspecting results",id:"running-and-inspecting-results",level:2},{value:"Recovering from typed errors",id:"recovering-from-typed-errors",level:2},{value:"From logical failures",id:"from-logical-failures",level:3},{value:"From exceptions",id:"from-exceptions",level:3},{value:"Accumulating errors",id:"accumulating-errors",level:2},{value:"Accumulating different computations",id:"accumulating-different-computations",level:3},{value:"Transforming errors",id:"transforming-errors",level:2},{value:"Summary",id:"summary",level:2}];function u(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"working-with-typed-errors",children:"Working with typed errors"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Typed errors"})," refer to a technique from functional programming in which we\nmake ",(0,i.jsx)(n.em,{children:"explicit"})," in the signature (or ",(0,i.jsx)(n.em,{children:"type"}),") the potential errors that may\narise during the execution of a piece of code. This is not the case when using\nexceptions, where any documentation that we might provide is not taken into account by the compiler,\nleading to a defensive mode of error handling."]}),"\n",(0,i.jsx)(n.admonition,{title:"Media resources",type:"info",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://kotlindevday.com/videos/functional-error-handling-a-practical-approach-bas-de-groot/",children:(0,i.jsx)(n.em,{children:"Functional Error Handling - A Practical Approach"})})," by Bas de Groot"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://www.youtube.com/watch?v=ipF540mBG9w",children:(0,i.jsx)(n.em,{children:"Exception handling in Kotlin with Arrow"})})," by Ramandeep Kaur"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://www.youtube.com/watch?v=8WdprhzmQe4",children:(0,i.jsx)(n.em,{children:"Por qu\xe9 no uso excepciones en mi c\xf3digo"})})," by Ra\xfal Raja and ",(0,i.jsx)(n.a,{href:"https://codely.com/",children:"Codely"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://medium.com/@mitchellyuwono/typed-error-handling-in-kotlin-11ff25882880",children:(0,i.jsx)(n.em,{children:"Typed error handling in Kotlin"})})," by Mitchell Yuwono"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Functional Error Handling in Kotlin"})," by Riccardo Cardin (video and text): ",(0,i.jsx)(n.a,{href:"https://blog.rockthejvm.com/functional-error-handling-in-kotlin/",children:"part 1"}),", ",(0,i.jsx)(n.a,{href:"https://blog.rockthejvm.com/functional-error-handling-in-kotlin-part-2/",children:"part 2"}),", and ",(0,i.jsx)(n.a,{href:"https://blog.rockthejvm.com/functional-error-handling-in-kotlin-part-3/",children:"part 3"})]}),"\n"]})}),"\n",(0,i.jsx)(n.h2,{id:"concepts-and-types",children:"Concepts and types"}),"\n",(0,i.jsx)(n.p,{children:"In the rest of the documentation we often refer to a few concepts related to error handling."}),"\n",(0,i.jsxs)(n.admonition,{title:"Logical Failure vs. Real exceptions",type:"note",children:[(0,i.jsxs)(n.p,{children:["We use the term ",(0,i.jsx)(n.em,{children:"logical failure"})," to describe a situation not deemed as successful in your domain, but that is still within the realms of that domain.\nFor example, if you are implementing a repository for users, not finding a user for a certain query is a logical failure."]}),(0,i.jsxs)(n.p,{children:["In contrast to logical failures we have ",(0,i.jsx)(n.em,{children:"real exceptions"}),", which are problems, usually technical, which are ",(0,i.jsx)(n.em,{children:"truly exceptional"})," and are thus not part of our domain.\nFor example, if the connection to the database suddenly drops, or network times out, host unavailable, etcetera.\nThose cases benefit from the ",(0,i.jsx)(n.a,{href:"../../resilience/",children:"resilience mechanisms"})," provided by Arrow."]})]}),"\n",(0,i.jsx)(n.admonition,{title:"Success and failure",type:"note",children:(0,i.jsxs)(n.p,{children:["When talking about error handling, we often distinguish between ",(0,i.jsx)(n.em,{children:"success"})," or ",(0,i.jsx)(n.em,{children:"happy path"}),", and ",(0,i.jsx)(n.em,{children:"failure"}),".\nThe former represents the case in which everything works as intended, whereas the latter represents a problem.\nDepending on the approach, the signature of the function only signals that a failure is possible,\nor additionally describes the range of problems that may arise."]})}),"\n",(0,i.jsxs)(n.p,{children:["There are two main approaches to representing types in the signature of a function.\nFortunately, Arrow provides a ",(0,i.jsx)(n.em,{children:"uniform"})," API for working with all of them, which is described in the rest of this section."]}),"\n",(0,i.jsxs)(n.p,{children:["The first approach is using a ",(0,i.jsx)(n.em,{children:"wrapper type"}),", in which the return type of your function\nis nested within a larger type that provides the choice of error.\nIn that way the error is represented as a ",(0,i.jsx)(n.em,{children:"value"}),".\nFor example, the following signature expresses that the outcome of ",(0,i.jsx)(n.code,{children:"findUser"})," is\nof type ",(0,i.jsx)(n.code,{children:"User"})," when successful, or ",(0,i.jsx)(n.code,{children:"UserNotFound"})," when a logical failure is raised."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"fun findUser(id: UserId): Either<UserNotFound, User>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The Kotlin standard library includes a few wrapper types, but they are all restricted in the information they may include.\nArrow introduces ",(0,i.jsx)(n.code,{children:"Either"})," and ",(0,i.jsx)(n.code,{children:"Ior"}),", both giving the developer the choice of type of logical failures, and reflecting that choice as their first type parameter.\nAfter reading this introduction, you can read about the different ",(0,i.jsx)(n.a,{href:"../wrappers",children:"wrapper types"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The second approach is describing errors as part of the ",(0,i.jsx)(n.em,{children:"computation context"})," of the function.\nIn that case the ability to finish with logical failures is represented by having ",(0,i.jsx)(n.code,{children:"Raise<E>"}),"\nbe part of the context or scope of the function. Kotlin offers two choices here: we can use\nan extension receiver, and in the future we may use context parameters."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Raise<UserNotFound> is extension receiver\nfun Raise<UserNotFound>.findUser(id: UserId): User\n// Raise<UserNotFound> is context parameter\ncontext(_: Raise<UserNotFound>) fun findUser(id: UserId): User\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's define a simple program that ",(0,i.jsx)(n.em,{children:"raises"})," a ",(0,i.jsx)(n.em,{children:"logical failure"})," of ",(0,i.jsx)(n.code,{children:"UserNotFound"})," or returns a ",(0,i.jsx)(n.code,{children:"User"}),". We can represent this both as a value ",(0,i.jsx)(n.code,{children:"Either<UserNotFound, User>"}),", and as a ",(0,i.jsx)(n.em,{children:"computation"})," (using ",(0,i.jsx)(n.code,{children:"Raise<UserNotFound>"}),")."]}),"\n",(0,i.jsx)(n.admonition,{title:"Two examples per code block",type:"caution",children:(0,i.jsxs)(n.p,{children:["In the examples in this document we use ",(0,i.jsx)(n.code,{children:"Either<E, A>"})," as wrapper type and\n",(0,i.jsx)(n.code,{children:"Raise<E>"})," as extension receiver, with the intention of the reader choosing\ntheir preferred type. Note that the same ideas and techniques apply to the\nrest of choices outlined above."]})}),"\n",(0,i.jsx)(n.h2,{id:"defining-the-success--happy-path",children:"Defining the success / happy path"}),"\n",(0,i.jsxs)(n.p,{children:["The code below shows how we can define a function which ",(0,i.jsx)(n.em,{children:"successfully"})," returns a ",(0,i.jsx)(n.code,{children:"User"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"object UserNotFound\ndata class User(val id: Long)\n\n// wrapper type approach\nval user: Either<UserNotFound, User> = User(1).right()\n\n// computation context approach\nfun Raise<UserNotFound>.user(): User = User(1)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the case of ",(0,i.jsx)(n.code,{children:"Either"}),", since we are creating a ",(0,i.jsx)(n.em,{children:"value"})," (note the use of ",(0,i.jsx)(n.code,{children:"val"}),") we need to additionally wrap our value in the type that represents success.\nThis type is called ",(0,i.jsx)(n.code,{children:"Right"}),", although it's common to use the ",(0,i.jsx)(n.code,{children:".right()"})," extension function to give more predominance to the value itself.\nIn the case of a ",(0,i.jsx)(n.em,{children:"computation"})," (note the use of ",(0,i.jsx)(n.code,{children:"fun"}),") with ",(0,i.jsx)(n.code,{children:"Raise"})," the value is returned directly."]}),"\n",(0,i.jsx)(n.h2,{id:"raising-an-error",children:"Raising an error"}),"\n",(0,i.jsxs)(n.p,{children:["To create a ",(0,i.jsx)(n.em,{children:"value"})," of a ",(0,i.jsx)(n.em,{children:"logical failure"}),", we use the ",(0,i.jsx)(n.code,{children:"left"})," ",(0,i.jsx)(n.em,{children:"smart-constructor"})," for ",(0,i.jsx)(n.code,{children:"Either"}),", or ",(0,i.jsx)(n.code,{children:"raise"})," DSL function for a ",(0,i.jsx)(n.em,{children:"logical failure"})," inside a ",(0,i.jsx)(n.code,{children:"Raise"})," ",(0,i.jsx)(n.em,{children:"computation"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"// wrapper type approach\nval error: Either<UserNotFound, User> = UserNotFound.left()\n\n// computation context approach\nfun Raise<UserNotFound>.error(): User = raise(UserNotFound)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Besides ",(0,i.jsx)(n.code,{children:"raise"})," or ",(0,i.jsx)(n.code,{children:"left"}),", several DSLs are also available to check invariants.\n",(0,i.jsx)(n.code,{children:"either { }"})," and ",(0,i.jsx)(n.code,{children:"Raise"})," offer ",(0,i.jsx)(n.code,{children:"ensure"})," and ",(0,i.jsx)(n.code,{children:"ensureNotNull"}),", mirroring the style of ",(0,i.jsx)(n.code,{children:"require"})," and ",(0,i.jsx)(n.code,{children:"requireNotNull"})," from the Kotlin Std Lib.\nInstead of throwing an exception, they result in a ",(0,i.jsx)(n.em,{children:"logical failure"})," with the given error if the predicate is not satisfied."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ensure"})," takes a ",(0,i.jsx)(n.em,{children:"predicate"})," and a ",(0,i.jsx)(n.em,{children:"lazy"})," evaluated ",(0,i.jsx)(n.code,{children:"UserNotFound"})," value. When the ",(0,i.jsx)(n.em,{children:"predicate"})," is not matched, the ",(0,i.jsx)(n.em,{children:"computation"})," will result in a ",(0,i.jsx)(n.em,{children:"logical failure"})," of ",(0,i.jsx)(n.code,{children:"UserNotFound"}),".\nIn the function below, we show how we can use ",(0,i.jsx)(n.code,{children:"ensure"})," to check if a given ",(0,i.jsx)(n.code,{children:"User"})," has a valid id, and if not, we return a ",(0,i.jsx)(n.em,{children:"logical failure"})," of ",(0,i.jsx)(n.code,{children:"UserNotFound"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'data class UserNotFound(val message: String)\n\n// wrapper type approach\nfun User.isValid(): Either<UserNotFound, Unit> = either {\n  ensure(id > 0) { UserNotFound("User without a valid id: $id") }\n}\n\n// computation context approach\nfun Raise<UserNotFound>.isValid(user: User): User {\n  ensure(user.id > 0) { UserNotFound("User without a valid id: ${user.id}") }\n  return user\n}\n\nfun example() {\n  User(-1).isValid() shouldBe UserNotFound("User without a valid id: -1").left()\n\n  fold(\n    { isValid(User(1)) },\n    { _: UserNotFound -> fail("No logical failure occurred!") },\n    { user: User -> user.id shouldBe 1 }\n  )\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Without context receivers, these functions look pretty different depending on whether we use ",(0,i.jsx)(n.code,{children:"Raise"})," or ",(0,i.jsx)(n.code,{children:"Either"}),". This is because we sacrifice our ",(0,i.jsx)(n.em,{children:"extension receiver"})," for ",(0,i.jsx)(n.code,{children:"Raise"}),".\nAnd thus, the ",(0,i.jsx)(n.code,{children:"Raise"})," based computation cannot be an extension function on ",(0,i.jsx)(n.code,{children:"User"}),".\nIn the future, context parameters should allow us to define the function as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'context(_: Raise<UserNotFound>)\nfun User.isValid(): Unit =\n  ensure(id > 0) { UserNotFound("User without a valid id: $id") }\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ensureNotNull"})," takes a ",(0,i.jsx)(n.em,{children:"nullable value"})," and a ",(0,i.jsx)(n.em,{children:"lazy"})," evaluated ",(0,i.jsx)(n.code,{children:"UserNotFound"})," value. When the value is null, the ",(0,i.jsx)(n.em,{children:"computation"})," will result in a ",(0,i.jsx)(n.em,{children:"logical failure"})," of ",(0,i.jsx)(n.code,{children:"UserNotFound"}),".\nOtherwise, the value will be ",(0,i.jsx)(n.em,{children:"smart-casted"})," to non-null, and you can operate on it without checking nullability.\nIn the function below, we show how we can use ",(0,i.jsx)(n.code,{children:"ensureNotNull"})," to check if a given ",(0,i.jsx)(n.code,{children:"User"})," is non-null, and if not, we return a ",(0,i.jsx)(n.em,{children:"logical failure"})," of ",(0,i.jsx)(n.code,{children:"UserNotFound"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'// wrapper type approach\nfun process(user: User?): Either<UserNotFound, Long> = either {\n  ensureNotNull(user) { UserNotFound("Cannot process null user") }\n  user.id // smart-casted to non-null\n}\n\n// computation context approach\nfun Raise<UserNotFound>.process(user: User?): Long {\n  ensureNotNull(user) { UserNotFound("Cannot process null user") }\n  return user.id // smart-casted to non-null\n}\n\nfun example() {\n  process(null) shouldBe UserNotFound("Cannot process null user").left()\n\n  fold(\n    { process(User(1)) },\n    { _: UserNotFound -> fail("No logical failure occurred!") },\n    { i: Long -> i shouldBe 1L }\n  )\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"running-and-inspecting-results",children:"Running and inspecting results"}),"\n",(0,i.jsxs)(n.p,{children:["We ",(0,i.jsx)(n.em,{children:"inspect"})," the value of ",(0,i.jsx)(n.code,{children:"res"})," using Kotlin's ",(0,i.jsx)(n.code,{children:"when"}),", or ",(0,i.jsx)(n.code,{children:"fold"})," the ",(0,i.jsx)(n.em,{children:"computation"})," providing a lambda for both the ",(0,i.jsx)(n.em,{children:"logical failure"})," and the ",(0,i.jsx)(n.em,{children:"success"})," case."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'fun example() {\n  when (error) {\n    is Left -> error.value shouldBe UserNotFound\n    is Right -> fail("A logical failure occurred!")\n  }\n\n  fold(\n    block = { error() },\n    recover = { e: UserNotFound -> e shouldBe UserNotFound },\n    transform = { _: User -> fail("A logical failure occurred!") }\n  )\n}\n'})}),"\n",(0,i.jsx)(n.admonition,{title:"Fold over all possible cases",type:"info",children:(0,i.jsxs)(n.p,{children:["Unless you explicitly wrap your code to catch exceptions as part of ",(0,i.jsx)(n.code,{children:"Either"})," or ",(0,i.jsx)(n.code,{children:"Raise"}),", exceptions bubble up in the usual way. If you need to handle those exceptions, ",(0,i.jsx)(n.code,{children:"fold"})," is also available with a ",(0,i.jsx)(n.code,{children:"catch"})," argument to recover from any ",(0,i.jsx)(n.code,{children:"Throwable"})," that might've been thrown. ",(0,i.jsx)(n.a,{href:"#from-exceptions",children:"More information can be found below"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["Another possibility is to have a ",(0,i.jsx)(n.code,{children:"Raise"})," computation, that we would like to turn into a wrapper type.\nIn that case we don't have to call ",(0,i.jsx)(n.code,{children:"fold"}),", we can use one of the runners, each of them named as the wrapper type, but with all letters in lowercase."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun example() {\n  either { error() } shouldBe UserNotFound.left()\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The opposite conversion, turning a value of a type like ",(0,i.jsx)(n.code,{children:"Either"})," into a\ncomputation with ",(0,i.jsx)(n.code,{children:"Raise"}),", is achieved via the ",(0,i.jsx)(n.code,{children:".bind()"})," extension function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun Raise<UserNotFound>.res(): User = user.bind()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In fact, to define a result with a wrapper type, we recommend to use one\nof the runners (",(0,i.jsx)(n.code,{children:"either"}),", ",(0,i.jsx)(n.code,{children:"ior"}),", et cetera), and use ",(0,i.jsx)(n.code,{children:".bind()"}),' to "inject"\nany sub-computation that might be required, or ',(0,i.jsx)(n.code,{children:"raise"})," to describe a logical\nfailure. We often refer to this approach as ",(0,i.jsxs)(n.em,{children:["using the ",(0,i.jsx)(n.code,{children:"Raise"})," DSL"]}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val maybeTwo: Either<Problem, Int> = either { 2 }\nval maybeFive: Either<Problem, Int> = either { raise(Problem) }\n\nval maybeSeven: Either<Problem, Int> = either {\n  maybeTwo.bind() + maybeFive.bind()\n}\n"})}),"\n",(0,i.jsx)(n.mermaid,{value:'graph LR;\n  raise{{"Raise&lt;E&gt;.() -> A"}};\n  other{{"WrapperType&lt;E, A&gt;"}};\n  raise--\x3e|nullable / result / either / ior|other;\n  other--\x3e|".bind()"|raise;'}),"\n",(0,i.jsx)(n.admonition,{title:"Don't forget your binds!",type:"info",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://github.com/woltapp/arrow-detekt-rules",children:"Arrow Detekt Rules"})," project has a set of rules to ",(0,i.jsx)(n.em,{children:"detekt"})," that you call ",(0,i.jsx)(n.code,{children:"bind"})," on every ",(0,i.jsx)(n.code,{children:"Either"})," value."]})}),"\n",(0,i.jsxs)(n.admonition,{title:"Nested error types",type:"info",children:[(0,i.jsxs)(n.p,{children:["Sometimes you might need to have one error type nested inside another one,\nlike ",(0,i.jsx)(n.code,{children:"Either<Problem, Int?>"}),". The rule of thumb in that case is to nest the\nrunner functions (",(0,i.jsx)(n.code,{children:"either"}),", ",(0,i.jsx)(n.code,{children:"option"}),", ",(0,i.jsx)(n.code,{children:"nullable"}),") in the same order as they\nappear in the type. When you call ",(0,i.jsx)(n.code,{children:"raise"}),', the type of the error given as\nan argument is used to "select" the appropriate type to fall back to.']}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun problematic(n: Int): Either<Problem, Int?> =\n  either { \n    nullable { \n      when {\n        n < 0  -> raise(Problem)\n        n == 0 -> raise(null)\n        else   -> n\n      }\n    }\n  }\n"})})]}),"\n",(0,i.jsx)(n.admonition,{title:"Tracing the origin of a raise",type:"info",children:(0,i.jsxs)(n.p,{children:["As projects grow in size, raised errors propagate through the call stack. To make debugging easier, Arrow provides a way to trace calls to ",(0,i.jsx)(n.code,{children:"raise"})," and ",(0,i.jsx)(n.code,{children:"bind"}),": ",(0,i.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-core/arrow.core.raise/traced.html",children:"see Raise.traced"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"recovering-from-typed-errors",children:"Recovering from typed errors"}),"\n",(0,i.jsxs)(n.p,{children:["We've already hinted at this distinction above, but when working with type errors it's important to distinguish between two kinds of ",(0,i.jsx)(n.em,{children:"problems"})," that may arise:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Logical failures"})," indicate problems within the domain, and those should be handled as part of the usual domain logic. For example, trying to find a user which doesn't exist, or validating input data."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Exceptions"})," indicate problems which affect the system's ability to continue working. For example, if the database connection breaks this is something outside your domain logic."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Historically exceptions have been used for both cases. For example, throwing a ",(0,i.jsx)(n.code,{children:"UserNotValidException"})," when the input data was wrong.\nWe advocate for making this distinction clear in the types, and leave exceptions only for exceptional cases.\nHowever, we're also aware of the historical baggage, so we provide tools to transforms those exceptions which shouldn't have been exceptions in the first place into typed errors."]}),"\n",(0,i.jsx)(n.h3,{id:"from-logical-failures",children:"From logical failures"}),"\n",(0,i.jsxs)(n.p,{children:["When working with values or functions that can result in a typed error, we often need to ",(0,i.jsx)(n.em,{children:"recover"})," to provide or calculate fallback values.\nTo demonstrate how we can ",(0,i.jsx)(n.em,{children:"recover"})," from ",(0,i.jsx)(n.em,{children:"logical failures"}),", let's define a simple function that returns our ",(0,i.jsx)(n.code,{children:"User"})," in case the ",(0,i.jsx)(n.code,{children:"id > 0"}),"; otherwise it returns ",(0,i.jsx)(n.code,{children:"UserNotFound"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'// wrapper type approach\nsuspend fun fetchUser(id: Long): Either<UserNotFound, User> = either {\n  ensure(id > 0) { UserNotFound("Invalid id: $id") }\n  User(id)\n}\n\n// computation context approach\nsuspend fun Raise<UserNotFound>.fetchUser(id: Long): User {\n  ensure(id > 0) { UserNotFound("Invalid id: $id") }\n  return User(id)\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To recover from any errors on a ",(0,i.jsx)(n.code,{children:"Either"})," value, we can most conveniently use ",(0,i.jsx)(n.code,{children:"getOrElse"}),", since it allows us to ",(0,i.jsx)(n.em,{children:"unwrap"})," the ",(0,i.jsx)(n.code,{children:"Either"})," and provide a fallback value.\nThe same can be done for the ",(0,i.jsx)(n.code,{children:"Raise"})," based computation using the ",(0,i.jsx)(n.code,{children:"recover"})," DSL instead."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"suspend fun example() {\n  // wrapper type approach\n  fetchUser(-1)\n    .getOrElse { e: UserNotFound -> null } shouldBe null\n  \n  // computation context approach\n  recover({\n    fetchUser(1)\n  }) { e: UserNotFound -> null } shouldBe User(1)\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Defaulting to ",(0,i.jsx)(n.code,{children:"null"})," is typically not desired since we've effectively swallowed our ",(0,i.jsx)(n.em,{children:"logical failure"})," and ignored our error. If that was desirable, we could've used nullable types in the first place.\nWhen encountering a ",(0,i.jsx)(n.em,{children:"logical failure"})," and not being able to provide a proper fallback value, we typically want to execute another operation that might fail with ",(0,i.jsx)(n.code,{children:"OtherError"}),".\nAs a result, our ",(0,i.jsx)(n.code,{children:"Either"})," value doesn't get ",(0,i.jsx)(n.em,{children:"unwrapped"})," as it did with ",(0,i.jsx)(n.code,{children:"getOrElse"}),", since a different ",(0,i.jsx)(n.em,{children:"logical failure"})," might've occurred."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"object OtherError\n\nfun example() {\n  val either: Either<OtherError, User> =\n    fetchUser(1)\n      .recover { _: UserNotFound -> raise(OtherError) }\n  \n  either shouldBe User(1).right()\n\n  fetchUser(-1)\n    .recover { _: UserNotFound -> raise(OtherError) } shouldBe OtherError.left()\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The type system now tracks that a new error of ",(0,i.jsx)(n.code,{children:"OtherError"})," might have occurred, but we've recovered from any possible errors of ",(0,i.jsx)(n.code,{children:"UserNotFound"}),". This is useful across application layers or in the service layer, where we might want to ",(0,i.jsx)(n.code,{children:"recover"})," from a ",(0,i.jsx)(n.code,{children:"DatabaseError"})," with a ",(0,i.jsx)(n.code,{children:"NetworkError"})," when we want to load data from the network when a database operation failed.\nTo achieve the same with the ",(0,i.jsx)(n.code,{children:"Raise"})," DSL, we need to be inside the context of ",(0,i.jsx)(n.code,{children:"Raise<OtherError>"})," to ",(0,i.jsx)(n.code,{children:"raise"})," it."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"// computation context approach\nsuspend fun Raise<OtherError>.recovery(): User =\n  recover({\n    fetchUser(-1)\n  }) { _: UserNotFound -> raise(OtherError) }\n"})}),"\n",(0,i.jsx)(n.admonition,{title:"DSLs everywhere",type:"tip",children:(0,i.jsxs)(n.p,{children:["Since recovery for both ",(0,i.jsx)(n.code,{children:"Either"})," and ",(0,i.jsx)(n.code,{children:"Raise"})," is DSL based, you can also call ",(0,i.jsx)(n.code,{children:"bind"})," or ",(0,i.jsx)(n.code,{children:"raise"})," from both.\nThis allows for a seamless interop between both types when creating programs that can fail and recovering from them."]})}),"\n",(0,i.jsx)(n.h3,{id:"from-exceptions",children:"From exceptions"}),"\n",(0,i.jsxs)(n.p,{children:["When building applications, we often need to wrap side effects or foreign code, like when interacting with the network or databases.\nWrapping such APIs requires handling the possibility of failure, and we can do so by returning a ",(0,i.jsx)(n.em,{children:"logical failure"}),". The question is often, do we need to take into ",(0,i.jsx)(n.strong,{children:"all"})," exceptions or just a subset of them?\nThe answer is that it depends on the use case, but, in general, we should try to be as specific as possible and only handle the exceptions that we can recover from or expect.\nHowever, you might want to be more defensive when interacting with improperly defined systems."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's look at an example where we interact with a database and want to insert a new user. If the user already exists, we want to return a ",(0,i.jsx)(n.em,{children:"logical failure"})," of ",(0,i.jsx)(n.code,{children:"UserAlreadyExists"}),". Otherwise, we want to return the newly created user.\nWe again showcase both the code for ",(0,i.jsx)(n.code,{children:"Either"})," and ",(0,i.jsx)(n.code,{children:"Raise"})," based computation and see that both are almost the same."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"catch"})," DSL allows us to wrap foreign functions and capture any ",(0,i.jsx)(n.code,{children:"Throwable"})," or ",(0,i.jsx)(n.code,{children:"T: Throwable"})," that might be thrown. It automatically avoids capturing ",(0,i.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-core/arrow.core/-non-fatal.html",children:"fatal exceptions"})," such as ",(0,i.jsx)(n.code,{children:"OutOfMemoryError"}),", or Kotlin's ",(0,i.jsx)(n.code,{children:"CancellationException"}),".\nIt requires two functions, or lambdas, as arguments: One for wrapping our ",(0,i.jsx)(n.em,{children:"foreign code"})," and another for resolving the captured ",(0,i.jsx)(n.code,{children:"Throwable"})," or ",(0,i.jsx)(n.code,{children:"T : Throwable"}),". In this case, instead of providing a fallback value, we ",(0,i.jsx)(n.code,{children:"raise"})," a ",(0,i.jsx)(n.em,{children:"logical failure"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["We expect ",(0,i.jsx)(n.code,{children:"SQLException"})," since we only ",(0,i.jsx)(n.em,{children:"expect"})," it to be thrown and rethrow any other ",(0,i.jsx)(n.code,{children:"Throwable"}),".\nWe can then operate on a captured ",(0,i.jsx)(n.code,{children:"SQLException"})," to check if our insertion failed with a unique violation, and, in that case, to turn it into a ",(0,i.jsx)(n.code,{children:"UserAlreadyExists"})," ",(0,i.jsx)(n.em,{children:"logical failure"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"data class UserAlreadyExists(val username: String, val email: String)\n\n// computation context approach\nsuspend fun Raise<UserAlreadyExists>.insertUser(username: String, email: String): Long =\n  catch({\n    UsersQueries.insert(username, email)\n  }) { e: SQLException ->\n    if (e.isUniqueViolation()) raise(UserAlreadyExists(username, email))\n    else throw e\n  }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Since we also have ",(0,i.jsx)(n.code,{children:"raise"})," available inside ",(0,i.jsx)(n.code,{children:"either"}),", we can also write the same code using ",(0,i.jsx)(n.code,{children:"either"})," or execute this function inside an ",(0,i.jsx)(n.code,{children:"either"})," block as shown above.\nThis behavior is also available as top-level functionality on ",(0,i.jsx)(n.code,{children:"Either"})," itself if you prefer to use that. It can be achieved using ",(0,i.jsx)(n.code,{children:"catchOrThrow"})," instead of ",(0,i.jsx)(n.code,{children:"catch"})," and ",(0,i.jsx)(n.code,{children:"mapLeft"})," to transform ",(0,i.jsx)(n.code,{children:"SQLException"})," into ",(0,i.jsx)(n.code,{children:"UserAlreadyExists"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"// wrapper type approach\nsuspend fun insertUser(username: String, email: String): Either<UserAlreadyExists, Long> =\n  Either.catchOrThrow<SQLException, Long> {\n    UsersQueries.insert(username, email)\n  }.mapLeft { e ->\n    if (e.isUniqueViolation()) UserAlreadyExists(username, email)\n    else throw e\n  }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This pattern allows us to turn exceptions we want to track into ",(0,i.jsx)(n.em,{children:"typed errors"}),", and things that are ",(0,i.jsx)(n.strong,{children:"truly"})," exceptional remain exceptional."]}),"\n",(0,i.jsx)(n.h2,{id:"accumulating-errors",children:"Accumulating errors"}),"\n",(0,i.jsxs)(n.p,{children:["All the behavior above works similarly to ",(0,i.jsx)(n.code,{children:"Throwable"}),", but in a typed manner. This means that if we encounter a typed error or ",(0,i.jsx)(n.em,{children:"logical failure"}),", that error is propagated, and we can't continue with the computation and ",(0,i.jsx)(n.em,{children:"short-circuit"}),".\nWhen we need to work with collections, or ",(0,i.jsx)(n.code,{children:"Iterable"}),", we often want to accumulate all the errors and not short-circuit. Let's take a look at how we can do this."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"data class NotEven(val i: Int)\n\n// computation context approach\nfun Raise<NotEven>.isEven(i: Int): Int =\n  i.also { ensure(i % 2 == 0) { NotEven(i) } }\n\n// wrapper type approach\nfun isEven2(i: Int): Either<NotEven, Int> =\n  either { isEven(i) }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["First, we define two functions that return a typed error if the value is not even.\nIf we want to accumulate all the errors, we can use ",(0,i.jsx)(n.code,{children:"mapOrAccumulate"})," on ",(0,i.jsx)(n.code,{children:"Iterable"})," to get all the errors, and doing so for ",(0,i.jsx)(n.code,{children:"(0..10)"})," should return the following ",(0,i.jsx)(n.code,{children:"errors"}),"."]}),"\n",(0,i.jsx)(n.admonition,{title:"Non-empty lists",type:"info",children:(0,i.jsxs)(n.p,{children:["Since you might potentially have more than one failure, the error type in ",(0,i.jsx)(n.code,{children:"Either"})," must be some sort of list.\nHowever, we know that if we are not in the happy path, then ",(0,i.jsx)(n.em,{children:"at least one"})," error must have occurred.\nArrow makes this fact explicit by making the return type of ",(0,i.jsx)(n.code,{children:"mapOrAccumulate"})," a ",(0,i.jsx)(n.code,{children:"NonEmptyList"}),", or ",(0,i.jsx)(n.code,{children:"Nel"})," for short."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val errors = nonEmptyListOf(NotEven(1), NotEven(3), NotEven(5), NotEven(7), NotEven(9)).left()\n\nfun example() {\n  // computation context approach\n  (1..10).mapOrAccumulate { isEven(it) } shouldBe errors\n  // wrapper type approach\n  (1..10).mapOrAccumulate { isEven2(it).bind() } shouldBe errors\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can also provide custom logic to accumulate the errors, typically when we have custom types.\nBelow, instead of ",(0,i.jsx)(n.code,{children:"NonEmptyList<NotEven>"}),", we have a ",(0,i.jsx)(n.code,{children:"MyError"})," type that builds a String with all the error messages.\nSo we again define two functions that return a typed error if the value is not even."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'data class MyError(val message: String)\n\n// computation context approach\nfun Raise<MyError>.isEven(i: Int): Int =\n  ensureNotNull(i.takeIf { i % 2 == 0 }) { MyError("$i is not even") }\n\n// wrapper type approach\nfun isEven2(i: Int): Either<MyError, Int> =\n  either { isEven(i) }\n'})}),"\n",(0,i.jsx)(n.p,{children:"And we write a small function that combines two values of our typed error into one, appending the error messages."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'operator fun MyError.plus(second: MyError): MyError =\n  MyError(message + ", ${second.message}")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["We can then simply pass this function to the ",(0,i.jsx)(n.code,{children:"mapOrAccumulate"})," function, and it will accumulate all the errors into a single ",(0,i.jsx)(n.code,{children:"MyError"})," value using our provided function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val error = MyError("1 is not even, 3 is not even, 5 is not even, 7 is not even, 9 is not even").left()\n\nfun example() {\n  // computation context approach\n  (1..10).mapOrAccumulate(MyError::plus) { isEven(it) } shouldBe error\n  // wrapper type approach\n  (1..10).mapOrAccumulate(MyError::plus) { isEven2(it).bind() } shouldBe error\n}\n'})}),"\n",(0,i.jsxs)(n.admonition,{title:"Accumulating errors but not values",type:"tip",children:[(0,i.jsxs)(n.p,{children:["If you need to execute a computation that may ",(0,i.jsx)(n.code,{children:"raise"})," errors over all the elements of an iterable or sequence, but without storing the resulting values, ",(0,i.jsx)(n.code,{children:"forEachAccumulating"})," is your tool of choice. The relation between ",(0,i.jsx)(n.code,{children:"mapOrAccumulate"})," and ",(0,i.jsx)(n.code,{children:"forEachAccumulating"})," is similar to that of ",(0,i.jsx)(n.code,{children:"map"})," and ",(0,i.jsx)(n.code,{children:"forEach"})," in Kotlin's standard library."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'fun example() = either {\n  forEachAccumulating(1 .. 10) { i ->\n    ensure(i % 2 == 0) { "$i is not even" }\n  }\n}\n'})})]}),"\n",(0,i.jsx)(n.h3,{id:"accumulating-different-computations",children:"Accumulating different computations"}),"\n",(0,i.jsxs)(n.p,{children:["In the example above we are providing one single function to operate on a sequence of elements.\nAnother important and related scenario is accumulating different errors, but each of them coming from different computations.\nFor example, you need to perform validation over the different fields of a form, and accumulate the errors, but each field has different constraints.\nArrow supports two different styles for this task: using ",(0,i.jsx)(n.code,{children:"zipOrAccumulate"}),", and using the ",(0,i.jsx)(n.code,{children:"accumulate"})," scope."]}),"\n",(0,i.jsx)(n.p,{children:"As a guiding example, let's consider information about a user, where the name shouldn't be empty and the age should be non-negative."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"data class User(val name: String, val age: Int)\n"})}),"\n",(0,i.jsx)(n.p,{children:"It's customary to define the different problems that may arise from validation as a sealed interface:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"sealed interface UserProblem {\n  object EmptyName: UserProblem\n  data class NegativeAge(val age: Int): UserProblem\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's define validation as a ",(0,i.jsx)(n.em,{children:"smart constructor"}),", that is, by creating a function which looks like the ",(0,i.jsx)(n.code,{children:"User"})," constructor, but performs additional checks."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"data class User private constructor(val name: String, val age: Int) {\n  companion object {\n    operator fun invoke(name: String, age: Int): Either<UserProblem, User> = either {\n      ensure(name.isNotEmpty()) { UserProblem.EmptyName }\n      ensure(age >= 0) { UserProblem.NegativeAge(age) }\n      User(name, age)\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Alas, that implementation short-circuits after encountering the first error. We can see this if we try to validate a ",(0,i.jsx)(n.code,{children:"User"})," with both an empty name and a wrong age."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'fun example() {\n  User("", -1) shouldBe Left(UserProblem.EmptyName)\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["If you want to gather as many validation problems as possible, you need to switch to ",(0,i.jsx)(n.em,{children:"accumulation"}),", as done above with ",(0,i.jsx)(n.code,{children:"mapOrAccumulate"}),".\nBut in this case we want to run independent validations of a different type, each for each field comprising the value."]}),"\n",(0,i.jsxs)(n.p,{children:["The first approach is to use ",(0,i.jsx)(n.code,{children:"zipOrAccumulate"}),".\nIn that case the first arguments define the different independent validations, often as a block of code.\nIf all those validations succeed, that is, when no problem was ",(0,i.jsx)(n.code,{children:"raise"}),"d during execution of any of them,\nthen the final block is executed. The result of independent validations is made available, in case they are required."]}),"\n",(0,i.jsxs)(n.p,{children:["The second approach involves delimiting a scope where accumulation should take place using ",(0,i.jsx)(n.code,{children:"accumulate"}),". That way we bring into scope variations of most functions described above, like ",(0,i.jsx)(n.code,{children:"ensureOrAccumulate"})," and ",(0,i.jsx)(n.code,{children:"bindOrAccumulate"}),". One important difference, though, is that when the computation returns a value, you must use ",(0,i.jsx)(n.code,{children:"by"})," (property delegation) instead of ",(0,i.jsx)(n.code,{children:"="})," to obtain the value."]}),"\n",(0,i.jsxs)(s.A,{groupId:"errorAccumulation",children:[(0,i.jsx)(a.A,{value:"errorAccumulationZip",label:"Using zipOrAccumulate",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"data class User private constructor(val name: String, val age: Int) {\n  companion object {\n    operator fun invoke(name: String, age: Int): Either<NonEmptyList<UserProblem>, User> = either {\n      zipOrAccumulate(\n        { ensure(name.isNotEmpty()) { UserProblem.EmptyName } },\n        { ensure(age >= 0) { UserProblem.NegativeAge(age) } }\n      ) { _, _ -> User(name, age) }\n    }\n  }\n}\n"})})}),(0,i.jsx)(a.A,{value:"errorAccumulationBlock",label:"Using accumulate block",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"data class User private constructor(val name: String, val age: Int) {\n  companion object {\n    operator fun invoke(name: String, age: Int): Either<NonEmptyList<UserProblem>, User> = either {\n      accumulate {\n        ensureOrAccumulate(name.isNotEmpty()) { UserProblem.EmptyName }\n        ensureOrAccumulate(age >= 0) { UserProblem.NegativeAge(age) }\n        User(name, age)\n      }\n    }\n  }\n}\n"})})})]}),"\n",(0,i.jsx)(n.p,{children:"With this change, the problems are correctly accumulated. Now we can notify the user about all the problems found in the form at once."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'fun example() {\n  User("", -1) shouldBe Left(nonEmptyListOf(UserProblem.EmptyName, UserProblem.NegativeAge(-1)))\n}\n'})}),"\n",(0,i.jsx)(n.admonition,{title:"Error accumulation and concurrency",type:"tip",children:(0,i.jsxs)(n.p,{children:["In addition to accumulating errors, you might want to perform each of the tasks within ",(0,i.jsx)(n.code,{children:"zipOrAccumulate"})," or ",(0,i.jsx)(n.code,{children:"mapOrAccumulate"})," in parallel.\nArrow Fx features ",(0,i.jsxs)(n.a,{href:"../../coroutines/parallel/#accumulating-typed-errors-in-parallel",children:[(0,i.jsx)(n.code,{children:"parZipOrAccumulate"})," and ",(0,i.jsx)(n.code,{children:"parMapOrAccumulate"})]})," to cover\nthose cases, in addition to ",(0,i.jsxs)(n.a,{href:"../../coroutines/parallel/#integration-with-typed-errors",children:[(0,i.jsx)(n.code,{children:"parZip"})," and ",(0,i.jsx)(n.code,{children:"parMap"})]}),"\nwhich follow a short-circuiting approach."]})}),"\n",(0,i.jsx)(n.h2,{id:"transforming-errors",children:"Transforming errors"}),"\n",(0,i.jsxs)(n.p,{children:["We call this approach ",(0,i.jsx)(n.em,{children:"typed"})," errors because at every point the signatures state which is the type of errors that might be raised from some computation. This type is checked when ",(0,i.jsx)(n.code,{children:".bind"}),"ed, which means that you cannot directly consume computation with a given error type within a block with a different one. The solution is to ",(0,i.jsx)(n.em,{children:"transform"})," the error, which is achieved using ",(0,i.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-core/arrow.core.raise/with-error.html",children:(0,i.jsx)(n.code,{children:"withError"})}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val stringError: Either<String, Boolean> = "problem".left()\n\nval intError: Either<Int, Boolean> = either {\n  // transform error String -> Int\n  withError({ it.length }) { \n    stringError.bind()\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["A very common pattern is using ",(0,i.jsx)(n.code,{children:"withError"}),' to "bridge" validation errors of sub-components into validation errors of the larger value.']}),"\n",(0,i.jsx)(n.admonition,{title:"Ignoring errors",type:"tip",children:(0,i.jsxs)(n.p,{children:["In the context of ",(0,i.jsxs)(n.a,{href:"../wrappers/nullable-and-option",children:["nullable and ",(0,i.jsx)(n.code,{children:"Option"})]}),' you often need to "forget" the error type if consuming more informative types like ',(0,i.jsx)(n.code,{children:"Either"}),". Although you can achieve this behavior using ",(0,i.jsx)(n.code,{children:"withError"}),", we provide a more declarative version called ",(0,i.jsx)(n.code,{children:"ignoreErrors"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"At this point we can summarize the advantages that typed errors offer over using exceptions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type Safety:"})," Typed errors allow the compiler to find type mismatches early, making it easier to catch bugs before they make it to production. However, with exceptions, the type information is lost, making it more difficult to detect errors at compile-time."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Predictability:"})," When using typed errors, the possible error conditions are explicitly listed in the type signature of a function. This makes it easier to understand the possible error conditions and write tests covering all error scenarios."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Composability:"})," Typed errors can be easily combined and propagated through a series of function calls, making writing modular, composable code easier. Whereas with exceptions, ensuring that errors are correctly propagated through a complex codebase can be difficult. Patterns like accumulation, which are at your fingertips when using typed errors, become quite convoluted using exceptions."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Performance:"})," Exception handling can significantly impact performance, especially in languages that don't have a dedicated stack for exceptions. Typed errors can be handled more efficiently as the compiler has more information about the possible error conditions."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In summary, typed errors provide a more structured, predictable, and efficient way of handling errors and make writing high-quality, maintainable code easier."}),"\n",(0,i.jsxs)(n.p,{children:["We can use the ",(0,i.jsx)(n.code,{children:"Either"})," type to represent a value that can either be a success or a failure, and we can use the ",(0,i.jsx)(n.code,{children:"Raise"})," DSL to raise typed errors without ",(0,i.jsx)(n.em,{children:"wrappers"}),".\nSince all these functions and builders are built on top of ",(0,i.jsx)(n.code,{children:"Raise"}),", they all seamlessly work together, and we can mix and match them as we please."]}),"\n",(0,i.jsxs)(n.p,{children:["If you have any questions or feedback, please reach out to us on ",(0,i.jsx)(n.a,{href:"https://slack-chats.kotlinlang.org/c/arrow",children:"Slack"})," or ",(0,i.jsx)(n.a,{href:"https://github.com/arrow-kt/arrow/issues",children:"Github"}),"."]})]})}function p(e={}){let{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},57250:function(e,n,r){r.d(n,{A:()=>o});var t=r(74848);r(96540);var i=r(34164);function o({children:e,hidden:n,className:r}){return(0,t.jsx)("div",{role:"tabpanel",className:(0,i.A)("tabItem_Ymn6",r),hidden:n,children:e})}},78010:function(e,n,r){r.d(n,{A:()=>w});var t=r(74848),i=r(96540),o=r(34164),s=r(88287),a=r(28584),l=r(56347),c=r(99989),d=r(96629),h=r(80618),u=r(41367);function p(e){return i.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function m({value:e,tabValues:n}){return n.some(n=>n.value===e)}var x=r(19863);function f({className:e,block:n,selectedValue:r,selectValue:i,tabValues:s}){let l=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),d=e=>{let n=e.currentTarget,t=s[l.indexOf(n)].value;t!==r&&(c(n),i(t))},h=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{let r=l.indexOf(e.currentTarget)+1;n=l[r]??l[0];break}case"ArrowLeft":{let r=l.indexOf(e.currentTarget)-1;n=l[r]??l[l.length-1]}}n?.focus()};return(0,t.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":n},e),children:s.map(({value:e,label:n,attributes:i})=>(0,t.jsx)("li",{role:"tab",tabIndex:r===e?0:-1,"aria-selected":r===e,ref:e=>{l.push(e)},onKeyDown:h,onClick:d,...i,className:(0,o.A)("tabs__item","tabItem_LNqP",i?.className,{"tabs__item--active":r===e}),children:n??e},e))})}function j({lazy:e,children:n,selectedValue:r}){let s=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){let e=s.find(e=>e.props.value===r);return e?(0,i.cloneElement)(e,{className:(0,o.A)("margin-top--md",e.props.className)}):null}return(0,t.jsx)("div",{className:"margin-top--md",children:s.map((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==r}))})}function g(e){let n=function(e){let n,{defaultValue:r,queryString:t=!1,groupId:o}=e,s=function(e){let{values:n,children:r}=e;return(0,i.useMemo)(()=>{let e=n??p(r).map(({props:{value:e,label:n,attributes:r,default:t}})=>({value:e,label:n,attributes:r,default:t})),t=(0,h.XI)(e,(e,n)=>e.value===n.value);if(t.length>0)throw Error(`Docusaurus error: Duplicate values "${t.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`);return e},[n,r])}(e),[a,x]=(0,i.useState)(()=>(function({defaultValue:e,tabValues:n}){if(0===n.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}let r=n.find(e=>e.default)??n[0];if(!r)throw Error("Unexpected error: 0 tabValues");return r.value})({defaultValue:r,tabValues:s})),[f,j]=function({queryString:e=!1,groupId:n}){let r=(0,l.W6)(),t=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,d.aZ)(t),(0,i.useCallback)(e=>{if(!t)return;let n=new URLSearchParams(r.location.search);n.set(t,e),r.replace({...r.location,search:n.toString()})},[t,r])]}({queryString:t,groupId:o}),[g,w]=function({groupId:e}){let n=e?`docusaurus.tab.${e}`:null,[r,t]=(0,u.Dv)(n);return[r,(0,i.useCallback)(e=>{n&&t.set(e)},[n,t])]}({groupId:o}),y=m({value:n=f??g,tabValues:s})?n:null;return(0,c.A)(()=>{y&&x(y)},[y]),{selectedValue:a,selectValue:(0,i.useCallback)(e=>{if(!m({value:e,tabValues:s}))throw Error(`Can't select invalid tab value=${e}`);x(e),j(e),w(e)},[j,w,s]),tabValues:s}}(e);return(0,t.jsxs)("div",{className:(0,o.A)(s.G.tabs.container,"tabs-container","tabList__CuJ"),children:[(0,t.jsx)(f,{...n,...e}),(0,t.jsx)(j,{...n,...e})]})}function w(e){let n=(0,x.A)();return(0,t.jsx)(g,{...e,children:p(e.children)},String(n))}},28453:function(e,n,r){r.d(n,{R:()=>s,x:()=>a});var t=r(96540);let i={},o=t.createContext(i);function s(e){let n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);