"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[9091],{71268:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=t(85893),r=t(11151);const i={sidebar_position:3},o="Transactional memory (STM)",s={id:"learn/coroutines/stm",title:"Transactional memory (STM)",description:"Software transactional memory, or STM, is an abstraction for concurrent state modification.",source:"@site/content/docs/learn/coroutines/stm.md",sourceDirName:"learn/coroutines",slug:"/learn/coroutines/stm",permalink:"/learn/coroutines/stm",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/coroutines/stm.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"learnSidebar",previous:{title:"Resource",permalink:"/learn/coroutines/resource-safety"},next:{title:"Concurrency primitives",permalink:"/learn/coroutines/concurrency-primitives"}},c={},l=[{value:"Reading and writing concurrent state",id:"reading-and-writing-concurrent-state",level:2},{value:"Other STM data structures",id:"other-stm-data-structures",level:3},{value:"Retries",id:"retries",level:2},{value:"Branching",id:"branching",level:3},{value:"Exceptions",id:"exceptions",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"transactional-memory-stm",children:"Transactional memory (STM)"}),"\n",(0,a.jsxs)(n.p,{children:["Software transactional memory, or STM, is an abstraction for concurrent state modification.\nWith STM, one can write code that concurrently accesses state, and that can easily be composed without\nexposing details of how it ensures safety guarantees.\nPrograms running within an STM transaction will neither deadlock nor have race-conditions.\nThe base building blocks of STM are ",(0,a.jsx)(n.code,{children:"TVar"}),"s and the primitives ",(0,a.jsx)(n.code,{children:"retry"}),", ",(0,a.jsx)(n.code,{children:"orElse"}),", and ",(0,a.jsx)(n.code,{children:"catch"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["The API of ",(0,a.jsx)(n.code,{children:"arrow-fx-stm"})," is based on Haskell's ",(0,a.jsx)(n.a,{href:"https://hackage.haskell.org/package/stm",children:(0,a.jsx)(n.code,{children:"stm"})})," package, and the implementation is based on the GHC implementation for fine-grained locks.\nFor further information, you can read ",(0,a.jsx)(n.a,{href:"https://www.microsoft.com/en-us/research/publication/composable-memory-transactions/",children:(0,a.jsx)(n.em,{children:"Composable memory transactions"})})," by Tim Harris, Simon Marlow, Simon Peyton Jones, and Maurice Herlihy."]})}),"\n",(0,a.jsx)(n.h2,{id:"reading-and-writing-concurrent-state",children:"Reading and writing concurrent state"}),"\n",(0,a.jsxs)(n.p,{children:["Those values that live under the umbrella of STM must be defined as ",(0,a.jsx)(n.code,{children:"TVar"}),"s\n(short for ",(0,a.jsx)(n.em,{children:"transactional variable"}),").\nYou can think of a ",(0,a.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-fx-stm/arrow.fx.stm/-t-var/index.html",children:(0,a.jsx)(n.code,{children:"TVar<A>"})})," as a variable holding values of type ",(0,a.jsx)(n.code,{children:"A"}),", but where\nconcurrent modification is protected.\n",(0,a.jsx)(n.code,{children:"TVar"}),"s are not the only transactional data structure (more on that later),\nbut in any case, to modify one, you need to be ",(0,a.jsx)(n.em,{children:"inside"})," the\nSTM context. This is achieved either by defining our\nfunctions with ",(0,a.jsx)(n.code,{children:"STM"})," as the receiver, or using ",(0,a.jsx)(n.code,{children:"stm"})," to create lambda functions\nwith such a receiver."]}),"\n",(0,a.jsxs)(n.p,{children:["By itself, a function using ",(0,a.jsx)(n.code,{children:"STM"})," as a receiver does ",(0,a.jsx)(n.em,{children:"not"})," perform any computations.\nWe say it's just a ",(0,a.jsx)(n.em,{children:"description"})," of a transaction. Running a transaction is then\ndone using ",(0,a.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-fx-stm/arrow.fx.stm/atomically.html",children:(0,a.jsx)(n.code,{children:"atomically"})}),"."]}),"\n",(0,a.jsx)(n.p,{children:"The example below shows a banking service moving money from one account to another with STM.\nShould the first account not have enough money, we throw an exception. This code is guaranteed never to deadlock and to never\nproduce an invalid state by committing after the read state has changed concurrently."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'import arrow.fx.stm.atomically\nimport arrow.fx.stm.TVar\nimport arrow.fx.stm.STM\n\nfun STM.transfer(from: TVar<Int>, to: TVar<Int>, amount: Int): Unit {\n  withdraw(from, amount)\n  deposit(to, amount)\n}\n\nfun STM.deposit(acc: TVar<Int>, amount: Int): Unit {\n  val current = acc.read()\n  acc.write(current + amount)\n  // or the shorthand acc.modify { it + amount }\n}\n\nfun STM.withdraw(acc: TVar<Int>, amount: Int): Unit {\n  val current = acc.read()\n  require(current - amount >= 0) { "Not enough money in the account!" }\n  acc.write(current - amount)\n}\n\nsuspend fun example() {\n  val acc1 = TVar.new(500)\n  val acc2 = TVar.new(300)\n  // check initial balances\n  acc1.unsafeRead() shouldBe 500\n  acc2.unsafeRead() shouldBe 300\n  // perform transaction\n  atomically { transfer(acc1, acc2, 50) }\n  // check final balances\n  acc1.unsafeRead() shouldBe 450\n  acc2.unsafeRead() shouldBe 350\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["One additional guarantee of STM is that the ",(0,a.jsx)(n.em,{children:"whole"})," transaction is executed\natomically. That means we can modify several ",(0,a.jsx)(n.code,{children:"TVar"}),"s in one transaction,\nand we'll never observe an intermediate state."]}),"\n",(0,a.jsx)(n.h3,{id:"other-stm-data-structures",children:"Other STM data structures"}),"\n",(0,a.jsxs)(n.p,{children:["The following types are built upon ",(0,a.jsx)(n.code,{children:"TVar"}),"s and provided out of the box with Arrow:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-fx-stm/arrow.fx.stm/-t-queue/index.html",children:(0,a.jsx)(n.code,{children:"TQueue"})}),": transactional mutable queue,"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-fx-stm/arrow.fx.stm/-t-m-var/index.html",children:(0,a.jsx)(n.code,{children:"TMVar"})}),": mutable transactional variable that may be empty,"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-fx-stm/arrow.fx.stm/-t-set/index.html",children:(0,a.jsx)(n.code,{children:"TSet"})}),", ",(0,a.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-fx-stm/arrow.fx.stm/-t-map/index.html",children:(0,a.jsx)(n.code,{children:"TMap"})}),": transactional ",(0,a.jsx)(n.code,{children:"Set"})," and ",(0,a.jsx)(n.code,{children:"Map"}),","]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-fx-stm/arrow.fx.stm/-t-array/index.html",children:(0,a.jsx)(n.code,{children:"TArray"})}),": array of ",(0,a.jsx)(n.code,{children:"TVar"}),"s,"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-fx-stm/arrow.fx.stm/-t-semaphore/index.html",children:(0,a.jsx)(n.code,{children:"TSemaphore"})}),": transactional semaphore."]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:['Note that, in most cases, using these data structures is much more efficient than\nwrapping their "regular" version in a ',(0,a.jsx)(n.code,{children:"TVar"}),". For example, a ",(0,a.jsx)(n.code,{children:"TSet<A>"})," performs\nbetter than a ",(0,a.jsx)(n.code,{children:"TVar<Set<A>>"}),' because the latter needs to "lock" the entire set\non modification, whereas the former knows that only the affected entries need\nto be taken into account.']})}),"\n",(0,a.jsx)(n.h2,{id:"retries",children:"Retries"}),"\n",(0,a.jsxs)(n.p,{children:["It is sometimes beneficial to manually abort the current transaction if an\ninvalid state has been reached. For example, a ",(0,a.jsx)(n.code,{children:"TQueue"})," had no elements to read.\nThe aborted transaction will automatically restart once any previously accessed\nvariable has changed."]}),"\n",(0,a.jsxs)(n.p,{children:["Here in this example, we've changed ",(0,a.jsx)(n.code,{children:"withdraw"})," to use ",(0,a.jsx)(n.code,{children:"retry"})," and thus wait until\nenough money is in the account, which after a few seconds happens to be the case."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun STM.transfer(from: TVar<Int>, to: TVar<Int>, amount: Int): Unit {\n  withdraw(from, amount)\n  deposit(to, amount)\n}\n\nfun STM.deposit(acc: TVar<Int>, amount: Int): Unit {\n  val current = acc.read()\n  acc.write(current + amount)\n  // or the shorthand acc.modify { it + amount }\n}\n\nfun STM.withdraw(acc: TVar<Int>, amount: Int): Unit {\n  val current = acc.read()\n  if (current - amount >= 0) acc.write(current - amount)\n  else retry()\n  // the two lines above could also be written\n  // check(current - amount >= 0)\n  // acc.write(it - amount)`\n}\n\nsuspend fun example() = coroutineScope {\n  val acc1 = TVar.new(0)\n  val acc2 = TVar.new(300)\n  // check initial balances\n  acc1.unsafeRead() shouldBe 0\n  acc2.unsafeRead() shouldBe 300\n  // simulate some time until the money is found\n  async {\n    delay(500)\n    atomically { acc1.write(100_000_000) }\n  }\n  // concurrently attempt the transaction\n  atomically {\n    transfer(acc1, acc2, 50)\n  }\n  // check final balances\n  acc1.unsafeRead() shouldBe (100_000_000 - 50)\n  acc2.unsafeRead() shouldBe 350\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"retry"})," can be used to implement a lot of complex transactions,\nand lies at the heart of the implementation of more complex transactional\ndata structured like ",(0,a.jsx)(n.code,{children:"TMVar"})," and ",(0,a.jsx)(n.code,{children:"TQueue"}),"."]}),"\n",(0,a.jsxs)(n.admonition,{type:"caution",children:[(0,a.jsxs)(n.p,{children:["A transaction that sees an invalid state (which includes reading a ",(0,a.jsx)(n.code,{children:"TVar"})," that has been changed concurrently) will restart and try again.\nThis usually means we rerun the function entirely. Therefore it is recommended to keep transactions small and never to use code that\nhas side effects inside."]}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Transactions may be aborted at any time, so accessing resources may never trigger finalizers,"}),"\n",(0,a.jsx)(n.li,{children:"Transactions may rerun an arbitrary amount of times before finishing, and thus all effects will rerun."}),"\n"]})]}),"\n",(0,a.jsx)(n.h3,{id:"branching",children:"Branching"}),"\n",(0,a.jsxs)(n.p,{children:["The counterpart to ",(0,a.jsx)(n.code,{children:"retry"})," is ",(0,a.jsx)(n.code,{children:"orElse"}),", which allows detecting if a branch\nhas called ",(0,a.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-fx-stm/arrow.fx.stm/-s-t-m/retry.html",children:"retry"})," and then use a fallback instead. If the fallback retries as\nwell, then the whole transaction retries."]}),"\n",(0,a.jsxs)(n.p,{children:["In the example below, we use ",(0,a.jsx)(n.code,{children:"orElse"})," to return ",(0,a.jsx)(n.code,{children:"null"})," whenever the ",(0,a.jsx)(n.code,{children:"check"}),"\nfails. By default, ",(0,a.jsx)(n.code,{children:"check"})," retries the transaction, hence the need for ",(0,a.jsx)(n.code,{children:"orElse"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun STM.transaction(v: TVar<Int>): Int? =\n  stm {\n    val result = v.read()\n    check(result in 0 .. 10)\n    result\n  } orElse { null }\n\nsuspend fun example() {\n  val v = TVar.new(100)\n  // check initial balance\n  v.unsafeRead() shouldBe 100\n  // value is outside the range, should fail\n  atomically { transaction(v) } shouldBe null\n  // value is outside the range, should succeed\n  atomically { v.write(5) }\n  atomically { transaction(v) } shouldBe 5\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"exceptions",children:"Exceptions"}),"\n",(0,a.jsxs)(n.p,{children:["Throwing inside STM will let the exception bubble up to either a ",(0,a.jsx)(n.code,{children:"catch"})," handler\nor to ",(0,a.jsx)(n.code,{children:"atomically"}),", which will rethrow it. Note that this ",(0,a.jsx)(n.code,{children:"catch"})," does ",(0,a.jsx)(n.strong,{children:"not"})," refer\nto the built-in exception one, but rather to the function of the same name in\nthe STM module."]}),"\n",(0,a.jsx)(n.admonition,{type:"danger",children:(0,a.jsxs)(n.p,{children:["Using ",(0,a.jsx)(n.code,{children:"try {...} catch (e: Exception) {...}"})," is not encouraged because any state change inside ",(0,a.jsx)(n.code,{children:"try"})," will not be undone when\nan exception occurs. The recommended way of catching exceptions is to use the ",(0,a.jsx)(n.code,{children:"catch"})," function, which properly rolls back the transaction."]})})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>o});var a=t(67294);const r={},i=a.createContext(r);function o(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);