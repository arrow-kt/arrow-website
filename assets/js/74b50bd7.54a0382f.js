"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([["5513"],{83821:function(e,n,t){t.r(n),t.d(n,{metadata:()=>i,default:()=>u,frontMatter:()=>o,contentTitle:()=>r,toc:()=>c,assets:()=>l});var i=JSON.parse('{"id":"ecosystem/analysis/mutability","title":"Mutability and loops","description":"Arrow Analysis supports mutability at the level of functions (but not yet at the level of classes). However, when you declare something with var, things get tricky. \u{1F47B}","source":"@site/content/docs/ecosystem/analysis/mutability.md","sourceDirName":"ecosystem/analysis","slug":"/ecosystem/analysis/mutability","permalink":"/ecosystem/analysis/mutability","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"ecosystemSidebar","previous":{"title":"Control operators","permalink":"/ecosystem/analysis/control"},"next":{"title":"Types and invariants","permalink":"/ecosystem/analysis/types"}}'),a=t(74848),s=t(28453);let o={sidebar_position:4},r="Mutability and loops",l={},c=[{value:"Loops",id:"loops",level:2}];function h(e){let n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"mutability-and-loops",children:"Mutability and loops"})}),"\n",(0,a.jsxs)(n.p,{children:["Arrow Analysis supports mutability at the level of functions (but not yet at the level of classes). However, when you declare something with ",(0,a.jsx)(n.code,{children:"var"}),", things get tricky. \u{1F47B}"]}),"\n",(0,a.jsxs)(n.p,{children:["When a local variable ",(0,a.jsx)(n.code,{children:"x"})," is immutable"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val x = COMPLICATED_THING\n"})}),"\n",(0,a.jsxs)(n.p,{children:["the check knows upfront that any usage of ",(0,a.jsx)(n.code,{children:"x"})," correspond to the same ",(0,a.jsx)(n.code,{children:"COMPLICATED_THING"}),", wherever it's used later on. However, if the declaration uses ",(0,a.jsx)(n.code,{children:"var"}),", at the point in which we use ",(0,a.jsx)(n.code,{children:"x"})," the value inside of it may be completely different from the first one!"]}),"\n",(0,a.jsxs)(n.p,{children:["The way out of this problem is to promise Arrow Analysis that some condition over a mutable variable will ",(0,a.jsx)(n.em,{children:"always"})," be true for the entire computation:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"the check can base its reasoning on this promise,"}),"\n",(0,a.jsx)(n.li,{children:"but we need to check that you obey your promise every time you try to give a new value."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["We call this promise an ",(0,a.jsx)(n.strong,{children:"invariant"})," of the mutable variable."]}),"\n",(0,a.jsx)(n.p,{children:'As a consequence, if you do not declare an invariant, Arrow Analysis knows nothing about your variable. Here\'s an example which is "obviously" correct, but not accepted by the tool:'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.post\n\nfun usesMutability(x: Int): Int {\n  var z = 2\n  return z.post({ it > 0 }) { "greater than 0" }\n}\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-plain",children:"e: declaration `usesMutability` fails to satisfy the post-condition: ($result > 0)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Let's declare an invariant. We use the same syntax as post-conditions, but use the special function ",(0,a.jsx)(n.code,{children:"invariant"})," instead. Note that even though syntactically the invariant reads as part of the initial value, it really talks about the mutable variable being declared (",(0,a.jsx)(n.code,{children:"z"})," in this case)\n. After attaching this information to the variable, we are free to re-assign the variable, but we need to keep our promise."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.invariant\nimport arrow.analysis.post\n\nfun usesMutability(x: Int): Int {\n  var z = 2.invariant({ it > 0 }) { "invariant it > 0" }\n  z = 3\n  return z.post({ it > 0 }) { "greater than 0" }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Of course, if we don't keep our promise, Arrow Analysis won't be happy."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.invariant\nimport arrow.analysis.post\n\nfun usesMutability(x: Int): Int {\n  var z = 2.invariant({ it > 0 }) { "invariant it > 0" }\n  z = 0 // 0 is not > 0\n  return z.post({ it > 0 }) { "greater than 0" }\n}\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-plain",children:"e: invariants are not satisfied in `z = 0`\n"})}),"\n",(0,a.jsx)(n.h2,{id:"loops",children:"Loops"}),"\n",(0,a.jsx)(n.p,{children:"One place in which mutability is hard to avoid is loops. Our recommendation is to think carefully about invariants for your mutable variables, because a good choice will determine what can be checked. Here's an example in which we compute the length of a list using a mutable integral variable:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.invariant\nimport arrow.analysis.post\n\nfun <A> List<A>.count(): Int {\n  var count = 0.invariant({ it >= 0 }) { "z >= 0" }\n  for (elt in this) { count = count + 1 }\n  return count.post({ it >= 0 }) { "result >= 0" }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["We are investigating ways to introduce additional information in the tool, like ",(0,a.jsx)(n.code,{children:"for"})," looping exactly many times as the ",(0,a.jsx)(n.code,{children:"size"})," of the list."]})]})}function u(e={}){let{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},28453:function(e,n,t){t.d(n,{R:()=>o,x:()=>r});var i=t(96540);let a={},s=i.createContext(a);function o(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);