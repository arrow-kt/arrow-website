"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[2477],{87564:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>d});var s=l(85893),i=l(11151);const t={id:"nullable-and-option",title:"Why nullable types & Option?",description:"Difference between nullable types and Option, and when to use each.",sidebar_position:2},o="Why nullable types & Option?",r={id:"learn/typed-errors/nullable-and-option",title:"Why nullable types & Option?",description:"Difference between nullable types and Option, and when to use each.",source:"@site/content/docs/learn/typed-errors/nullable-and-option.md",sourceDirName:"learn/typed-errors",slug:"/learn/typed-errors/nullable-and-option",permalink:"/learn/typed-errors/nullable-and-option",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/typed-errors/nullable-and-option.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"nullable-and-option",title:"Why nullable types & Option?",description:"Difference between nullable types and Option, and when to use each.",sidebar_position:2},sidebar:"learnSidebar",previous:{title:"Working with typed errors",permalink:"/learn/typed-errors/working-with-typed-errors"},next:{title:"Either & Ior",permalink:"/learn/typed-errors/either-and-ior"}},a={},d=[{value:"Working with Option",id:"working-with-option",level:2},{value:"Extracting values from Option",id:"extracting-values-from-option",level:2},{value:"Option &amp; nullable DSL",id:"option--nullable-dsl",level:2},{value:"Inspecting <code>Option</code> values",id:"inspecting-option-values",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"why-nullable-types--option",children:"Why nullable types & Option?"}),"\n",(0,s.jsxs)(n.p,{children:["If you have worked with Java at all in the past, you have likely come across a ",(0,s.jsx)(n.code,{children:"NullPointerException"})," at some time (other languages will throw similarly named errors in such a case).\nUsually, this happens because some method returns ",(0,s.jsx)(n.code,{children:"null"})," when you weren't expecting it and, thus, isn't dealing with that possibility in your client code.\nA value of ",(0,s.jsx)(n.code,{children:"null"})," is often abused to represent an absent optional value. Kotlin already solves the problem by getting rid of ",(0,s.jsx)(n.code,{children:"null"})," values altogether and providing its own unique syntax ",(0,s.jsxs)(n.a,{href:"https://kotlinlang.org/docs/reference/null-safety.html",children:["Null-safety machinery based on ",(0,s.jsx)(n.code,{children:"?"})]}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Since Kotlin already has nullable types, why do we need Arrow's ",(0,s.jsx)(n.code,{children:"Option"})," type? There are only ",(0,s.jsx)(n.strong,{children:"a few"})," cases where you should use ",(0,s.jsx)(n.code,{children:"Option"})," instead of nullable types, and one is the ",(0,s.jsx)(n.em,{children:"nested nullability"})," problem. Let's see an example:"]}),"\n",(0,s.jsxs)(n.p,{children:["We write a small ",(0,s.jsx)(n.code,{children:"firstOrElse"})," function, which should return the list's first element or the default value if the list is ",(0,s.jsx)(n.strong,{children:"empty"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun <A> List<A>.firstOrElse(default: () -> A): A = firstOrNull() ?: default()\n\nfun example() {\n  emptyList<Int?>().firstOrElse { -1 } shouldBe -1\n  listOf(1, null, 3).firstOrElse { -1 } shouldBe 1\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Running this code with an ",(0,s.jsx)(n.code,{children:"emptyList"})," or a non-empty list seems to work as expected."]}),"\n",(0,s.jsx)(n.admonition,{title:"Unexpected result",type:"danger",children:(0,s.jsxs)(n.p,{children:["We get an unexpected result if we run this function with a list that contains ",(0,s.jsx)(n.code,{children:"null"})," as the ",(0,s.jsx)(n.strong,{children:"first"})," value."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun example() {\n  listOf(null, 2, 3).firstOrElse { -1 } shouldBe null\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now we're executing the function on a list that ",(0,s.jsx)(n.code,{children:"isNotEmpty"}),", so we expect it to return the first element of value ",(0,s.jsx)(n.code,{children:"null"}),".\nInstead, it returns ",(0,s.jsx)(n.code,{children:"-1"}),", the default value we specified in case the list ",(0,s.jsx)(n.code,{children:"isEmpty"}),"!"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'Exception in thread "main" java.lang.AssertionError: Expected null but actual was -1\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This is known as the ",(0,s.jsx)(n.em,{children:"nested nullability"})," problem, which can be solved using ",(0,s.jsx)(n.code,{children:"Option"})," instead of nullable types.\nSo let's analyze what is going wrong here and how we can fix it. When we look at the implementation of our ",(0,s.jsx)(n.code,{children:"firstOrElse"})," function,\nwe see that we're using ",(0,s.jsx)(n.code,{children:"firstOrNull"})," to get the first element of the list, and if that is ",(0,s.jsx)(n.code,{children:"null"}),", we return the default value."]}),"\n",(0,s.jsxs)(n.p,{children:["However, our generic parameter of ",(0,s.jsx)(n.code,{children:"Any"})," has an upperbound of ",(0,s.jsx)(n.code,{children:"Any?"}),", so we can pass in a list of nullable values.\nThis means that ",(0,s.jsx)(n.code,{children:"firstOrNull"})," can return ",(0,s.jsx)(n.code,{children:"null"})," if the first element of the list is ",(0,s.jsx)(n.code,{children:"null"}),", and we're not handling that case."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun <A> List<A>.firstOrElse(default: () -> A): A = firstOrNull() ?: default()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We can solve this in two ways. One is by restricting ",(0,s.jsx)(n.code,{children:"A"})," to have an upperbound of ",(0,s.jsx)(n.code,{children:"Any"})," instead,\nbut then we limit this function to only work with non-nullable types."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun <A : Any> List<A>.firstOrElse(default: () -> A): A = firstOrNull() ?: default()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Our previous examples of ",(0,s.jsx)(n.code,{children:"List<Int?>"})," would not even compile in that case, so this is not a good solution.\nInstead, we could use ",(0,s.jsx)(n.code,{children:"firstOrNone"}),", and then we can handle the case where the first element is ",(0,s.jsx)(n.code,{children:"null"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun <A> List<A>.firstOrElse(default: () -> A): A =\n  when(val option = firstOrNone()) {\n    is Some -> option.value\n    None -> default()\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If we rerun our previous examples, they all behave as expected since we can rely on ",(0,s.jsx)(n.code,{children:"None"})," to detect the case where the list is empty."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun example() {\n  emptyList<Int?>().firstOrElse { -1 } shouldBe -1\n  listOf(1, null, 3).firstOrElse { -1 } shouldBe 1\n  listOf(null, 2, 3).firstOrElse { -1 } shouldBe null\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes you might still want to use ",(0,s.jsx)(n.code,{children:"Option"})," instead of nullable types, even when you're not the author of these generic functions.\nSome libraries such as ",(0,s.jsx)(n.a,{href:"https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#nulls",children:"RxJava"})," and ",(0,s.jsx)(n.a,{href:"https://projectreactor.io/docs/core/release/reference/#null-safety",children:"Project Reactor"})," don't support nullable types in all their APIs.\nIf you still need to work with ",(0,s.jsx)(n.code,{children:"null"})," in combination with generic APIs that don't allow nullable types, you can use ",(0,s.jsx)(n.code,{children:"Option"})," to work around this problem."]}),"\n",(0,s.jsx)(n.admonition,{title:"Arrow DSL",type:"tip",children:(0,s.jsxs)(n.p,{children:["Arrow also provides special DSL syntax for ",(0,s.jsx)(n.em,{children:"nullable"})," & ",(0,s.jsx)(n.code,{children:"Option"})," types"]})}),"\n",(0,s.jsx)(n.h2,{id:"working-with-option",children:"Working with Option"}),"\n",(0,s.jsxs)(n.p,{children:["Arrow offers a special DSL syntax for all of its types and provides it for ",(0,s.jsx)(n.em,{children:"nullable types"}),". So let's review both below.\nBefore we get started, we need to know how to construct an ",(0,s.jsx)(n.code,{children:"Option"})," from a (nullable) value and vice versa."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Option<A>"})," is a container for an optional value of type ",(0,s.jsx)(n.code,{children:"A"}),". If the value of type ",(0,s.jsx)(n.code,{children:"A"})," is present, the ",(0,s.jsx)(n.code,{children:"Option<A>"})," is an instance of ",(0,s.jsx)(n.code,{children:"Some<A>"}),", containing the current value of type ",(0,s.jsx)(n.code,{children:"A"}),". If the value is absent, the ",(0,s.jsx)(n.code,{children:"Option<A>"})," is the object ",(0,s.jsx)(n.code,{children:"None"}),".\nAnd we have four constructors available to create an ",(0,s.jsx)(n.code,{children:"Option<A>"}),", their regular ",(0,s.jsx)(n.code,{children:"class"})," constructors, and two extension functions that return ",(0,s.jsx)(n.code,{children:"Option<A>"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'val some: Some<String> = Some("I am wrapped in something")\nval none: None = None\n\nval optionA: Option<String> = "I am wrapped in something".some()\nval optionB: Option<String> = none<String>()\n\nfun example() {\n  some shouldBe optionA\n  none shouldBe optionB\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Creating a ",(0,s.jsx)(n.code,{children:"Option<A>"})," from a nullable type ",(0,s.jsx)(n.code,{children:"A?"})," can be helpful when we need to lift nullable values into Option. This can be done with the ",(0,s.jsx)(n.code,{children:"Option.fromNullable"})," function or the ",(0,s.jsx)(n.code,{children:"A?.toOption()"})," extension function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'fun example() {\n  val some: Option<String> = Option.fromNullable("Nullable string")\n  val none: Option<String> = Option.fromNullable(null)\n  \n  "Nullable string".toOption() shouldBe some\n  null.toOption<String>() shouldBe none\n}\n'})}),"\n",(0,s.jsx)(n.admonition,{title:"Take care",type:"danger",children:(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"A?"})," is null, you should explicitly use the ",(0,s.jsx)(n.code,{children:"Some"})," or ",(0,s.jsx)(n.code,{children:".some()"})," constructor.\nOtherwise, you will get a ",(0,s.jsx)(n.code,{children:"None"})," instead of a ",(0,s.jsx)(n.code,{children:"Some"})," due to the ",(0,s.jsx)(n.em,{children:"nested nullable"})," problem."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun example() {\n  val some: Option<String?> = Some(null)\n  val none: Option<String?> = Option.fromNullable(null)\n  \n  some shouldBe null.some()\n  none shouldBe None\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"extracting-values-from-option",children:"Extracting values from Option"}),"\n",(0,s.jsxs)(n.p,{children:["So now that we know how to construct ",(0,s.jsx)(n.code,{children:"Option"})," values, how can we extract the value from it?\nThe easiest way to extract the ",(0,s.jsx)(n.code,{children:"String"})," value from the ",(0,s.jsx)(n.code,{children:"Option"})," would be to turn it into a ",(0,s.jsx)(n.em,{children:"nullable type"})," using ",(0,s.jsx)(n.code,{children:"getOrNull"})," and work with it as we would typically do with nullable types."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'fun example() {\n  Some("Found value").getOrNull() shouldBe "Found value"\n  None.getOrNull() shouldBe null\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Another way would be to provide a default value using ",(0,s.jsx)(n.code,{children:"getOrElse"}),". This is similar to the ",(0,s.jsx)(n.code,{children:"?:"})," operator in Kotlin, but instead of giving a default value for ",(0,s.jsx)(n.code,{children:"null"}),", we provide a default value for ",(0,s.jsx)(n.code,{children:"None"}),".\nIn the example below, we provide a default value of ",(0,s.jsx)(n.code,{children:'"No value"'}),"when the ",(0,s.jsx)(n.code,{children:"Option"})," is ",(0,s.jsx)(n.code,{children:"None"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'fun example() {\n  Some( "Found value").getOrElse { "No value" } shouldBe "Found value"\n  None.getOrElse { "No value" } shouldBe "No value"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"Option"})," is modeled as a ",(0,s.jsx)(n.code,{children:"sealed class"}),", we can use exhaustive ",(0,s.jsx)(n.code,{children:"when"})," statements to ",(0,s.jsx)(n.em,{children:"pattern match"})," on the possible cases."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'fun example() {\n  when(val value = 20.some()) {\n    is Some -> value.value shouldBe 20\n    None -> fail("$value should not be None")\n  }\n  \n  when(val value = none<Int>()) {\n    is Some -> fail("$value should not be Some")\n    None -> value shouldBe None\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"option--nullable-dsl",children:"Option & nullable DSL"}),"\n",(0,s.jsxs)(n.p,{children:["Now that we know how to construct ",(0,s.jsx)(n.code,{children:"Option"})," values and turn ",(0,s.jsx)(n.code,{children:"Option"})," back into regular (nullable) values,\nlet's see how we can use the ",(0,s.jsx)(n.code,{children:"Option"})," and nullable DSL to work with ",(0,s.jsx)(n.code,{children:"Option"})," & nullable values in an imperative way."]}),"\n",(0,s.jsxs)(n.p,{children:["When working with nullable types, we often need to check if the value is ",(0,s.jsx)(n.code,{children:"null"})," or not and then do something with it. We typically do that by using ",(0,s.jsx)(n.code,{children:"?.let { }"}),", but this quickly results in a lot of nested ",(0,s.jsx)(n.code,{children:"?.let { }"})," blocks.\nArrow offers ",(0,s.jsx)(n.code,{children:"bind()"})," and ",(0,s.jsx)(n.code,{children:"ensureNotNull"})," to get rid of this issue, so let's look at an example and some other interesting functions that Arrow provides in its DSL."]}),"\n",(0,s.jsxs)(n.p,{children:["Imagine we have a ",(0,s.jsx)(n.code,{children:"User"})," domain class that has ",(0,s.jsx)(n.em,{children:"nullable"})," email address, and we want to find a user by their id and then email them."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'@JvmInline value class UserId(val value: Int)\ndata class User(val id: UserId, val email: Email?)\n\nfun QueryParameters.userId(): UserId? = get("userId")?.toIntOrNull()?.let { UserId(it) }\nfun findUserById(id: UserId): User? = TODO()\nfun sendEmail(email: Email): SendResult? = TODO()\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun sendEmail(params: QueryParameters): SendResult? =\n  params.userId()?.let { userId ->\n    findUserById(userId)?.email?.let { email ->\n      sendEmail(email)\n    }\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["There is already quite some nesting going on and quite a lot of ",(0,s.jsx)(n.code,{children:"?"}),", but we can use ",(0,s.jsx)(n.code,{children:"bind()"})," and ",(0,s.jsx)(n.code,{children:"ensureNotNull"})," to get rid of the nesting."]}),"\n",(0,s.jsx)(n.admonition,{title:"Seamlessly mix",type:"tip",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"nullable"})," DSL can seamlessly be mixed with ",(0,s.jsx)(n.code,{children:"Option"})," by calling ",(0,s.jsx)(n.code,{children:"bind"})," on ",(0,s.jsx)(n.code,{children:"Option"})," values."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'@JvmInline value class UserId(val value: Int)\ndata class User(val id: UserId, val email: Email?)\n\nfun QueryParameters.userId(): UserId? = get("userId")?.toIntOrNull()?.let { UserId(it) }\nfun findUserById(id: UserId): Option<User> = TODO()\nfun sendEmail(email: Email): SendResult? = TODO()\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun sendEmail(params: QueryParameters): SendResult? = nullable {\n  val userId = ensureNotNull(params.userId())\n  val user = findUserById(userId).bind()\n  val email = user.email.bind()\n  sendEmail(email)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Similarly, this same pattern applies to ",(0,s.jsx)(n.code,{children:"Option"})," and other data types such as ",(0,s.jsx)(n.code,{children:"Either"}),", which is covered in other sections."]}),"\n",(0,s.jsx)(n.admonition,{title:"Seamlessly mix",type:"tip",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Option"})," DSL can seamlessly be mixed with ",(0,s.jsx)(n.em,{children:"nullable types"})," using ",(0,s.jsx)(n.code,{children:"ensureNotNull"}),"."]})}),"\n",(0,s.jsx)(n.admonition,{title:"Ignoring errors",type:"tip",children:(0,s.jsxs)(n.p,{children:['Sometimes you need to "forget" the error type if consuming more informative types like ',(0,s.jsx)(n.code,{children:"Either"}),". Wrap the ",(0,s.jsx)(n.code,{children:".bind()"})," in ",(0,s.jsx)(n.code,{children:"ignoreErrors"})," to make this explicit."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'@JvmInline value class UserId(val value: Int)\ndata class User(val id: UserId, val email: Email?)\n\nfun QueryParameters.userId(): Option<UserId> =\n  get("userId")?.toIntOrNull()?.let(::UserId).toOption()\n\nfun findUserById(id: UserId): Option<User> = TODO()\nfun sendEmail(email: Email): Option<SendResult> = TODO()\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun sendEmail(params: QueryParameters): Option<SendResult> = option {\n  val userId = params.userId().bind()\n  val user = findUserById(userId).bind()\n  val email = ensureNotNull(user.email)\n  sendEmail(email).bind()\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"inspecting-option-values",children:["Inspecting ",(0,s.jsx)(n.code,{children:"Option"})," values"]}),"\n",(0,s.jsxs)(n.p,{children:["Besides extracting the value from an ",(0,s.jsx)(n.code,{children:"Option"})," or sequencing nullable or ",(0,s.jsx)(n.code,{children:"Option"})," based logic, we often just need to ",(0,s.jsx)(n.em,{children:"inspect"})," the values inside it.\nWith ",(0,s.jsx)(n.em,{children:"nullable types"}),", we can simply use ",(0,s.jsx)(n.code,{children:"!= null"})," to inspect the value, but with ",(0,s.jsx)(n.code,{children:"Option"}),", we can check whether option has value or not using ",(0,s.jsx)(n.code,{children:"isSome"})," and ",(0,s.jsx)(n.code,{children:"isNone"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun example() {\n  Some(1).isSome() shouldBe true\n  none<Int>().isNone() shouldBe true\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The same function exists to check if ",(0,s.jsx)(n.code,{children:"Some"})," contains a value that passes a certain predicate. For ",(0,s.jsx)(n.em,{children:"nullable types"}),", we would use ",(0,s.jsx)(n.code,{children:"?.let { } ?: false"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun example() {\n  Some(2).isSome { it % 2 == 0 } shouldBe true\n  Some(1).isSome { it % 2 == 0 } shouldBe false\n  none<Int>().isSome { it % 2 == 0 } shouldBe false\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And, finally, sometimes we just need to execute a side effect if the value is present. For ",(0,s.jsx)(n.em,{children:"nullable types"}),", we would use ",(0,s.jsx)(n.code,{children:"?.also { }"})," or ",(0,s.jsx)(n.code,{children:"?.also { if(it != null) { } }"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'fun example() {\n  Some(1).onSome { println("I am here: $it") }\n  none<Int>().onNone { println("I am here") }\n  \n  none<Int>().onSome { println("I am not here: $it") }\n  Some(1).onNone { println("I am not here") }\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"I am here: 1\nI am here\n"})}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(n.p,{children:["Typically, when working in Kotlin, you should prefer working with ",(0,s.jsx)(n.em,{children:"nullable types"})," over ",(0,s.jsx)(n.code,{children:"Option"})," as it is more idiomatic.\nHowever, when writing generic code, we sometimes need ",(0,s.jsx)(n.code,{children:"Option"})," to avoid the ",(0,s.jsx)(n.em,{children:"nested nullability"})," issues, or when working with libraries that don't support ",(0,s.jsx)(n.em,{children:"null values"})," such as Project Reactor or RxJava."]}),"\n",(0,s.jsxs)(n.p,{children:["Arrow offers a neat DSL to work with ",(0,s.jsx)(n.code,{children:"Option"})," and ",(0,s.jsx)(n.em,{children:"nullable types"})," in an imperative way, which makes it easy to work with them both in a functional way.\nThey seamlessly integrate, so you can use whatever you need and prefer when you need it."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},11151:(e,n,l)=>{l.d(n,{Z:()=>r,a:()=>o});var s=l(67294);const i={},t=s.createContext(i);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);