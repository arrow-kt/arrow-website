"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([["6735"],{81441:function(e,n,t){t.r(n),t.d(n,{metadata:()=>a,default:()=>h,frontMatter:()=>s,contentTitle:()=>o,toc:()=>l,assets:()=>c});var a=JSON.parse('{"id":"learn/resilience/saga","title":"Saga","description":"Implement transactional behavior in distributed systems","source":"@site/content/docs/learn/resilience/saga.md","sourceDirName":"learn/resilience","slug":"/learn/resilience/saga","permalink":"/learn/resilience/saga","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"description":"Implement transactional behavior in distributed systems"},"sidebar":"learnSidebar","previous":{"title":"Circuit breaker","permalink":"/learn/resilience/circuitbreaker"},"next":{"title":"Immutable Data","permalink":"/learn/immutable-data/"}}'),r=t(74848),i=t(28453);let s={sidebar_position:4,description:"Implement transactional behavior in distributed systems"},o="Saga",c={},l=[];function d(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"saga",children:"Saga"})}),"\n",(0,r.jsxs)(n.p,{children:["In a distributed system, sometimes you need a concept similar to a ",(0,r.jsx)(n.em,{children:"transaction"}),"\nin a database. That is, several operations spanning different microservices\nmust succeed or fail as a unit; otherwise, we may end up in an inconsistent state.\nA ",(0,r.jsx)(n.strong,{children:"saga"})," implements this concept by providing for each action a corresponding\n",(0,r.jsx)(n.em,{children:"compensating"})," action, which is executed if any of the following steps fail.\nThe role of the compensating action is to undo any changes performed by the\naction, hence taking the system back to the state before the entire operation\nbegan its execution."]}),"\n",(0,r.jsx)(n.admonition,{title:"Additional context for this pattern",type:"info",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga",children:"Saga distributed transactions pattern"}),"\nin ",(0,r.jsx)(n.em,{children:"Cloud Design Patterns"}),"."]})}),"\n",(0,r.jsxs)(n.p,{children:["Arrow Resilience provides the ",(0,r.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/saga.html",children:(0,r.jsx)(n.code,{children:"saga"})}),"\nfunction, which creates a new scope where compensating actions can be declared\nalongside the action to perform. This is done by the ",(0,r.jsxs)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/-saga-scope/saga.html",children:[(0,r.jsx)(n.code,{children:"saga"})," function in\n",(0,r.jsx)(n.code,{children:"SagaScope"})]}),".\nThe resulting ",(0,r.jsx)(n.code,{children:"Saga<A>"})," doesn't perform any actions, though; you need to call\n",(0,r.jsx)(n.a,{href:"https://apidocs.arrow-kt.io/arrow-resilience/arrow.resilience/transact.html",children:(0,r.jsx)(n.code,{children:"transact"})}),"\nto keep the chain going."]}),"\n",(0,r.jsxs)(n.p,{children:["Let's use a small counter as an example, which we implement using the\n",(0,r.jsx)(n.a,{href:"../../coroutines/concurrency-primitives/#atomic",children:(0,r.jsx)(n.code,{children:"Atomic"})})," type provided\nby Arrow."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"import arrow.atomic.AtomicInt\nimport arrow.resilience.*\n\nval INITIAL_VALUE = 1\n\nobject Counter {\n  val value = AtomicInt(INITIAL_VALUE)\n\n  fun increment() {\n    value.incrementAndGet()\n  }\n\n  fun decrement() {\n    value.decrementAndGet()\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now we create a saga with a couple of operations. The first one increments the\ncounter, so the compensating action must be to decrement it. The second action\nsimply fails; we include no compensation because we know that part is never\nreached."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'val PROBLEM = Throwable("problem detected!")\n\n// describe the transaction\nval transaction: Saga<Int> = saga {\n  saga({\n    // action to perform\n    Counter.increment()\n  }) {\n    // inverse action for rolling back\n    Counter.decrement()\n  }\n  saga({\n    throw PROBLEM\n  }) {}\n  // final value of the saga\n  Counter.value.get()\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Executing the transaction gives the expected results:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The exception raised in the second step bubbles up to the caller of\n",(0,r.jsx)(n.code,{children:"transact"}),". In this case, we use ",(0,r.jsx)(n.code,{children:"Either.catch"})," to turn it into ",(0,r.jsx)(n.code,{children:"Either"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"The counter has been correctly decremented as part of the compensation\nprocess in the saga."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"suspend fun example() {\n  // perform the transaction\n  val result = Either.catch { transaction.transact() }\n  result shouldBe PROBLEM.left()\n  Counter.value.get() shouldBe INITIAL_VALUE\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the example above the failure of a step is signalled by throwing an\nexception. ",(0,r.jsx)(n.code,{children:"Saga"})," also integrates with Arrow's\n",(0,r.jsx)(n.a,{href:"https://arrow-kt.io/learn/typed-errors/working-with-typed-errors/",children:(0,r.jsx)(n.code,{children:"Raise"})}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"fun Raise<String>.transaction(): Saga<Int> = saga {\n  saga({ Counter.increment() }) { Counter.decrement() }\n  saga({ raise(PROBLEM) }) {}\n  Counter.value.get()\n}\n\nsuspend fun example() {\n  // perform the transaction\n  val result = either { transaction().transact() }\n  result shouldBe PROBLEM.left()\n  Counter.value.get() shouldBe INITIAL_VALUE\n}\n"})}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsxs)(n.mdxAdmonitionTitle,{children:["Saga and ",(0,r.jsx)(n.a,{href:"../../coroutines/resource-safety/",children:"Resource"})]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"SagaScope"})," has many parallels with ",(0,r.jsx)(n.code,{children:"ResourceScope"}),": both ensure that some\noperations are performed at a certain point, and ",(0,r.jsx)(n.code,{children:"saga"})," and ",(0,r.jsx)(n.code,{children:"install"}),' require\nan action that "undoes" something. The main difference is that ',(0,r.jsx)(n.code,{children:"ResourceScope"}),"\n",(0,r.jsx)(n.strong,{children:"always"})," runs the release actions, whereas ",(0,r.jsx)(n.code,{children:"SagaScope"})," only runs compensation\n",(0,r.jsx)(n.strong,{children:"if"})," the entire action fails."]})]}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsxs)(n.mdxAdmonitionTitle,{children:["Saga and ",(0,r.jsx)(n.a,{href:"../../coroutines/stm/",children:"STM"})]}),(0,r.jsxs)(n.p,{children:["If you need to perform several actions as a unit over ",(0,r.jsx)(n.strong,{children:"local"})," data,\n",(0,r.jsx)(n.a,{href:"../../coroutines/stm/",children:"Software Transactional Memory"})," is a better tool than\nSagas and Atomic references."]})]})]})}function h(e={}){let{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:function(e,n,t){t.d(n,{R:()=>s,x:()=>o});var a=t(96540);let r={},i=a.createContext(r);function s(e){let n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);