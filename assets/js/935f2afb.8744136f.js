"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"learnSidebar":[{"type":"link","label":"Overview","href":"/learn/overview","customProps":{"icon":"icon-docs.svg"},"docId":"learn/overview","unlisted":false},{"type":"category","label":"Quickstart","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-quickstart.svg","description":"Gradle or Maven, JVM or Multiplatform, Arrow fits in all your projects","overview":true},"items":[{"type":"link","label":"From other FP languages","href":"/learn/quickstart/from-fp","docId":"learn/quickstart/from-fp","unlisted":false},{"type":"link","label":"Serialization","href":"/learn/quickstart/serialization","docId":"learn/quickstart/serialization","unlisted":false},{"type":"link","label":"Compose and UIs","href":"/learn/quickstart/compose","docId":"learn/quickstart/compose","unlisted":false},{"type":"link","label":"Migration to Arrow 1.2.0","href":"/learn/quickstart/migration","docId":"learn/quickstart/migration","unlisted":false}],"href":"/learn/quickstart/"},{"type":"category","label":"Typed errors","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-typed-errors.svg","description":"Learn how to work with typed errors","overview":true},"items":[{"type":"link","label":"Working with typed errors","href":"/learn/typed-errors/working-with-typed-errors","docId":"learn/typed-errors/working-with-typed-errors","unlisted":false},{"type":"link","label":"Why nullable types & Option?","href":"/learn/typed-errors/nullable-and-option","docId":"learn/typed-errors/nullable-and-option","unlisted":false},{"type":"link","label":"Either & Ior","href":"/learn/typed-errors/either-and-ior","docId":"learn/typed-errors/either-and-ior","unlisted":false},{"type":"link","label":"Validation","href":"/learn/typed-errors/validation","docId":"learn/typed-errors/validation","unlisted":false},{"type":"link","label":"Creating your own error wrappers","href":"/learn/typed-errors/own-error-types","docId":"learn/typed-errors/own-error-types","unlisted":false}],"href":"/learn/typed-errors/"},{"type":"category","label":"Coroutines","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-coroutines.svg","description":"Concurrency and parallelism","overview":true},"items":[{"type":"link","label":"High-level concurrency","href":"/learn/coroutines/parallel","docId":"learn/coroutines/parallel","unlisted":false},{"type":"link","label":"Resource","href":"/learn/coroutines/resource-safety","docId":"learn/coroutines/resource-safety","unlisted":false},{"type":"link","label":"Transactional memory (STM)","href":"/learn/coroutines/stm","docId":"learn/coroutines/stm","unlisted":false},{"type":"link","label":"Concurrency primitives","href":"/learn/coroutines/concurrency-primitives","docId":"learn/coroutines/concurrency-primitives","unlisted":false}],"href":"/learn/coroutines/"},{"type":"category","label":"Resilience","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-resilience.svg","description":"Act in an organized way when failures occur","overview":true},"items":[{"type":"link","label":"Introduction","href":"/learn/resilience/intro","docId":"learn/resilience/intro","unlisted":false},{"type":"link","label":"Retry and repeat","href":"/learn/resilience/retry-and-repeat","docId":"learn/resilience/retry-and-repeat","unlisted":false},{"type":"link","label":"Circuit breaker","href":"/learn/resilience/circuitbreaker","docId":"learn/resilience/circuitbreaker","unlisted":false},{"type":"link","label":"Saga","href":"/learn/resilience/saga","docId":"learn/resilience/saga","unlisted":false}],"href":"/learn/resilience/"},{"type":"category","label":"Immutable data","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-immutable-data.svg","description":"Concise ways to handle immutable data","overview":true},"items":[{"type":"link","label":"Introduction","href":"/learn/immutable-data/intro","docId":"learn/immutable-data/intro","unlisted":false},{"type":"link","label":"Lenses","href":"/learn/immutable-data/lens","docId":"learn/immutable-data/lens","unlisted":false},{"type":"link","label":"Optionals","href":"/learn/immutable-data/optional","docId":"learn/immutable-data/optional","unlisted":false},{"type":"link","label":"Traversals","href":"/learn/immutable-data/traversal","docId":"learn/immutable-data/traversal","unlisted":false},{"type":"link","label":"Prisms & Isos","href":"/learn/immutable-data/prism-iso","docId":"learn/immutable-data/prism-iso","unlisted":false},{"type":"link","label":"Reflection","href":"/learn/immutable-data/reflection","docId":"learn/immutable-data/reflection","unlisted":false}],"href":"/learn/immutable-data/"},{"type":"category","label":"Collections and functions","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-generic-6.svg","description":"Utilities for more productive basics","overview":true},"items":[{"type":"link","label":"Non-empty collections","href":"/learn/collections-functions/non-empty","docId":"learn/collections-functions/non-empty","unlisted":false},{"type":"link","label":"Collectors","href":"/learn/collections-functions/collectors","docId":"learn/collections-functions/collectors","unlisted":false},{"type":"link","label":"Recursive functions","href":"/learn/collections-functions/recursive","docId":"learn/collections-functions/recursive","unlisted":false},{"type":"link","label":"Memoization","href":"/learn/collections-functions/memoize","docId":"learn/collections-functions/memoize","unlisted":false},{"type":"link","label":"Control over evaluation","href":"/learn/collections-functions/eval","docId":"learn/collections-functions/eval","unlisted":false},{"type":"link","label":"Utilities for functions","href":"/learn/collections-functions/utils","docId":"learn/collections-functions/utils","unlisted":false}],"href":"/learn/collections-functions/"},{"type":"category","label":"Design","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-design.svg","description":"Recipes for designing nice Kotlin code","overview":true},"items":[{"type":"link","label":"Domain modeling","href":"/learn/design/domain-modeling","docId":"learn/design/domain-modeling","unlisted":false},{"type":"link","label":"Effects and contexts","href":"/learn/design/effects-contexts","docId":"learn/design/effects-contexts","unlisted":false},{"type":"link","label":"Receivers vs. flatMap","href":"/learn/design/receivers-flatmap","docId":"learn/design/receivers-flatmap","unlisted":false},{"type":"link","label":"Why suspend over IO","href":"/learn/design/suspend-io","docId":"learn/design/suspend-io","unlisted":false},{"type":"link","label":"Example projects","href":"/learn/design/projects","docId":"learn/design/projects","unlisted":false}],"href":"/learn/design/"},{"type":"link","label":"Integrations","href":"/learn/integrations","customProps":{"description":"Playing nice with the rest of the ecosystem","icon":"icon-generic-5.svg","overview":true},"docId":"learn/integrations","unlisted":false},{"type":"link","label":"Summary","href":"/learn/summary","customProps":{"icon":"icon-tutorial.svg"},"docId":"learn/summary","unlisted":false}],"ecosystemSidebar":[{"type":"category","label":"SuspendApp","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-coroutines.svg","description":"Graceful shutdowns"},"items":[{"type":"link","label":"With Ktor","href":"/ecosystem/suspendapp/ktor","docId":"ecosystem/suspendapp/ktor","unlisted":false},{"type":"link","label":"With Kafka","href":"/ecosystem/suspendapp/kafka","docId":"ecosystem/suspendapp/kafka","unlisted":false}],"href":"/ecosystem/suspendapp/"},{"type":"category","label":"Analysis","collapsible":true,"collapsed":true,"customProps":{"icon":"arrow-analysis-icon.svg","description":"Arrow Analysis introduces new checks in your compilation pipeline, which warn about common mistakes like out of bounds indexing"},"items":[{"type":"link","label":"Quickstart","href":"/ecosystem/analysis/quickstart","customProps":{"icon":"icon-quickstart.svg"},"docId":"ecosystem/analysis/quickstart","unlisted":false},{"type":"link","label":"Pre and post-conditions","href":"/ecosystem/analysis/conditions","docId":"ecosystem/analysis/conditions","unlisted":false},{"type":"link","label":"Control operators","href":"/ecosystem/analysis/control","docId":"ecosystem/analysis/control","unlisted":false},{"type":"link","label":"Mutability and loops","href":"/ecosystem/analysis/mutability","docId":"ecosystem/analysis/mutability","unlisted":false},{"type":"link","label":"Types and invariants","href":"/ecosystem/analysis/types","docId":"ecosystem/analysis/types","unlisted":false},{"type":"link","label":"Fields and wrappers","href":"/ecosystem/analysis/wrappers","docId":"ecosystem/analysis/wrappers","unlisted":false},{"type":"link","label":"3rd-party libraries (Laws)","href":"/ecosystem/analysis/laws","docId":"ecosystem/analysis/laws","unlisted":false},{"type":"link","label":"Java support","href":"/ecosystem/analysis/java","docId":"ecosystem/analysis/java","unlisted":false},{"type":"link","label":"GitHub Actions / SARIF","href":"/ecosystem/analysis/sarif","customProps":{"icon":"icon-github.svg"},"docId":"ecosystem/analysis/sarif","unlisted":false}],"href":"/ecosystem/analysis/"}]},"docs":{"ecosystem/analysis/conditions":{"id":"ecosystem/analysis/conditions","title":"Pre and post-conditions","description":"In Quickstart we\'ve introduced the idea of pre and post-conditions of functions as promises that either the caller or the body of the function should obey. Here we go deeper in the topic, about how these conditions may look, how they compose, and which way they are checked.","sidebar":"ecosystemSidebar"},"ecosystem/analysis/control":{"id":"ecosystem/analysis/control","title":"Control operators","description":"When dealing with pre-conditions, the environment in which a call takes place is very important. You introduce new information in the environment every time you use a control operator like if or when. For example, the following is accepted by Arrow Analysis, when you manually checking whether the size of the list is enough for getin the right value:","sidebar":"ecosystemSidebar"},"ecosystem/analysis/index":{"id":"ecosystem/analysis/index","title":"Analysis","description":"{useCurrentSidebarCategory().customProps.description}","sidebar":"ecosystemSidebar"},"ecosystem/analysis/java":{"id":"ecosystem/analysis/java","title":"Java support","description":"This is still an alpha feature.","sidebar":"ecosystemSidebar"},"ecosystem/analysis/laws":{"id":"ecosystem/analysis/laws","title":"3rd-party libraries (Laws)","description":"Is a library you use not compiled with Arrow Analysis? I could tell you to open an issue in their repository and convince their authors, but this is not always possible. For those cases Arrow Analysis provides a way to declare pre- and postconditions separately from the implementation, using @Law annotations. In fact, this is the way we package the analysis information related to Kotlin\'s stdlib.","sidebar":"ecosystemSidebar"},"ecosystem/analysis/mutability":{"id":"ecosystem/analysis/mutability","title":"Mutability and loops","description":"Arrow Analysis supports mutability at the level of functions (but not yet at the level of classes). However, when you declare something with var, things get tricky. \ud83d\udc7b","sidebar":"ecosystemSidebar"},"ecosystem/analysis/quickstart":{"id":"ecosystem/analysis/quickstart","title":"Quickstart","description":"This Quickstart explains how to set up Arrow Analysis in your Gradle project, and how to use it to get further insight in your code, and to introduce additional checks in your own functions and classes.","sidebar":"ecosystemSidebar"},"ecosystem/analysis/sarif":{"id":"ecosystem/analysis/sarif","title":"GitHub Actions / SARIF","description":"This is still an alpha feature.","sidebar":"ecosystemSidebar"},"ecosystem/analysis/types":{"id":"ecosystem/analysis/types","title":"Types and invariants","description":"Classes and interfaces (which we shall collectively refer to as \\"types\\") play a crucial role in organizing data in Kotlin. Arrow Analysis builds upon this idea, giving users the ability to attach Boolean expressions related to the data contained in a class. We call those invariants of the type, since the tool enforces those expressions to be true throughout the whole program.","sidebar":"ecosystemSidebar"},"ecosystem/analysis/wrappers":{"id":"ecosystem/analysis/wrappers","title":"Fields and wrappers","description":"Arrow Analysis supports the addition of invariants to types, but what happens when you already have a type and want to add information relative to it? And when may that situation arise? There are two different features to keep more information: fields and wrapper types.","sidebar":"ecosystemSidebar"},"ecosystem/suspendapp/index":{"id":"ecosystem/suspendapp/index","title":"SuspendApp","description":"When building applications that require graceful shutdown it typically requires us to write a lot of platform-specific","sidebar":"ecosystemSidebar"},"ecosystem/suspendapp/kafka":{"id":"ecosystem/suspendapp/kafka","title":"With Kafka","description":"When streaming records from Kafka we need to commit (acknowledge) the offset of the records","sidebar":"ecosystemSidebar"},"ecosystem/suspendapp/ktor":{"id":"ecosystem/suspendapp/ktor","title":"With Ktor","description":"There are some cases where it is convenient to gracefully shutdown a Ktor server. Basically, it is about giving some","sidebar":"ecosystemSidebar"},"learn/collections-functions/collectors":{"id":"learn/collections-functions/collectors","title":"Collectors","description":"Better aggregation over sequences","sidebar":"learnSidebar"},"learn/collections-functions/eval":{"id":"learn/collections-functions/eval","title":"Control over evaluation","description":"Delaying computation and caching results","sidebar":"learnSidebar"},"learn/collections-functions/index":{"id":"learn/collections-functions/index","title":"Collections and functions","description":"{useCurrentSidebarCategory().customProps.description}","sidebar":"learnSidebar"},"learn/collections-functions/memoize":{"id":"learn/collections-functions/memoize","title":"Memoization","description":"Avoiding duplicate work for pure functions","sidebar":"learnSidebar"},"learn/collections-functions/non-empty":{"id":"learn/collections-functions/non-empty","title":"Non-empty collections","description":"Working with collections with at least one element","sidebar":"learnSidebar"},"learn/collections-functions/recursive":{"id":"learn/collections-functions/recursive","title":"Recursive functions","description":"Making functions stack-safe and efficient","sidebar":"learnSidebar"},"learn/collections-functions/utils":{"id":"learn/collections-functions/utils","title":"Utilities for functions","description":"Composition, partial application, and currying","sidebar":"learnSidebar"},"learn/coroutines/concurrency-primitives":{"id":"learn/coroutines/concurrency-primitives","title":"Concurrency primitives","description":"These types are not usually found in application code, but provide essential","sidebar":"learnSidebar"},"learn/coroutines/index":{"id":"learn/coroutines/index","title":"Coroutines","description":"{useCurrentSidebarCategory().customProps.description}","sidebar":"learnSidebar"},"learn/coroutines/parallel":{"id":"learn/coroutines/parallel","title":"High-level concurrency","description":"Coroutines are one of the","sidebar":"learnSidebar"},"learn/coroutines/resource-safety":{"id":"learn/coroutines/resource-safety","title":"Resource","description":"Allocation and release of resources is not easy, especially when","sidebar":"learnSidebar"},"learn/coroutines/stm":{"id":"learn/coroutines/stm","title":"Transactional memory (STM)","description":"Software transactional memory, or STM, is an abstraction for concurrent state modification.","sidebar":"learnSidebar"},"learn/design/domain-modeling":{"id":"learn/design/domain-modeling","title":"Domain modeling","description":"The goal of functional domain modeling is to describe your business domain as accurately as possible to achieve more type-safety, maximize the use of the compiler with our domain and, thus, prevent bugs and reduce unit testing. Additionally, it makes communicating about the domain easier since the domain is the touchpoint with the real world. Kotlin is a good fit for functional domain modeling. It offers us data class, sealed class, enum class, and value class. And we have Arrow, which provides some interesting generic data types such as Either and Ior.","sidebar":"learnSidebar"},"learn/design/effects-contexts":{"id":"learn/design/effects-contexts","title":"Effects and contexts","description":"How you model data is an essential part of the design of your software. The other important side is how you model your behaviors. Today, we will talk about how to simplify your code with effects, avoiding heavyweight dependency injection frameworks on the go.","sidebar":"learnSidebar"},"learn/design/index":{"id":"learn/design/index","title":"Design","description":"{useCurrentSidebarCategory().customProps.description}","sidebar":"learnSidebar"},"learn/design/projects":{"id":"learn/design/projects","title":"Example projects","description":"Bigger projects where the design guidelines are put into practice","sidebar":"learnSidebar"},"learn/design/receivers-flatmap":{"id":"learn/design/receivers-flatmap","title":"Receivers vs. flatMap","description":"The Arrow project promotes a particular style of Kotlin to achieve the composability of effects. Functional programming patterns inspire many concepts, but the implementation differs significantly from Haskell\'s or Scala\'s typical way of doing things (monads, IO, and transformers). This article aims to clarify how this style works in Kotlin, compare it to other sibling languages, and discuss the main limitations.","sidebar":"learnSidebar"},"learn/design/suspend-io":{"id":"learn/design/suspend-io","title":"Why suspend over IO","description":"Other functional ecosystems, Scala and Haskell among others,","sidebar":"learnSidebar"},"learn/immutable-data/index":{"id":"learn/immutable-data/index","title":"Immutable Data","description":"{useCurrentSidebarCategory().customProps.description}","sidebar":"learnSidebar"},"learn/immutable-data/intro":{"id":"learn/immutable-data/intro","title":"Introduction","description":"Data classes, sealed hierarchies, and above all, immutable data is","sidebar":"learnSidebar"},"learn/immutable-data/lens":{"id":"learn/immutable-data/lens","title":"Lenses","description":"Lenses are the most common type of optic you work with. This section discusses","sidebar":"learnSidebar"},"learn/immutable-data/optional":{"id":"learn/immutable-data/optional","title":"Optionals","description":"Optionals allow focusing on elements that may not be present. This includes","sidebar":"learnSidebar"},"learn/immutable-data/prism-iso":{"id":"learn/immutable-data/prism-iso","title":"Prisms & Isos","description":"Prisms extend the capabilities of optics from merely inspecting or modifying","sidebar":"learnSidebar"},"learn/immutable-data/reflection":{"id":"learn/immutable-data/reflection","title":"Reflection","description":"Although we strongly recommend generating optics using the DSL and @optics attribute, sometimes this is impossible. We provide the small utility package arrow-optics-reflect for those scenarios, which bridges Arrow Optics with Kotlin\'s reflection capabilities.","sidebar":"learnSidebar"},"learn/immutable-data/traversal":{"id":"learn/immutable-data/traversal","title":"Traversals","description":"The framework laid out by optics extends very nicely to values like lists, which","sidebar":"learnSidebar"},"learn/integrations":{"id":"learn/integrations","title":"Integrations","description":"Arrow comprises different libraries, each improving or extending one commonly-used library in the Kotlin ecosystem or a particular Kotlin language feature.","sidebar":"learnSidebar"},"learn/overview":{"id":"learn/overview","title":"Overview","description":"Arrow comprises different libraries, each improving or extending one commonly-used library in the Kotlin ecosystem or a particular Kotlin language feature.","sidebar":"learnSidebar"},"learn/quickstart/compose":{"id":"learn/quickstart/compose","title":"Compose and UIs","description":"Arrow provides several features which are very interesting when developing","sidebar":"learnSidebar"},"learn/quickstart/from-fp":{"id":"learn/quickstart/from-fp","title":"From other FP languages","description":"Arrow is heavily influenced by functional programming. If you\'re used to working","sidebar":"learnSidebar"},"learn/quickstart/index":{"id":"learn/quickstart/index","title":"Quickstart","description":"Arrow is composed of different libraries; simply select the ones","sidebar":"learnSidebar"},"learn/quickstart/migration":{"id":"learn/quickstart/migration","title":"Migration to Arrow 1.2.0","description":"Migration guide to upgrade to Arrow 1.2.0.","sidebar":"learnSidebar"},"learn/quickstart/serialization":{"id":"learn/quickstart/serialization","title":"Serialization","description":"How to (de)serialize Arrow Core types.","sidebar":"learnSidebar"},"learn/resilience/circuitbreaker":{"id":"learn/resilience/circuitbreaker","title":"Circuit breaker","description":"When a service is overloaded, additional interaction may only worsen its","sidebar":"learnSidebar"},"learn/resilience/index":{"id":"learn/resilience/index","title":"Resilience","description":"{useCurrentSidebarCategory().customProps.description}","sidebar":"learnSidebar"},"learn/resilience/intro":{"id":"learn/resilience/intro","title":"Introduction","description":"Most, if not all, of the systems we develop nowadays require the cooperation of","sidebar":"learnSidebar"},"learn/resilience/retry-and-repeat":{"id":"learn/resilience/retry-and-repeat","title":"Retry and repeat","description":"A common demand when working with actions is to retry or repeat them when","sidebar":"learnSidebar"},"learn/resilience/saga":{"id":"learn/resilience/saga","title":"Saga","description":"In a distributed system, sometimes you need a concept similar to a transaction","sidebar":"learnSidebar"},"learn/summary":{"id":"learn/summary","title":"Summary","description":"Summary","sidebar":"learnSidebar"},"learn/typed-errors/either-and-ior":{"id":"learn/typed-errors/either-and-ior","title":"Either & Ior","description":"Use cases for Either and Ior.","sidebar":"learnSidebar"},"learn/typed-errors/index":{"id":"learn/typed-errors/index","title":"Typed Errors","description":"{useCurrentSidebarCategory().customProps.description}","sidebar":"learnSidebar"},"learn/typed-errors/nullable-and-option":{"id":"learn/typed-errors/nullable-and-option","title":"Why nullable types & Option?","description":"Difference between nullable types and Option, and when to use each.","sidebar":"learnSidebar"},"learn/typed-errors/own-error-types":{"id":"learn/typed-errors/own-error-types","title":"Creating your own error wrappers","description":"Writing your own DSLs with Raise.","sidebar":"learnSidebar"},"learn/typed-errors/validation":{"id":"learn/typed-errors/validation","title":"Validation","description":"Worked out example of validation.","sidebar":"learnSidebar"},"learn/typed-errors/working-with-typed-errors":{"id":"learn/typed-errors/working-with-typed-errors","title":"Working with typed errors","description":"Working, recovering, and accumulating errors in a typed and concise way.","sidebar":"learnSidebar"}}}')}}]);