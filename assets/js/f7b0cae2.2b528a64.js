"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[5616],{75944:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var t=s(85893),o=s(11151);const i={title:"Effects and contexts",sidebar_position:2},a=void 0,r={id:"learn/design/effects-contexts",title:"Effects and contexts",description:"How you model data is an essential part of the design of your software. The other important side is how you model your behaviors. Today, we will talk about how to simplify your code with effects, avoiding heavyweight dependency injection frameworks on the go.",source:"@site/content/docs/learn/design/effects-contexts.md",sourceDirName:"learn/design",slug:"/learn/design/effects-contexts",permalink:"/learn/design/effects-contexts",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/design/effects-contexts.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Effects and contexts",sidebar_position:2},sidebar:"learnSidebar",previous:{title:"Domain modeling",permalink:"/learn/design/domain-modeling"},next:{title:"Receivers vs. flatMap",permalink:"/learn/design/receivers-flatmap"}},c={},l=[{value:"Dependencies as receivers",id:"dependencies-as-receivers",level:2},{value:"Injecting",id:"injecting",level:3},{value:"Always <code>suspend</code>",id:"always-suspend",level:3},{value:"More than one dependency",id:"more-than-one-dependency",level:2},{value:"Looking at the future",id:"looking-at-the-future",level:3},{value:"Contexts, effects, algebras",id:"contexts-effects-algebras",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components},{Head:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s,{children:(0,t.jsx)("link",{rel:"canonical",href:"https://www.47deg.com/blog/effects-contexts/"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.mdxAdmonitionTitle,{children:["This article was originally published in the ",(0,t.jsx)(n.a,{href:"https://www.47deg.com/blog/effects-contexts/",children:"47 Degrees blog"}),"."]})}),"\n",(0,t.jsxs)(n.p,{children:["How you model data is an essential part of the design of your software. The other important side is how you model your ",(0,t.jsx)(n.strong,{children:"behaviors"}),". Today, we will talk about how to simplify your code with effects, avoiding heavyweight dependency injection frameworks on the go."]}),"\n",(0,t.jsxs)(n.p,{children:["For every function you write, there's often some ",(0,t.jsx)(n.em,{children:"main"})," data you require and many other ancillary pieces, the ",(0,t.jsx)(n.em,{children:"context"}),". The typical example is a function to write some user information to the database: apart from the ",(0,t.jsx)(n.code,{children:"User"})," itself, you need a ",(0,t.jsx)(n.code,{children:"DatabaseConnection"}),", and maybe a way to ",(0,t.jsx)(n.code,{children:"log"})," potential issues. One possibility is to make everything a parameter, as follows."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'suspend fun User.saveInDb(conn: DatabaseConnection, logger: Logger) {\n  // prepare something\n  val result = conn.execute(update)\n  if (result.isFailure) logger.log("Big problem!")\n  // keep doing stuff\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This has an advantage: everything is ",(0,t.jsx)(n.strong,{children:"explicit"}),". You know precisely what you need to run this function. But there's a significant disadvantage too: everything is ",(0,t.jsx)(n.strong,{children:"explicit"}),". This means you must manually thread all this context in your functions. This also means a lot of boilerplate mudding your code and decreased ",(0,t.jsx)(n.em,{children:"maintainability"}),", as any change in the context required for some piece of code could create a domino effect in the rest of the code."]}),"\n",(0,t.jsxs)(n.p,{children:["This problem isn't new, of course; this is our old friend ",(0,t.jsx)(n.strong,{children:"dependency injection"})," (DI). In short, we want to have all the pieces we need, but don't want to thread them. The world has no shortage of DI frameworks, but almost all of them suffer from two disadvantages:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Dependencies are not reflected as part of the type, so they become part of a ",(0,t.jsx)(n.em,{children:"hidden"})," contract. We prefer explicitness for two reasons: (1) the rest of the team can discover the dependencies without looking in the function's body or how it's used, and (2) the compiler can perform some sanity checks for us."]}),"\n",(0,t.jsx)(n.li,{children:"Dependency injection does not use the same vocabulary as the rest of the code. We prefer ways to model this problem using language features instead of relying on magic, such as annotation processing."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"dependencies-as-receivers",children:"Dependencies as receivers"}),"\n",(0,t.jsxs)(n.p,{children:["The technique we want to present today takes a similar starting point to many others: define each of your dependencies as ",(0,t.jsx)(n.strong,{children:"interfaces"}),", which we usually call ",(0,t.jsx)(n.strong,{children:"effects"}),". Remember to mark all of your functions with ",(0,t.jsx)(n.code,{children:"suspend"}),". This allows for better control of both the effect and the runtime levels. In the case of a database connection, the interface can be as easy as a function returning it."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"interface Database {\n  suspend fun connection(): DatabaseConnection\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We always suggest exposing a more constrained API, though. In this case, instead of giving up all your control of the connection, we may provide a way to execute a query. This opens the door to ",(0,t.jsx)(n.code,{children:"execute"})," queueing the queries, for example."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"interface Database {\n  suspend fun <A> execute(q: Query<A>): Result<A>\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Regardless of your choice, the final step is to make this interface your ",(0,t.jsx)(n.em,{children:"receiver"})," type. Consequently, your ",(0,t.jsx)(n.code,{children:"User"})," must now appear as an argument, and you can directly call ",(0,t.jsx)(n.code,{children:"execute"}),", since it comes from the receiver ",(0,t.jsx)(n.code,{children:"Database"})," interface."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"suspend fun Database.saveUserInDb(user: User) {\n   // prepare something\n  val result = execute<User>(update)\n  // do more things\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This solution is explicit, as ",(0,t.jsx)(n.code,{children:"Database"})," appears as part of the type of ",(0,t.jsx)(n.code,{children:"saveUserInDb"}),", but avoids lots of boilerplate by using one Kotlin feature: receivers."]}),"\n",(0,t.jsx)(n.h3,{id:"injecting",children:"Injecting"}),"\n",(0,t.jsxs)(n.p,{children:["We can provide different incarnations of ",(0,t.jsx)(n.code,{children:"Database"})," by creating new objects implementing the interface above. The most straightforward is simply wrapping a ",(0,t.jsx)(n.code,{children:"DatabaseConnection"}),", as we were doing previously:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"class DatabaseFromConnection(conn: DatabaseConnection) : Database {\n  override suspend fun <A> execute(q: Query<A>): Result<A> =\n    conn.execute(q)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is not the only one: the execution may work in a pool of connections, or we could use an in-memory database for testing."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"class DatabaseFromPool(pool: ConnectionPool) : Database { ... }\nclass InMemoryDatabase() : Database { ... }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsxs)(n.a,{href:"https://kotlinlang.org/docs/scope-functions.html#with",children:["scope function ",(0,t.jsx)(n.code,{children:"with"})]})," is one of Kotlin's idiomatic ways to provide the value of a receiver. In most cases, we would use a block right after it, in which ",(0,t.jsx)(n.code,{children:"Database"})," is already made available."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'suspend fun example() {\n  val conn = openDatabaseConnection(connParams)\n  with(DatabaseFromConnection(conn)) {\n    saveUserInDb(User("Alex"))\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Some teams prefer to bundle the whole create the wrapping object + call ",(0,t.jsx)(n.code,{children:"with"})," into specialized ",(0,t.jsx)(n.strong,{children:"runner"})," functions. In that case, a clear pattern appears, in which the last parameter of such runner is a function that consumes that receiver."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'suspend fun <A> db(\n  params: ConnectionParams,\n  f: suspend Database.() -> A): A {\n  val conn = openDatabaseConnection(connParams)\n  return with(DatabaseFromConnection(conn), f)\n}\n\nsuspend fun example() {\n  db(connParams) { saveUserInDb(User("Alex")) }\n}\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"always-suspend",children:["Always ",(0,t.jsx)(n.code,{children:"suspend"})]}),"\n",(0,t.jsxs)(n.p,{children:["Strong statements require strong justifications, and we made one when we said that we ",(0,t.jsx)(n.em,{children:"always"})," mark the functions in our effects with the ",(0,t.jsx)(n.code,{children:"suspend"})," modifier. To understand the justification, we need to dive into the difference between ",(0,t.jsx)(n.em,{children:"describing"})," some computation and actually ",(0,t.jsx)(n.em,{children:"executing"})," it."]}),"\n",(0,t.jsxs)(n.p,{children:['Most of the time, we think of computation as happening "on the spot." Whenever the program arrives at my ',(0,t.jsx)(n.code,{children:'println("Hello!")'}),", it's going to execute it immediately. This model is simple; on the other hand, it's also problematic for a couple of reasons:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If the ",(0,t.jsx)(n.code,{children:"println"})," was in code we do not control, it's imposing on us a so-called ",(0,t.jsx)(n.em,{children:"side effect"})," that we cannot easily handle or get rid of."]}),"\n",(0,t.jsx)(n.li,{children:'Immediate executing the code denies us the possibility of modifying the parameters of this execution: maybe we wanted it to happen in a different thread. For example, because this is part of a graphical interface requiring some operations to occur in a specific "UI thread."'}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"suspend"})," modifier in Kotlin avoids these problems because such a function is ",(0,t.jsx)(n.em,{children:"not"}),' immediately executed. We can still compose those functions \u2014 in fact, Kotlin makes it so easy that it looks as if we were writing "normal" code \u2014. But ',(0,t.jsx)(n.code,{children:"suspend"})," functions themselves are only ",(0,t.jsx)(n.strong,{children:"descriptions"})," of what should be done. As a very simplistic approximation, think of a function ",(0,t.jsx)(n.code,{children:"() -> Int"}),": such a function is ",(0,t.jsx)(n.em,{children:"not yet"})," an integral number, but a recipe to obtain one."]}),"\n",(0,t.jsxs)(n.p,{children:["Once you've built the full description, you can ",(0,t.jsx)(n.strong,{children:"execute"})," it in many different ways. The simplest one is ",(0,t.jsx)(n.a,{href:"https://kotlinlang.org/docs/coroutines-basics.html",children:(0,t.jsx)(n.code,{children:"runBlocking"})}),". By marking all the functions in our effects as ",(0,t.jsx)(n.code,{children:"suspend"}),", we give freedom to both implementors of instances (who may choose to introduce additional threading, for example) and end users of the effects (who can ultimately decide how to spawn the initial computation)."]}),"\n",(0,t.jsxs)(n.p,{children:["If you squint your eyes a bit more, the type of ",(0,t.jsx)(n.code,{children:"runBlocking"})," actually looks suspiciously similar to the ",(0,t.jsx)(n.code,{children:"db"})," function defined above."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"fun <T> runBlocking(\n  context: CoroutineContext = EmptyCoroutineContext,\n  block: suspend CoroutineScope.() -> T): T\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Here, ",(0,t.jsx)(n.code,{children:"CoroutineScope"})," is the effect related to handling concurrency since it provides functions like ",(0,t.jsx)(n.code,{children:"cancel"})," or ",(0,t.jsx)(n.code,{children:"launch"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["This notion of separating description from the execution of code is by no means new. The Scala community has been playing with this idea for a long time, as witnessed by ",(0,t.jsx)(n.a,{href:"https://typelevel.org/cats-effect/",children:"Cats Effect"})," or ",(0,t.jsx)(n.a,{href:"https://zio.dev/",children:"ZIO"}),". Those libraries, however, cannot get to the same level of integration as Kotlin's built-in ",(0,t.jsx)(n.code,{children:"suspend"}),". For deeper insight into the use of ",(0,t.jsx)(n.code,{children:"suspend"})," as effects, check the ",(0,t.jsx)(n.em,{children:"Coroutines"})," section on this site."]}),"\n",(0,t.jsx)(n.h2,{id:"more-than-one-dependency",children:"More than one dependency"}),"\n",(0,t.jsxs)(n.p,{children:["I know what you're thinking: \"where's the ",(0,t.jsx)(n.code,{children:"Logger"}),"?\" Indeed, this technique requires a bit of refinement if your context comprises more than one effect. Let's start by defining the interface for logging:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"interface Log {\n  suspend fun log(message: String): Unit\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Here comes the trick: since contexts are interfaces, we can represent requiring both effects as a ",(0,t.jsx)(n.em,{children:"subclass"})," of both. For this, we bring in a not-so-well-known feature in Kotlin: ",(0,t.jsxs)(n.a,{href:"https://kotlinlang.org/docs/generics.html#upper-bounds",children:[(0,t.jsx)(n.code,{children:"where"})," clauses"]}),". Simply stated, ",(0,t.jsx)(n.code,{children:"where"})," clauses allow us to define more than one upper bound for a generic type. Let's see it in action:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'suspend fun <Ctx> Ctx.saveUserInDb(user: User)\n  where Ctx : Database, Ctx : Log {\n  // prepare something\n  val result = execute(update)\n  if (result.isFailure) log("Big problem!")\n  // keep doing stuff\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This pattern slowly grows on you, and at the end, you always define your functions using a ",(0,t.jsx)(n.strong,{children:"context receiver"})," ",(0,t.jsx)(n.code,{children:"Ctx"}),", whose effects you define later as upper bounds using ",(0,t.jsx)(n.code,{children:"where"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The main problem now is injecting the required instances of ",(0,t.jsx)(n.code,{children:"Database"})," and ",(0,t.jsx)(n.code,{children:"Log"})," so you can call ",(0,t.jsx)(n.code,{children:"saveUserInDb"}),". Unfortunately, the following does ",(0,t.jsx)(n.strong,{children:"not"})," work, even though we have those two instances at hand."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'suspend fun example() {\n  db(connParams) { stdoutLogger {\n    saveUserInDb(User("Alex"))\n  } }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The problem is that ",(0,t.jsx)(n.code,{children:"saveUserInDb"})," expects both to be packed into a single context object. We can work around it by creating an object on the spot and using delegation to refer to the previously-created instances."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'suspend fun example() {\n  db(connParams) { stdoutLogger {\n    with(object : Database by this@db, Logger as this@stdoutLogger) {\n      saveUserInDb(User("Alex"))\n    }\n  } }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The main restriction is that you can",(0,t.jsx)(n.strong,{children:"not"}),' inject two values whose type only depends on different type parameters due to JVM erasure. For example, imagine we had defined a generic "environment value" effect.']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"interface Environment<A> {\n  suspend fun get(): A\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Then we cannot define a context requiring ",(0,t.jsx)(n.code,{children:"Environment<ConnectionParams>"})," and ",(0,t.jsx)(n.code,{children:"Environment<AppConfig>"}),". In practice, this is not so problematic, as you often want to introduce more specialized interfaces and constrain your usage as outlined above for ",(0,t.jsx)(n.code,{children:"Database"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"looking-at-the-future",children:"Looking at the future"}),"\n",(0,t.jsxs)(n.p,{children:["The future looks quite bright for Kotliners in this respect. For a few versions now, the language includes ",(0,t.jsx)(n.a,{href:"https://github.com/Kotlin/KEEP/issues/259",children:(0,t.jsx)(n.em,{children:"context receivers"})}),", which would allow a cleaner design for what we are describing using subtyping. Using context receiver, we're able to state:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"context(Database, Logger)\nfun User.saveInDb() { ... }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["and inject the values by simply nesting the calls to ",(0,t.jsx)(n.code,{children:"db"})," and ",(0,t.jsx)(n.code,{children:"stdoutLogger"}),". Note that sometimes you need a more robust ",(0,t.jsx)(n.code,{children:"with"})," function than the one provided by the standard library, like ",(0,t.jsx)(n.a,{href:"https://gist.github.com/carbaj03/4ebd0f8da17c351d4235e1bedd9a36b5",children:"this one"}),", which admits subtyping within contexts."]}),"\n",(0,t.jsx)(n.h2,{id:"contexts-effects-algebras",children:"Contexts, effects, algebras"}),"\n",(0,t.jsxs)(n.p,{children:["Kotlin's documentation often discusses ",(0,t.jsx)(n.em,{children:"contexts"})," when describing this ",(0,t.jsx)(n.a,{href:"https://kotlinlang.org/docs/scope-functions.html#context-object-this-or-it",children:"usage of receivers"}),". We often use ",(0,t.jsx)(n.em,{children:"effect"}),' instead; this term is used in functional programming to describe everything done by a function outside data manipulation. Some usages in that respect are "effect handlers" in ',(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/freer-simple",children:"many"})," ",(0,t.jsx)(n.a,{href:"https://hackage.haskell.org/package/fused-effects",children:"Haskell"})," ",(0,t.jsx)(n.a,{href:"https://github.com/hasura/eff",children:"libraries"}),", or ",(0,t.jsx)(n.a,{href:"https://typelevel.org/cats-effect/",children:"Cats effect"})," in the Scala community."]}),"\n",(0,t.jsxs)(n.p,{children:["This technique is also related to ",(0,t.jsx)(n.a,{href:"https://www.baeldung.com/scala/tagless-final-pattern",children:"tagless final"})," as approached in Scala. In that case, we would refer to our ",(0,t.jsx)(n.code,{children:"Database"})," interface as an ",(0,t.jsx)(n.em,{children:"algebra"}),". There's an important distinction though: whereas tagless final uses heavyweight-type machinery available only in Scala (and Haskell), the technique in this blog post uses ",(0,t.jsx)(n.strong,{children:"simpler mechanisms"})," offered by Kotlin."]})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>r,a:()=>a});var t=s(67294);const o={},i=t.createContext(o);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);