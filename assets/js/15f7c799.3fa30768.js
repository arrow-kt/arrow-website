"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[7603],{31657:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var a=t(85893),s=t(11151);const i={sidebar_position:1},o="Introduction",r={id:"learn/immutable-data/intro",title:"Introduction",description:"Data classes, sealed hierarchies, and above all, immutable data is",source:"@site/content/docs/learn/immutable-data/intro.md",sourceDirName:"learn/immutable-data",slug:"/learn/immutable-data/intro",permalink:"/learn/immutable-data/intro",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/immutable-data/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"learnSidebar",previous:{title:"Immutable Data",permalink:"/learn/immutable-data/"},next:{title:"Lenses",permalink:"/learn/immutable-data/lens"}},l={},c=[{value:"Meet optics",id:"meet-optics",level:2},{value:"Many optics to rule them all",id:"many-optics-to-rule-them-all",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsxs)(n.p,{children:["Data classes, sealed hierarchies, and above all, ",(0,a.jsx)(n.strong,{children:"immutable data"})," is\nan excellent recipe for ",(0,a.jsx)(n.a,{href:"../../design/domain-modeling/",children:"domain modeling"}),". If we want\nto model a domain sharply, we often end up with a large amount of (nested)\nclasses, each of them representing a particular kind of object."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"data class Person(val name: String, val age: Int, val address: Address)\ndata class Address(val street: Street, val city: City)\ndata class Street(val name: String, val number: Int?)\ndata class City(val name: String, val country: String)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Alas, Kotlin doesn't provide great tooling out of the box to transform those\nvalues. Data classes have a built-in ",(0,a.jsx)(n.code,{children:"copy"})," method, but we need to repeat the\nname of the fields and perform iterated copies even if we only want to touch\none single field."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun Person.capitalizeCountry(): Person =\n  this.copy(\n    address = address.copy(\n      city = address.city.copy(\n        country = address.city.country.capitalize()\n      )\n    )\n  )\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["We often use the word ",(0,a.jsx)(n.em,{children:"transform"})," even though we are talking about immutable\ndata. In most cases, we refer to creating a ",(0,a.jsx)(n.em,{children:"copy"})," of the value where some of\nthe fields are ",(0,a.jsx)(n.em,{children:"modified"}),"."]})}),"\n",(0,a.jsx)(n.h2,{id:"meet-optics",children:"Meet optics"}),"\n",(0,a.jsxs)(n.p,{children:["Arrow provides a solution to this problem in the form of ",(0,a.jsx)(n.strong,{children:"optics"}),". Optics\nare values that represent access to a value (or values) inside a larger\nvalue. For example, we may have an optic focusing (that's the term we use)\non the ",(0,a.jsx)(n.code,{children:"address"})," field of a ",(0,a.jsx)(n.code,{children:"Person"}),". By combining different optics, we can\nconcentrate on nested elements, like the ",(0,a.jsx)(n.code,{children:"city"})," field within the ",(0,a.jsx)(n.code,{children:"address"})," field\nwithin a ",(0,a.jsx)(n.code,{children:"Person"}),". But code speaks louder than words, so let's see how the\nexample above improves using optics."]}),"\n",(0,a.jsxs)(n.p,{children:["The easiest way to start with Arrow Optics is through its compiler\nplug-in. After ",(0,a.jsx)(n.a,{href:"../../quickstart/#additional-setup-for-plug-ins",children:"adding it to your build"}),"\nyou just need to mark each class for which you want optics generated\nwith the ",(0,a.jsx)(n.code,{children:"@optics"})," annotation."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"import arrow.optics.*\n\n@optics data class Person(val name: String, val age: Int, val address: Address) {\n  companion object\n}\n@optics data class Address(val street: Street, val city: City) {\n  companion object\n}\n@optics data class Street(val name: String, val number: Int?) {\n  companion object\n}\n@optics data class City(val name: String, val country: String) {\n  companion object\n}\n"})}),"\n",(0,a.jsx)(n.admonition,{title:"Annoying companion object",type:"caution",children:(0,a.jsxs)(n.p,{children:["You need to have a ",(0,a.jsx)(n.code,{children:"companion object"})," declaration in each class, even if it's empty.\nThis is due to limitations in ",(0,a.jsx)(n.a,{href:"https://kotlinlang.org/docs/ksp-quickstart.html",children:"KSP"}),",\nthe compiler plug-in framework used to implement the Arrow Optics plug-in."]})}),"\n",(0,a.jsxs)(n.p,{children:["The plug-in generates optics for each field, available under the class name.\nFor example, ",(0,a.jsx)(n.code,{children:"Person.address"})," is the optic focusing on the ",(0,a.jsx)(n.code,{children:"address"})," field.\nFurthermore, you can create optics that focus on nested fields using the\nsame dot notation you're used to. In this case,\n",(0,a.jsx)(n.code,{children:"Person.address.city.country"})," represents the optic focusing precisely on\nthe field we want to transform. By using it, we can reimplement ",(0,a.jsx)(n.code,{children:"capitalizeCountry"}),"\nin two ways:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Optic-first"}),": the ",(0,a.jsx)(n.code,{children:"modify"})," operation of an optic takes an entire value\n(",(0,a.jsx)(n.code,{children:"this"})," in the example) and the transformation to apply to the focused element."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun Person.capitalizeCountryModify(): Person =\n  Person.address.city.country.modify(this) { it.capitalize() }\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Copy builder"}),": Arrow Optics provides an overload of ",(0,a.jsx)(n.code,{children:"copy"})," that, instead\nof named arguments, takes a block. Inside that block, you can use the syntax\n",(0,a.jsx)(n.code,{children:"optic transform operation"})," to modify a focused element."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun Person.capitalizeCountryCopy(): Person =\n  this.copy {\n    Person.address.city.country transform { it.capitalize() }\n  }\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"many-optics-to-rule-them-all",children:"Many optics to rule them all"}),"\n",(0,a.jsxs)(n.p,{children:["You may have noticed that we speak about optic",(0,a.jsx)(n.em,{children:"s"}),". In fact, there are a few\nimportant kinds that differ in the ",(0,a.jsx)(n.em,{children:"amount"})," of elements they\ncan potentially focus on. All the optics in the example above are ",(0,a.jsx)(n.strong,{children:"lenses"}),",\nwhich have precisely one focus. At the other end of the spectrum, we have\n",(0,a.jsx)(n.a,{href:"../traversal",children:(0,a.jsx)(n.strong,{children:"traversals"})}),", which focus on any amount of elements; they can be used to\nuniformly modify all the elements in a list, among other operations.\nOptics form a hierarchy that we can summarize in the diagram below."]}),"\n",(0,a.jsx)("center",{children:(0,a.jsx)(n.mermaid,{value:"graph TD;\n  traversal{{\"<a href='../traversal/'><b>Traversal</b></a> (0 .. \u221e)<br /><tt>getAll</tt> (return a list)<br /><tt>modify</tt> and <tt>set</tt>\"}};\n  optional{{\"<a href='../optional/'><b>Optional</b></a> (0 .. 1)<br /><tt>getOrNull</tt> (return a nullable)\"}};\n  lens{{\"<a href='../lens/'><b>Lens</b></a> (exactly 1)<br /><tt>get</tt>\"}};\n  prism{{\"<a href='../prism-iso/'><b>Prism<b></a><br /><tt>reverseGet</tt>\"}};\n  iso{{\"<a href='../prism-iso/#isomorphisms'><b>Iso<b></a>\"}}\n  traversal--\x3eoptional;\n  optional--\x3elens;\n  optional--\x3eprism;\n  lens--\x3eiso;\n  prism--\x3eiso;"})}),"\n",(0,a.jsxs)(n.p,{children:['The "main line" of optics is ',(0,a.jsx)(n.code,{children:"Traversal"})," \u2192 ",(0,a.jsx)(n.code,{children:"Optional"})," \u2192 ",(0,a.jsx)(n.code,{children:"Lens"}),", which differ\nonly in the number of elements they focus on. ",(0,a.jsxs)(n.a,{href:"../prism-iso",children:[(0,a.jsx)(n.code,{children:"Prism"})," and ",(0,a.jsx)(n.code,{children:"Iso"})]})," add a slight\ntwist: they allow not only modifying, but also ",(0,a.jsx)(n.em,{children:"creating"})," new values and\nmatching over them."]}),"\n",(0,a.jsxs)(n.admonition,{title:"Even more optics",type:"info",children:[(0,a.jsx)(n.p,{children:'Arrow 1.x features a larger hierarchy of optics because the operations of\n"getting" values and "modifying" them live in different interfaces.\nArrow 2.x simplifies the hierarchy to the five optics described in this section.'}),(0,a.jsx)(n.mermaid,{value:'graph TD;\n  subgraph <h4>only access</h4>\n    fold{{"<b>Fold</b> (0 .. \u221e)<br /><tt>getAll</tt>"}};\n    optionalFold{{"<b>OptionalFold</b> (0 .. 1)<br /><tt>getOrNull</tt>"}};\n    getter{{"<b>Getter</b> (exactly 1)<br /><tt>get</tt>"}};\n  end\n  setter{{"<b>Setter</b><br /><tt>modify</tt> and <tt>set</tt>"}};\n  subgraph <h4>Arrow 2.x</h4>\n    traversal{{"<b>Traversal</b>"}};\n    optional{{"<b>Optional</b>"}};\n    lens{{"<b>Lens</b>"}};\n    prism{{"<b>Prism<b><br /><tt>reverseGet</tt>"}};\n    iso{{"<b>Iso<b>"}}\n  end\n  fold--\x3etraversal;\n  setter--\x3etraversal;\n  fold--\x3eoptionalFold;\n  optionalFold--\x3egetter;\n  optionalFold--\x3eoptional;\n  traversal--\x3eoptional;\n  getter--\x3elens;\n  optional--\x3elens;\n  optional--\x3eprism;\n  lens--\x3eiso;\n  prism--\x3eiso;'})]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>o});var a=t(67294);const s={},i=a.createContext(s);function o(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);