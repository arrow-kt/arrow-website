"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([["1199"],{77767:function(e,t,n){n.r(t),n.d(t,{metadata:()=>r,default:()=>p,frontMatter:()=>s,contentTitle:()=>a,toc:()=>l,assets:()=>c});var r=JSON.parse('{"id":"learn/coroutines/suspendapp/kafka","title":"... with Kafka","description":"When streaming records from Kafka we need to commit (acknowledge) the offset of the records","source":"@site/content/docs/learn/coroutines/suspendapp/kafka.md","sourceDirName":"learn/coroutines/suspendapp","slug":"/learn/coroutines/suspendapp/kafka","permalink":"/learn/coroutines/suspendapp/kafka","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"... with Kafka","sidebar_position":3},"sidebar":"learnSidebar","previous":{"title":"... with Ktor","permalink":"/learn/coroutines/suspendapp/ktor"},"next":{"title":"Transactional memory (STM)","permalink":"/learn/coroutines/stm"}}'),o=n(74848),i=n(28453);let s={title:"... with Kafka",sidebar_position:3},a="SuspendApp with Kafka",c={},l=[];function d(e){let t={a:"a",code:"code",em:"em",h1:"h1",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"suspendapp-with-kafka",children:"SuspendApp with Kafka"})}),"\n",(0,o.jsxs)(t.p,{children:["When streaming ",(0,o.jsx)(t.em,{children:"records"})," from Kafka we need to ",(0,o.jsx)(t.em,{children:"commit"})," (acknowledge) the offset of the ",(0,o.jsx)(t.em,{children:"records"}),"\nwe've processed.\nThe official recommendation for doing this is committing offsets in batches, so we typically don't send the commit event\nto Kafka for every processed record.\nInstead, we commit the offset every 5 seconds (or every x records, 5s is default)."]}),"\n",(0,o.jsxs)(t.p,{children:["Imagine the application getting stopped after 4,5 seconds, either by ",(0,o.jsx)(t.em,{children:"Ctrl+C"})," or K8S or another type of\ncontainerization.\nWe could've processed thousands, or tens of thousands of events by that time.\nIf we don't commit these offsets before shutting down we'd have to re-process all the events."]}),"\n",(0,o.jsxs)(t.p,{children:["We can easily prevent this with SuspendApp, and ",(0,o.jsx)(t.a,{href:"https://github.com/nomisRev/kotlin-kafka",children:"kotlin-kafka"}),"\nor ",(0,o.jsx)(t.a,{href:"https://github.com/reactor/reactor-kafka",children:"reactor-kafka"}),".\nBoth these high-level Kafka libraries guarantee committing offsets upon termination of the stream, this includes\ncancellation!\nIn the example below, all calls to ",(0,o.jsx)(t.code,{children:"acknowledge"})," will be committed to Kafka before the SuspendApp terminates when\nreceiving ",(0,o.jsx)(t.code,{children:"SIGTERM"})," or ",(0,o.jsx)(t.code,{children:"SIGINT"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-kotlin",children:'import kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.map\nimport org.apache.kafka.common.serialization.StringDeserializer\nimport io.github.nomisRev.kafka.receiver.KafkaReceiver\nimport io.github.nomisRev.kafka.receiver.ReceiverSettings\nimport arrow.continuations.SuspendApp\n\nfun main() = SuspendApp {\n  val settings: ReceiverSettings<Nothing, String> = ReceiverSettings(\n    bootstrapServers = bootstrapServers,\n    groupId = "group-id",\n    valueDeserializer = StringDeserializer()\n  )\n  KafkaReceiver(settings)\n    .receive(topicName)\n    .map { record ->\n      println("${record.key()} -> ${record.value()}")\n      record.offset.acknowledge()\n    }.collect()\n}\n'})})]})}function p(e={}){let{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:function(e,t,n){n.d(t,{R:()=>s,x:()=>a});var r=n(96540);let o={},i=r.createContext(o);function s(e){let t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);