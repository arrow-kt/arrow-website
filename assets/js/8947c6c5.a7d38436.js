"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[1721],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(t),c=r,h=d["".concat(s,".").concat(c)]||d[c]||m[c]||i;return t?a.createElement(h,o(o({ref:n},u),{},{components:t})):a.createElement(h,o({ref:n},u))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[d]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},84322:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=t(87462),r=(t(67294),t(3905));const i={sidebar_position:1},o="Working with typed errors",l={unversionedId:"learn/typed-errors/working-with-typed-errors",id:"learn/typed-errors/working-with-typed-errors",title:"Working with typed errors",description:"Working with typed errors offers a few advantages over using exceptions:",source:"@site/content/docs/learn/typed-errors/working-with-typed-errors.md",sourceDirName:"learn/typed-errors",slug:"/learn/typed-errors/working-with-typed-errors",permalink:"/learn/typed-errors/working-with-typed-errors",draft:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/typed-errors/working-with-typed-errors.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"learnSidebar",previous:{title:"Typed Errors",permalink:"/learn/typed-errors/"},next:{title:"Why nullable types & Option?",permalink:"/learn/typed-errors/nullable-and-option"}},s={},p=[{value:"Different types",id:"different-types",level:2},{value:"Working with errors",id:"working-with-errors",level:2},{value:"Recovering from typed errors",id:"recovering-from-typed-errors",level:2},{value:"From logical failures",id:"from-logical-failures",level:3},{value:"From exceptions",id:"from-exceptions",level:3},{value:"Accumulating errors",id:"accumulating-errors",level:2},{value:"Accumulating different computations",id:"accumulating-different-computations",level:3},{value:"Creating your own error wrappers",id:"creating-your-own-error-wrappers",level:2}],u={toc:p},d="wrapper";function m(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"working-with-typed-errors"},"Working with typed errors"),(0,r.kt)("p",null,"Working with typed errors offers a few advantages over using exceptions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Type Safety:")," Typed errors allow the compiler to find type mismatches early, making it easier to catch bugs before they make it to production. However, with exceptions, the type information is lost, making it more difficult to detect errors at compile-time.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Predictability:")," When using typed errors, the possible error conditions are explicitly listed in the type signature of a function. This makes it easier to understand the possible error conditions and write tests covering all error scenarios.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Composability:")," Typed errors can be easily combined and propagated through a series of function calls, making writing modular, composable code easier. With exceptions, ensuring errors are correctly propagated through a complex codebase can be difficult.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Performance:")," Exception handling can significantly impact performance, especially in languages that don't have a dedicated stack for exceptions. Typed errors can be handled more efficiently as the compiler has more information about the possible error conditions."))),(0,r.kt)("p",null,"In summary, typed errors provide a more structured, predictable, and efficient way of handling errors and make writing high-quality, maintainable code easier."),(0,r.kt)("admonition",{title:"Media resources",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://kotlindevday.com/videos/functional-error-handling-a-practical-approach-bas-de-groot/"},(0,r.kt)("em",{parentName:"a"},"Functional Error Handling - A Practical Approach"))," by Bas de Groot"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=ipF540mBG9w"},(0,r.kt)("em",{parentName:"a"},"Exception handling in Kotlin with Arrow"))," by Ramandeep Kaur"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=8WdprhzmQe4"},(0,r.kt)("em",{parentName:"a"},"Por qu\xe9 no uso excepciones en mi c\xf3digo"))," by Ra\xfal Raja and ",(0,r.kt)("a",{parentName:"li",href:"https://codely.com/"},"Codely")))),(0,r.kt)("h2",{id:"different-types"},"Different types"),(0,r.kt)("p",null,"There are three ways of working with errors (in addition to ",(0,r.kt)("a",{parentName:"p",href:"../nullable-and-option"},(0,r.kt)("em",{parentName:"a"},"nullability")," and ",(0,r.kt)("inlineCode",{parentName:"a"},"Option")),", which model simple absence of value):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Either<E, A>")," represents a ",(0,r.kt)("em",{parentName:"p"},"computed value")," of ",(0,r.kt)("em",{parentName:"p"},"either")," a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," or a ",(0,r.kt)("em",{parentName:"p"},"success")," value ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Ior<E, A>")," represents a computed value of ",(0,r.kt)("em",{parentName:"p"},"either")," a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," or a ",(0,r.kt)("em",{parentName:"p"},"success")," value ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," or ",(0,r.kt)("strong",{parentName:"p"},"both")," a success value of ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," together with a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"E"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Raise<E>")," represents a ",(0,r.kt)("em",{parentName:"p"},"computation")," that might result in a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"E"),"."))),(0,r.kt)("p",null,"Below, we'll cover how you can work with these types and the differences and similarities using some examples. These types expose a similar API and allow working in a similar fashion."),(0,r.kt)("h2",{id:"working-with-errors"},"Working with errors"),(0,r.kt)("p",null,"Let's define a simple program that ",(0,r.kt)("em",{parentName:"p"},"raises")," a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound")," or returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"User"),". We can represent this both as a value ",(0,r.kt)("inlineCode",{parentName:"p"},"Either<UserNotFound, User>"),", and as a ",(0,r.kt)("em",{parentName:"p"},"computation")," (using ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise<UserNotFound>"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"object UserNotFound\ndata class User(val id: Long)\n\nval user: Either<UserNotFound, User> = User(1).right()\n\nfun Raise<UserNotFound>.user(): User = User(1)\n")),(0,r.kt)("p",null,"Above, we clearly show the difference between a ",(0,r.kt)("em",{parentName:"p"},"value"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"val"),", of ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," and a ",(0,r.kt)("em",{parentName:"p"},"computation"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"fun"),", using ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise<UserNotFound>"),". Since ",(0,r.kt)("strong",{parentName:"p"},"both")," represent ",(0,r.kt)("em",{parentName:"p"},"either")," ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"User"),", we can easily work with both together."),(0,r.kt)("p",null,"We can quickly turn our ",(0,r.kt)("em",{parentName:"p"},"computation")," ",(0,r.kt)("inlineCode",{parentName:"p"},"user()")," into a ",(0,r.kt)("em",{parentName:"p"},"value")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," by wrapping it inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"either")," DSL, and we can do the opposite for our ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," value by ",(0,r.kt)("em",{parentName:"p"},"safely")," unwrapping it using ",(0,r.kt)("inlineCode",{parentName:"p"},"bind()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val res = either { user() }\n\nfun Raise<UserNotFound>.res(): User = user.bind()\n")),(0,r.kt)("p",null,"We can then ",(0,r.kt)("em",{parentName:"p"},"inspect")," the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"res")," using Kotlin's ",(0,r.kt)("inlineCode",{parentName:"p"},"when"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"fold")," the ",(0,r.kt)("em",{parentName:"p"},"computation")," providing a lambda for both the ",(0,r.kt)("em",{parentName:"p"},"logical failure")," and the ",(0,r.kt)("em",{parentName:"p"},"success")," case."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun example() {\n  when (res) {\n    is Left -> fail("No logical failure occurred!")\n    is Right -> res.value shouldBe User(1)\n  }\n\n  fold(\n    block = { res() },\n    recover = { _: UserNotFound -> fail("No logical failure occurred!") },\n    transform = { i: User -> i shouldBe User(1) }\n  )\n}\n')),(0,r.kt)("admonition",{title:"Fold over all possible cases",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Unless you explicitly wrap your code to catch exceptions as part of ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise"),", exceptions bubble up in the usual way. If you need to handle those exceptions, ",(0,r.kt)("inlineCode",{parentName:"p"},"fold")," is also available with a ",(0,r.kt)("inlineCode",{parentName:"p"},"catch")," argument to recover from any ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable")," that might've been thrown. ",(0,r.kt)("a",{parentName:"p",href:"#from-exceptions"},"More information can be found below"),".")),(0,r.kt)("p",null,"To create a ",(0,r.kt)("em",{parentName:"p"},"value")," of a ",(0,r.kt)("em",{parentName:"p"},"logical failure"),", we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"left")," ",(0,r.kt)("em",{parentName:"p"},"smart-constructor")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," DSL function for a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," inside a ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," ",(0,r.kt)("em",{parentName:"p"},"computation"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val error: Either<UserNotFound, User> = UserNotFound.left()\n\nfun Raise<UserNotFound>.error(): User = raise(UserNotFound)\n")),(0,r.kt)("p",null,"We can then again use ",(0,r.kt)("inlineCode",{parentName:"p"},"when")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"fold")," to ",(0,r.kt)("em",{parentName:"p"},"inspect")," or ",(0,r.kt)("em",{parentName:"p"},"compute")," the value and function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun example() {\n  when (error) {\n    is Left -> error.value shouldBe UserNotFound\n    is Right -> fail("A logical failure occurred!")\n  }\n\n  fold(\n    { error() },\n    { e: UserNotFound -> e shouldBe UserNotFound },\n    { _: User -> fail("A logical failure occurred!") }\n  )\n}\n')),(0,r.kt)("p",null,"Besides ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"left"),", several DSLs are also available to check invariants.\n",(0,r.kt)("inlineCode",{parentName:"p"},"either { }")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," offer ",(0,r.kt)("inlineCode",{parentName:"p"},"ensure")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ensureNotNull"),", in spirit with ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"requireNotNull")," from the Kotlin Std.\nInstead of throwing an exception, they result in a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," with the given error if the predicate is not satisfied."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ensure")," takes a ",(0,r.kt)("em",{parentName:"p"},"predicate")," and a ",(0,r.kt)("em",{parentName:"p"},"lazy")," ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound")," value. When the ",(0,r.kt)("em",{parentName:"p"},"predicate")," is not matched, the ",(0,r.kt)("em",{parentName:"p"},"computation")," will result in a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound"),".\nIn the function below, we show how we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"ensure")," to check if a given ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," has a valid id, and if not, we return a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'data class UserNotFound(val message: String)\n\nfun User.isValid(): Either<UserNotFound, Unit> = either {\n  ensure(id > 0) { UserNotFound("User without a valid id: $id") }\n}\n\nfun Raise<UserNotFound>.isValid(user: User): User {\n  ensure(user.id > 0) { UserNotFound("User without a valid id: ${user.id}") }\n  return user\n}\n\nfun example() {\n  User(-1).isValid() shouldBe UserNotFound("User without a valid id: -1").left()\n\n  fold(\n    { isValid(User(1)) },\n    { _: UserNotFound -> fail("No logical failure occurred!") },\n    { user: User -> user.id shouldBe 1 }\n  )\n}\n')),(0,r.kt)("p",null,"Without context receivers, these functions look pretty different depending on if we use ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),". This is because we sacrifice our ",(0,r.kt)("em",{parentName:"p"},"extension receiver")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise"),".\nAnd thus, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," based computation cannot be an extension function on ",(0,r.kt)("inlineCode",{parentName:"p"},"User"),". With context receivers, we could've defined it as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'context(Raise<UserNotFound>)\nfun User.isValid(): Unit =\n  ensure(id > 0) { UserNotFound("User without a valid id: $id") }\n')),(0,r.kt)("admonition",{title:"Don't forget your binds!",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/woltapp/arrow-detekt-rules"},"Arrow Detekt Rules")," project has a set of rules to ",(0,r.kt)("em",{parentName:"p"},"detekt")," you call ",(0,r.kt)("inlineCode",{parentName:"p"},"bind")," on every ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," value.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ensureNotNull")," takes a ",(0,r.kt)("em",{parentName:"p"},"nullable value")," and a ",(0,r.kt)("em",{parentName:"p"},"lazy")," ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound")," value. When the value is null, the ",(0,r.kt)("em",{parentName:"p"},"computation")," will result in a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound"),".\nOtherwise, the value will be ",(0,r.kt)("em",{parentName:"p"},"smart-casted")," to non-null, and you can operate on it without checking nullability.\nIn the function below, we show how we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"ensureNotNull")," to check if a given ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," is non-null, and if not, we return a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun process(user: User?): Either<UserNotFound, Long> = either {\n  ensureNotNull(user) { UserNotFound("Cannot process null user") }\n  user.id // smart-casted to non-null\n}\n\nfun Raise<UserNotFound>.process(user: User?): Long {\n  ensureNotNull(user) { UserNotFound("Cannot process null user") }\n  return user.id // smart-casted to non-null\n}\n\nfun example() {\n  process(null) shouldBe UserNotFound("Cannot process null user").left()\n\n  fold(\n    { process(User(1)) },\n    { _: UserNotFound -> fail("No logical failure occurred!") },\n    { i: Long -> i shouldBe 1L }\n  )\n}\n')),(0,r.kt)("admonition",{title:"Nested error types",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Sometimes you may need to have one error type inside another one,\nlike ",(0,r.kt)("inlineCode",{parentName:"p"},"Either<Problem, Int?>"),". The rule of thumb in that case is to nest the\nrunner functions (",(0,r.kt)("inlineCode",{parentName:"p"},"either"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"option"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"nullable"),") in the same order as they\nappear in the type. When you call ",(0,r.kt)("inlineCode",{parentName:"p"},"raise"),', the type of the error given as\nargument is used to "select" the appropriate type to fall back to.'),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun problematic(n: Int): Either<Problem, Int?> =\n  either { \n    nullable { \n      when {\n        n < 0  -> raise(Problem)\n        n == 0 -> raise(null)\n        else   -> n\n      }\n    }\n  }\n"))),(0,r.kt)("h2",{id:"recovering-from-typed-errors"},"Recovering from typed errors"),(0,r.kt)("p",null,"We've already hinted this distinction above, but with working with type errors it's important to distinguish between two kinds of ",(0,r.kt)("em",{parentName:"p"},"problems")," that may arise:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Logical failures")," indicate problems within the domain, and which should be handled as part of the usual domain logic. For example, trying to find a user which doesn't exist, or validating input data."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Exceptions")," indicate problems which affect the system's ability to continue working. For example, if the database connection breaks this is something outside your domain logic.")),(0,r.kt)("p",null,"Historically exceptions have been used for both cases. For example, throwing a ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotValidException")," when the input data was wrong.\nWe advocate for making this distinction clear in the types, and leave exceptions only for exceptional cases.\nHowever, we're also aware of the historical baggage, so we provide tools to transforms those exceptions which shouldn't have been exceptions into typed errors."),(0,r.kt)("h3",{id:"from-logical-failures"},"From logical failures"),(0,r.kt)("p",null,"When working with values or functions that can result in a typed error, we often need to ",(0,r.kt)("em",{parentName:"p"},"recover")," to provide or calculate fallback values.\nTo demonstrate how we can ",(0,r.kt)("em",{parentName:"p"},"recover")," from ",(0,r.kt)("em",{parentName:"p"},"logical failures"),", let's define a simple function that returns our ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," in case the ",(0,r.kt)("inlineCode",{parentName:"p"},"id > 0"),"; otherwise it returns ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'suspend fun fetchUser(id: Long): Either<UserNotFound, User> = either {\n  ensure(id > 0) { UserNotFound("Invalid id: $id") }\n  User(id)\n}\n\nsuspend fun Raise<UserNotFound>.fetchUser(id: Long): User {\n  ensure(id > 0) { UserNotFound("Invalid id: $id") }\n  return User(id)\n}\n')),(0,r.kt)("p",null,"To recover from any errors on a ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," value, we can most conveniently use ",(0,r.kt)("inlineCode",{parentName:"p"},"getOrElse"),", since it allows us to ",(0,r.kt)("em",{parentName:"p"},"unwrap")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," and provide a fallback value.\nThe same can be done for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," based computation using the ",(0,r.kt)("inlineCode",{parentName:"p"},"recover")," DSL instead."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun example() {\n  fetchUser(-1)\n    .getOrElse { e: UserNotFound -> null } shouldBe null\n\n  recover({\n    fetchUser(1)\n  }) { e: UserNotFound -> null } shouldBe User(1)\n}\n")),(0,r.kt)("p",null,"Default to ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," is typically not desired since we've effectively swallowed our ",(0,r.kt)("em",{parentName:"p"},"logical failure")," and ignored our error. If that was desirable, we could've used nullable types initially.\nWhen encountering a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," and not being able to provide a proper fallback value, we typically want to execute another operation that might fail with ",(0,r.kt)("inlineCode",{parentName:"p"},"OtherError"),".\nAs a result, our ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," value doesn't get ",(0,r.kt)("em",{parentName:"p"},"unwrapped")," as it did with ",(0,r.kt)("inlineCode",{parentName:"p"},"getOrElse"),", since a different ",(0,r.kt)("em",{parentName:"p"},"logical failure")," might've occurred."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"object OtherError\n\nfun example() {\n  val either: Either<OtherError, User> =\n    fetchUser(1)\n      .recover { _: UserNotFound -> raise(OtherError) }\n  \n  either shouldBe User(1).right()\n\n  fetchUser(-1)\n    .recover { _: UserNotFound -> raise(OtherError) } shouldBe OtherError.left()\n}\n")),(0,r.kt)("p",null,"The type system now tracks that a new error of ",(0,r.kt)("inlineCode",{parentName:"p"},"OtherError")," might have occurred, but we recovered from any possible errors of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound "),". This is useful across application layers or in the service layer, where we might want to ",(0,r.kt)("inlineCode",{parentName:"p"},"recover")," from a ",(0,r.kt)("inlineCode",{parentName:"p"},"DatabaseError")," with a ",(0,r.kt)("inlineCode",{parentName:"p"},"NetworkError")," when we want to load data from the network when a database operation failed.\nTo achieve the same with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," DSL, we need to be inside the context of ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise<OtherError>")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun Raise<OtherError>.recovery(): User =\n  recover({\n    fetchUser(-1)\n  }) { _: UserNotFound -> raise(OtherError) }\n")),(0,r.kt)("admonition",{title:"DSLs everywhere",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Since recovery for both ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," is DSL based, you can also call ",(0,r.kt)("inlineCode",{parentName:"p"},"bind")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," from both.\nThis allows seamless interop between both types when creating programs that can fail and recovering from them.")),(0,r.kt)("h3",{id:"from-exceptions"},"From exceptions"),(0,r.kt)("p",null,"When building applications, we often need to wrap side effects or foreign code, like when interacting with the network or databases.\nWrapping such APIs requires handling the possibility of failure, and we can do so by returning a ",(0,r.kt)("em",{parentName:"p"},"logical failure"),". The question is often, do we need to take into ",(0,r.kt)("strong",{parentName:"p"},"all")," exceptions or just a subset of them?\nThe answer is that it depends on the use case, but, in general, we should try to be as specific as possible and only handle the exceptions that we can recover from or expect.\nHowever, you might want to be more defensive when interacting with improperly defined systems."),(0,r.kt)("p",null,"Let's look at an example where we interact with a database and want to insert a new user. If the user already exists, we want to return a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserAlreadyExists"),". Otherwise, we want to return the newly created user.\nWe again showcase both the code for ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," based computation and see that both are almost the same."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"catch")," DSL allows us to wrap foreign functions and capture any ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"T: Throwable")," that might be thrown. It automatically avoids capturing ",(0,r.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-core/arrow.core/-non-fatal.html"},"fatal exceptions")," such as ",(0,r.kt)("inlineCode",{parentName:"p"},"OutOfMemoryError"),", or Kotlin's ",(0,r.kt)("inlineCode",{parentName:"p"},"CancellationException"),".\nIt requires two functions, or lambdas, as arguments: One for wrapping our ",(0,r.kt)("em",{parentName:"p"},"foreign code")," and another for resolving the captured ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"T : Throwable"),". In this case, instead of providing a fallback value, we ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," a ",(0,r.kt)("em",{parentName:"p"},"logical failure"),"."),(0,r.kt)("p",null,"We expect ",(0,r.kt)("inlineCode",{parentName:"p"},"SQLException")," since we only ",(0,r.kt)("em",{parentName:"p"},"expect")," it to be thrown and rethrow any other ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable"),".\nWe can then operate on the captured ",(0,r.kt)("inlineCode",{parentName:"p"},"SQLException")," to check if our insertion failed with a unique violation, and, in that case, we turn it into a ",(0,r.kt)("inlineCode",{parentName:"p"},"UserAlreadyExists")," ",(0,r.kt)("em",{parentName:"p"},"logical failure"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class UserAlreadyExists(val username: String, val email: String)\n\nsuspend fun Raise<UserAlreadyExists>.insertUser(username: String, email: String): Long =\n  catch({\n    UsersQueries.insert(username, email)\n  }) { e: SQLException ->\n    if (e.isUniqueViolation()) raise(UserAlreadyExists(username, email))\n    else throw e\n  }\n")),(0,r.kt)("p",null,"Since we also have ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," available inside ",(0,r.kt)("inlineCode",{parentName:"p"},"either"),", we can also write the same code using ",(0,r.kt)("inlineCode",{parentName:"p"},"either")," or execute this function inside an ",(0,r.kt)("inlineCode",{parentName:"p"},"either")," block as shown above.\nThis behavior is also available as top-level functionality on ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," itself if you prefer to use that. It can be achieved using ",(0,r.kt)("inlineCode",{parentName:"p"},"catchOrThrow")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"catch")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"mapLeft")," to transform ",(0,r.kt)("inlineCode",{parentName:"p"},"SQLException")," into ",(0,r.kt)("inlineCode",{parentName:"p"},"UserAlreadyExists"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun insertUser(username: String, email: String): Either<UserAlreadyExists, Long> =\n  Either.catchOrThrow<SQLException, Long> {\n    UsersQueries.insert(username, email)\n  }.mapLeft { e ->\n    if (e.isUniqueViolation()) UserAlreadyExists(username, email)\n    else throw e\n  }\n")),(0,r.kt)("p",null,"This pattern allows us to turn exceptions we want to track into ",(0,r.kt)("em",{parentName:"p"},"typed errors"),", and things that are ",(0,r.kt)("strong",{parentName:"p"},"truly")," exceptional remain exceptional."),(0,r.kt)("h2",{id:"accumulating-errors"},"Accumulating errors"),(0,r.kt)("p",null,"All the behavior above works similarly to ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable"),", but in a typed manner. This means that if we encounter a typed error or ",(0,r.kt)("em",{parentName:"p"},"logical failure"),", that error is propagated, and we can't continue with the computation and ",(0,r.kt)("em",{parentName:"p"},"short-circuit"),".\nWhen we need to work with collections, or ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterable"),", we often want to accumulate all the errors and not short-circuit. Let's take a look at how we can do this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class NotEven(val i: Int)\n\nfun Raise<NotEven>.isEven(i: Int): Int =\n  i.also { ensure(i % 2 == 0) { NotEven(i) } }\n\nfun isEven2(i: Int): Either<NotEven, Int> =\n  either { isEven(i) }\n")),(0,r.kt)("p",null,"First, we define two functions that return a typed error if the value is not even.\nIf we want to accumulate all the errors, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"mapOrAccumulate")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterable")," to get all the errors, and doing so for ",(0,r.kt)("inlineCode",{parentName:"p"},"(0..10)")," should return the following ",(0,r.kt)("inlineCode",{parentName:"p"},"errors"),"."),(0,r.kt)("admonition",{title:"Non-empty lists",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Since you have potentially more than one failure, the error type in ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," must be some sort of list.\nHowever, we know that if we are not in the happy path, then ",(0,r.kt)("em",{parentName:"p"},"at least one")," error must have occurred.\nArrow makes this fact explicit by making the return type of ",(0,r.kt)("inlineCode",{parentName:"p"},"mapOrAccumulate ")," a ",(0,r.kt)("inlineCode",{parentName:"p"},"NonEmptyList"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"Nel")," for short.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val errors = nonEmptyListOf(NotEven(1), NotEven(3), NotEven(5), NotEven(7), NotEven(9)).left()\n\nfun example() {\n  (1..10).mapOrAccumulate { isEven(it) } shouldBe errors\n  (1..10).mapOrAccumulate { isEven2(it).bind() } shouldBe errors\n}\n")),(0,r.kt)("p",null,"We can also provide custom logic to accumulate the errors, typically when we have custom types.\nBelow, instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"NonEmptyList<NotEven>"),", we have a ",(0,r.kt)("inlineCode",{parentName:"p"},"MyError")," type that builds a String with all the error messages.\nSo we again define two functions that return a typed error if the value is not even."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'data class MyError(val message: String)\n\nfun Raise<MyError>.isEven(i: Int): Int =\n  ensureNotNull(i.takeIf { i % 2 == 0 }) { MyError("$i is not even") }\n\nfun isEven2(i: Int): Either<MyError, Int> =\n  either { isEven(i) }\n')),(0,r.kt)("p",null,"And we write a small function that combines two values of our typed error into one, appending the error messages."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'operator fun MyError.plus(second: MyError): MyError =\n  MyError(message + ", ${second.message}")\n')),(0,r.kt)("p",null,"We can then simply pass this function to the ",(0,r.kt)("inlineCode",{parentName:"p"},"mapOrAccumulate")," function, and it will accumulate all the errors into a single ",(0,r.kt)("inlineCode",{parentName:"p"},"MyError")," value using our provided function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val error = MyError("1 is not even, 3 is not even, 5 is not even, 7 is not even, 9 is not even").left()\n\nfun example() {\n  (1..10).mapOrAccumulate(MyError::plus) { isEven(it) } shouldBe error\n  (1..10).mapOrAccumulate(MyError::plus) { isEven2(it).bind() } shouldBe error\n}\n')),(0,r.kt)("h3",{id:"accumulating-different-computations"},"Accumulating different computations"),(0,r.kt)("p",null,"In the example above we are providing one single function to operate on a sequence of elements.\nAnother important and related scenario is accumulating different errors, but each of them coming from different computations.\nFor example, you need to perform validation over the different fields of a form, and accumulate the errors, but each field has different constraints."),(0,r.kt)("p",null,"As a guiding example, let's consider information about a user, where the name shouldn't be empty and the age should be non-negative."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class User(val name: String, val age: Int)\n")),(0,r.kt)("p",null,"It's customary to define the different problems that may arise from validation as a sealed interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"sealed interface UserProblem {\n  object EmptyName: UserProblem\n  data class NegativeAge(val age: Int): UserProblem\n}\n")),(0,r.kt)("p",null,"Let's define validation as a ",(0,r.kt)("em",{parentName:"p"},"smart constructor"),", that is, by creating a function which looks like the ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," constructor, but performs additional checks."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class User private constructor(val name: String, val age: Int) {\n  companion object {\n    operator fun invoke(name: String, age: Int): Either<UserProblem, User> = either {\n      ensure(name.isNotEmpty()) { UserProblem.EmptyName }\n      ensure(age >= 0) { UserProblem.NegativeAge(age) }\n      User(name, age)\n    }\n  }\n}\n")),(0,r.kt)("p",null,"Alas, that implementation stops after the first error. We can see this if we try to validate a ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," with both an empty name and a wrong age."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun example() {\n  User("", -1) shouldBe Left(UserProblem.EmptyName)\n}\n')),(0,r.kt)("p",null,"If you want to gather as many validation problems as possible, you need to switch to ",(0,r.kt)("em",{parentName:"p"},"accumulation"),", as done above with ",(0,r.kt)("inlineCode",{parentName:"p"},"mapOrAccumulate"),".\nWhen each of the validations is different, you should reach to ",(0,r.kt)("inlineCode",{parentName:"p"},"zipOrAccumulate"),": each of the arguments defines one independent validation,\nand the final block defines what to do when all the validations were successful, that is, when no problem was ",(0,r.kt)("inlineCode",{parentName:"p"},"raise"),"d during execution."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class User private constructor(val name: String, val age: Int) {\n  companion object {\n    operator fun invoke(name: String, age: Int): Either<NonEmptyList<UserProblem>, User> = either {\n      zipOrAccumulate(\n        { ensure(name.isNotEmpty()) { UserProblem.EmptyName } },\n        { ensure(age >= 0) { UserProblem.NegativeAge(age) } }\n      ) { _, _ -> User(name, age) }\n    }\n  }\n}\n")),(0,r.kt)("p",null,"With this change, the problems are correctly accumulated. Now we can present the user all the problems in the form at once."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun example() {\n  User("", -1) shouldBe Left(nonEmptyListOf(UserProblem.EmptyName, UserProblem.NegativeAge(-1)))\n}\n')),(0,r.kt)("admonition",{title:"Error accumulation and concurrency",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"In addition to accumulating errors, you may want to perform each of the tasks within ",(0,r.kt)("inlineCode",{parentName:"p"},"zipOrAccumulate")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"mapOrAccumulate")," in parallel.\nArrow Fx features ",(0,r.kt)("a",{parentName:"p",href:"../../coroutines/parallel/#accumulating-typed-errors-in-parallel"},(0,r.kt)("inlineCode",{parentName:"a"},"parZipOrAccumulate")," and ",(0,r.kt)("inlineCode",{parentName:"a"},"parMapOrAccumulate"))," to cover\nthose cases, in addition to ",(0,r.kt)("a",{parentName:"p",href:"../../coroutines/parallel/#integration-with-typed-errors"},(0,r.kt)("inlineCode",{parentName:"a"},"parZip")," and ",(0,r.kt)("inlineCode",{parentName:"a"},"parMap")),"\nwhich follow a short-circuiting approach.")),(0,r.kt)("h2",{id:"creating-your-own-error-wrappers"},"Creating your own error wrappers"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," is a powerful tool that allows us to create our own DSLs to raise typed errors.\nIt easily allows integration with existing libraries and frameworks that offer similar data types like ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," or even your own custom types.\nFor example, let's take a popular ADT often used in the front end, a type that models ",(0,r.kt)("inlineCode",{parentName:"p"},"Loading"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Content"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"Failure"),", often abbreviated as ",(0,r.kt)("inlineCode",{parentName:"p"},"LCE"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"sealed interface Lce<out E, out A> {\n  object Loading : Lce<Nothing, Nothing>\n  data class Content<A>(val value: A) : Lce<Nothing, A>\n  data class Failure<E>(val error: E) : Lce<E, Nothing>\n}\n")),(0,r.kt)("p",null,"Let's say that once a ",(0,r.kt)("inlineCode",{parentName:"p"},"Failure")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Loading")," case is encountered, we want to short-circuit and not continue with the computation.\nIt's easy to define a ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," instance for ",(0,r.kt)("inlineCode",{parentName:"p"},"Lce")," that does just that. We'll use the composition pattern to do this ",(0,r.kt)("strong",{parentName:"p"},"without")," context receivers.\nSince we need to ",(0,r.kt)("em",{parentName:"p"},"raise")," both ",(0,r.kt)("inlineCode",{parentName:"p"},"Lce.Loading")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Lce.Failure"),", our ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," instance will need to be able to ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," ",(0,r.kt)("inlineCode",{parentName:"p"},"Lce<E, Nothing>"),", and we wrap that in a ",(0,r.kt)("inlineCode",{parentName:"p"},"LceRaise")," class.\nWithin that class, a ",(0,r.kt)("inlineCode",{parentName:"p"},"bind")," function can be defined to short-circuit any encountered ",(0,r.kt)("inlineCode",{parentName:"p"},"Failure")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Loading")," case or otherwise return the ",(0,r.kt)("inlineCode",{parentName:"p"},"Content")," value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@JvmInline\nvalue class LceRaise<E>(val raise: Raise<Lce<E, Nothing>>) : Raise<Lce<E, Nothing>> by raise {\n  fun <A> Lce<E, A>.bind(): A =  when (this) {\n    is Lce.Content -> value\n    is Lce.Failure -> raise.raise(this)\n    Lce.Loading -> raise.raise(Lce.Loading)\n  }\n}\n")),(0,r.kt)("p",null,"All that is required now is a DSL function. We can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"recover")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"fold")," function to summon an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"RaiseLce<E, Nothing>")," from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," type class.\nWe wrap the ",(0,r.kt)("inlineCode",{parentName:"p"},"block")," in an ",(0,r.kt)("inlineCode",{parentName:"p"},"Lce.Content")," value and return any encountered ",(0,r.kt)("inlineCode",{parentName:"p"},"Lce<E, Nothing>")," value. We can call ",(0,r.kt)("inlineCode",{parentName:"p"},"block")," by wrapping ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise<Lce<E, Nothing>>")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"LceRaise"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@OptIn(ExperimentalTypeInference::class)\ninline fun <E, A> lce(@BuilderInference block: LceRaise<E>.() -> A): Lce<E, A> =\n  recover({ Lce.Content(block(LceRaise(this))) }) { e: Lce<E, Nothing> -> e }\n")),(0,r.kt)("p",null,"We can now use this DSL to compose our computations and ",(0,r.kt)("inlineCode",{parentName:"p"},"Lce")," values in the same way as we've discussed above in this document.\nFurthermore, since this DSL is built on top of ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise"),", we can use all the functions we've discussed above."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun example() {\n  lce {\n    val a = Lce.Content(1).bind()\n    val b = Lce.Content(1).bind()\n    a + b\n  } shouldBe Lce.Content(2)\n\n  lce {\n    val a = Lce.Content(1).bind()\n    ensure(a > 1) { Lce.Failure("a is not greater than 1") }\n    a + 1\n  } shouldBe Lce.Failure("a is not greater than 1")\n}\n')),(0,r.kt)("p",null,"If we'd used ",(0,r.kt)("em",{parentName:"p"},"context receivers"),", defining this DSL would be even more straightforward, and we could use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," type class directly."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"context(Raise<Lce<E, Nothing>>)\nfun <E, A> Lce<E, A>.bind(): A =  when (this) {\n  is Lce.Content -> value\n  is Lce.Failure -> raise(this)\n  Lce.Loading -> raise(Lce.Loading)\n}\n\ninline fun <E, A> lce(@BuilderInference block: Raise<Lce<E, Nothing>>.() -> A): Lce<E, A> =\n  recover({ Lce.Content(block(this)) }) { e: Lce<E, Nothing> -> e }\n")),(0,r.kt)("h1",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"Working with typed errors in Kotlin with Arrow is a breeze. We can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," type to represent a value that can either be a success or a failure, and we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," DSL to raise typed errors without ",(0,r.kt)("em",{parentName:"p"},"wrappers"),".\nSince all these functions and builders are built on top of ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise"),", they all seamlessly work together, and we can mix and match them as we please."),(0,r.kt)("p",null,"If you have any questions or feedback, please reach out to us on ",(0,r.kt)("a",{parentName:"p",href:"https://slack-chats.kotlinlang.org/c/arrow"},"Slack")," or ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/arrow-kt/arrow/issues"},"Github"),"."))}m.isMDXComponent=!0}}]);