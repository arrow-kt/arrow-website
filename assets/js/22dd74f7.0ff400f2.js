"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([["1924"],{55226:function(e){e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"learnSidebar":[{"type":"category","label":"Quickstart","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-quickstart.svg","description":"Gradle or Maven, JVM or Multiplatform, Arrow fits in all your projects","overview":true},"items":[{"type":"link","href":"/learn/quickstart/libs","label":"Overview of libraries","customProps":{"icon":"icon-docs.svg"},"docId":"learn/quickstart/libs","unlisted":false},{"type":"link","href":"/learn/quickstart/from-fp","label":"From other FP languages","docId":"learn/quickstart/from-fp","unlisted":false},{"type":"link","href":"/learn/quickstart/serialization","label":"Serialization","docId":"learn/quickstart/serialization","unlisted":false},{"type":"link","href":"/learn/quickstart/compose","label":"Compose and UIs","docId":"learn/quickstart/compose","unlisted":false},{"type":"link","href":"/learn/quickstart/migration","label":"Migration to Arrow 2.0 / 1.2","docId":"learn/quickstart/migration","unlisted":false}],"href":"/learn/quickstart/"},{"type":"category","label":"Typed errors","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-typed-errors.svg","description":"Learn how to work with typed errors","overview":true},"items":[{"type":"link","href":"/learn/typed-errors/working-with-typed-errors","label":"Working with typed errors","docId":"learn/typed-errors/working-with-typed-errors","unlisted":false},{"type":"link","href":"/learn/typed-errors/validation","label":"Validation","docId":"learn/typed-errors/validation","unlisted":false},{"type":"link","href":"/learn/typed-errors/from-either-to-raise","label":"From Either to Raise","docId":"learn/typed-errors/from-either-to-raise","unlisted":false},{"type":"link","href":"/learn/typed-errors/nullable-and-option","label":"Why nullable types & Option?","docId":"learn/typed-errors/nullable-and-option","unlisted":false},{"type":"link","href":"/learn/typed-errors/either-and-ior","label":"Either & Ior (& Result)","docId":"learn/typed-errors/either-and-ior","unlisted":false},{"type":"link","href":"/learn/typed-errors/outcome-progress","label":"Outcomes and in-progress","docId":"learn/typed-errors/outcome-progress","unlisted":false},{"type":"link","href":"/learn/typed-errors/own-error-types","label":"Your own error wrappers","docId":"learn/typed-errors/own-error-types","unlisted":false}],"href":"/learn/typed-errors/"},{"type":"category","label":"Concurrency and resources","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-coroutines.svg","description":"Concurrency and resources","overview":true},"items":[{"type":"link","href":"/learn/coroutines/parallel","label":"Parallelism","docId":"learn/coroutines/parallel","unlisted":false},{"type":"link","href":"/learn/coroutines/racing","label":"Racing","docId":"learn/coroutines/racing","unlisted":false},{"type":"link","href":"/learn/coroutines/resource-safety","label":"Resource","docId":"learn/coroutines/resource-safety","unlisted":false},{"type":"category","label":"Graceful shutdown","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-coroutines.svg","description":"Graceful shutdowns"},"items":[{"type":"link","href":"/learn/coroutines/suspendapp/ktor","label":"... with Ktor","docId":"learn/coroutines/suspendapp/ktor","unlisted":false},{"type":"link","href":"/learn/coroutines/suspendapp/kafka","label":"... with Kafka","docId":"learn/coroutines/suspendapp/kafka","unlisted":false}],"href":"/learn/coroutines/suspendapp/"},{"type":"link","href":"/learn/coroutines/stm","label":"Transactional memory (STM)","docId":"learn/coroutines/stm","unlisted":false},{"type":"link","href":"/learn/coroutines/concurrency-primitives","label":"Concurrency primitives","docId":"learn/coroutines/concurrency-primitives","unlisted":false}],"href":"/learn/coroutines/"},{"type":"category","label":"Resilience","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-resilience.svg","description":"Act in an organized way when failures occur","overview":true},"items":[{"type":"link","href":"/learn/resilience/retry-and-repeat","label":"Retry and repeat","docId":"learn/resilience/retry-and-repeat","unlisted":false},{"type":"link","href":"/learn/resilience/circuitbreaker","label":"Circuit breaker","docId":"learn/resilience/circuitbreaker","unlisted":false},{"type":"link","href":"/learn/resilience/saga","label":"Saga","docId":"learn/resilience/saga","unlisted":false}],"href":"/learn/resilience/"},{"type":"category","label":"Immutable data","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-immutable-data.svg","description":"Concise ways to handle immutable data","overview":true},"items":[{"type":"link","href":"/learn/immutable-data/intro","label":"Introduction","docId":"learn/immutable-data/intro","unlisted":false},{"type":"link","href":"/learn/immutable-data/lens","label":"Lenses","docId":"learn/immutable-data/lens","unlisted":false},{"type":"link","href":"/learn/immutable-data/optional","label":"Optionals","docId":"learn/immutable-data/optional","unlisted":false},{"type":"link","href":"/learn/immutable-data/traversal","label":"Traversals","docId":"learn/immutable-data/traversal","unlisted":false},{"type":"link","href":"/learn/immutable-data/prism-iso","label":"Prisms & Isos","docId":"learn/immutable-data/prism-iso","unlisted":false},{"type":"link","href":"/learn/immutable-data/reflection","label":"Reflection","docId":"learn/immutable-data/reflection","unlisted":false},{"type":"link","href":"/learn/immutable-data/regex","label":"Regular expressions","docId":"learn/immutable-data/regex","unlisted":false}],"href":"/learn/immutable-data/"},{"type":"category","label":"Collections and functions","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-generic-6.svg","description":"Utilities for more productive basics","overview":true},"items":[{"type":"link","href":"/learn/collections-functions/non-empty","label":"Non-empty collections","docId":"learn/collections-functions/non-empty","unlisted":false},{"type":"link","href":"/learn/collections-functions/collectors","label":"Collectors","docId":"learn/collections-functions/collectors","unlisted":false},{"type":"link","href":"/learn/collections-functions/recursive","label":"Recursive functions","docId":"learn/collections-functions/recursive","unlisted":false},{"type":"link","href":"/learn/collections-functions/memoize","label":"Memoization","docId":"learn/collections-functions/memoize","unlisted":false},{"type":"link","href":"/learn/collections-functions/eval","label":"Control over evaluation","docId":"learn/collections-functions/eval","unlisted":false},{"type":"link","href":"/learn/collections-functions/utils","label":"Utilities for functions","docId":"learn/collections-functions/utils","unlisted":false}],"href":"/learn/collections-functions/"},{"type":"category","label":"Design recipes","collapsible":true,"collapsed":true,"customProps":{"icon":"icon-design.svg","description":"Recipes for designing nice Kotlin code","overview":true},"items":[{"type":"link","href":"/learn/design/domain-modeling","label":"Domain modeling","docId":"learn/design/domain-modeling","unlisted":false},{"type":"link","href":"/learn/design/effects-contexts","label":"Effects and contexts","docId":"learn/design/effects-contexts","unlisted":false},{"type":"link","href":"/learn/design/receivers-flatmap","label":"Receivers vs. flatMap","docId":"learn/design/receivers-flatmap","unlisted":false},{"type":"link","href":"/learn/design/suspend-io","label":"Why suspend over IO","docId":"learn/design/suspend-io","unlisted":false}],"href":"/learn/design/"},{"type":"link","href":"/learn/projects","label":"Example projects","docId":"learn/projects","unlisted":false},{"type":"link","href":"/learn/integrations","label":"Integrations","customProps":{"description":"Playing nice with the rest of the ecosystem","icon":"icon-generic-5.svg","overview":true},"docId":"learn/integrations","unlisted":false},{"type":"link","href":"/learn/summary","label":"Summary","customProps":{"icon":"icon-tutorial.svg"},"docId":"learn/summary","unlisted":false},{"type":"link","href":"/learn/overview","label":"overview","className":"sidebar-hidden","docId":"learn/overview","unlisted":false}],"ecosystemSidebar":[{"type":"category","label":"Analysis","collapsible":true,"collapsed":true,"customProps":{"icon":"arrow-analysis-icon.svg","description":"Arrow Analysis introduces new checks in your compilation pipeline, which warn about common mistakes like out of bounds indexing"},"items":[{"type":"link","href":"/ecosystem/analysis/quickstart","label":"Quickstart","customProps":{"icon":"icon-quickstart.svg"},"docId":"ecosystem/analysis/quickstart","unlisted":false},{"type":"link","href":"/ecosystem/analysis/conditions","label":"Pre and post-conditions","docId":"ecosystem/analysis/conditions","unlisted":false},{"type":"link","href":"/ecosystem/analysis/control","label":"Control operators","docId":"ecosystem/analysis/control","unlisted":false},{"type":"link","href":"/ecosystem/analysis/mutability","label":"Mutability and loops","docId":"ecosystem/analysis/mutability","unlisted":false},{"type":"link","href":"/ecosystem/analysis/types","label":"Types and invariants","docId":"ecosystem/analysis/types","unlisted":false},{"type":"link","href":"/ecosystem/analysis/wrappers","label":"Fields and wrappers","docId":"ecosystem/analysis/wrappers","unlisted":false},{"type":"link","href":"/ecosystem/analysis/laws","label":"3rd-party libraries (Laws)","docId":"ecosystem/analysis/laws","unlisted":false},{"type":"link","href":"/ecosystem/analysis/java","label":"Java support","docId":"ecosystem/analysis/java","unlisted":false},{"type":"link","href":"/ecosystem/analysis/sarif","label":"GitHub Actions / SARIF","customProps":{"icon":"icon-github.svg"},"docId":"ecosystem/analysis/sarif","unlisted":false}],"href":"/ecosystem/analysis/"}]},"docs":{"ecosystem/analysis/conditions":{"id":"ecosystem/analysis/conditions","title":"Pre and post-conditions","description":"In Quickstart we\'ve introduced the idea of pre and post-conditions of functions as promises that either the caller or the body of the function should obey. Here we go deeper in the topic, about how these conditions may look, how they compose, and which way they are checked.","sidebar":"ecosystemSidebar"},"ecosystem/analysis/control":{"id":"ecosystem/analysis/control","title":"Control operators","description":"When dealing with pre-conditions, the environment in which a call takes place is very important. You introduce new information in the environment every time you use a control operator like if or when. For example, the following is accepted by Arrow Analysis, when you manually checking whether the size of the list is enough for getin the right value:","sidebar":"ecosystemSidebar"},"ecosystem/analysis/index":{"id":"ecosystem/analysis/index","title":"Analysis","description":"{useCurrentSidebarCategory().customProps.description}","sidebar":"ecosystemSidebar"},"ecosystem/analysis/java":{"id":"ecosystem/analysis/java","title":"Java support","description":"This is still an alpha feature.","sidebar":"ecosystemSidebar"},"ecosystem/analysis/laws":{"id":"ecosystem/analysis/laws","title":"3rd-party libraries (Laws)","description":"Is a library you use not compiled with Arrow Analysis? I could tell you to open an issue in their repository and convince their authors, but this is not always possible. For those cases Arrow Analysis provides a way to declare pre- and postconditions separately from the implementation, using @Law annotations. In fact, this is the way we package the analysis information related to Kotlin\'s stdlib.","sidebar":"ecosystemSidebar"},"ecosystem/analysis/mutability":{"id":"ecosystem/analysis/mutability","title":"Mutability and loops","description":"Arrow Analysis supports mutability at the level of functions (but not yet at the level of classes). However, when you declare something with var, things get tricky. \u{1F47B}","sidebar":"ecosystemSidebar"},"ecosystem/analysis/quickstart":{"id":"ecosystem/analysis/quickstart","title":"Quickstart","description":"This Quickstart explains how to set up Arrow Analysis in your Gradle project, and how to use it to get further insight in your code, and to introduce additional checks in your own functions and classes.","sidebar":"ecosystemSidebar"},"ecosystem/analysis/sarif":{"id":"ecosystem/analysis/sarif","title":"GitHub Actions / SARIF","description":"This is still an alpha feature.","sidebar":"ecosystemSidebar"},"ecosystem/analysis/types":{"id":"ecosystem/analysis/types","title":"Types and invariants","description":"Classes and interfaces (which we shall collectively refer to as \\"types\\") play a crucial role in organizing data in Kotlin. Arrow Analysis builds upon this idea, giving users the ability to attach Boolean expressions related to the data contained in a class. We call those invariants of the type, since the tool enforces those expressions to be true throughout the whole program.","sidebar":"ecosystemSidebar"},"ecosystem/analysis/wrappers":{"id":"ecosystem/analysis/wrappers","title":"Fields and wrappers","description":"Arrow Analysis supports the addition of invariants to types, but what happens when you already have a type and want to add information relative to it? And when may that situation arise? There are two different features to keep more information: fields and wrapper types.","sidebar":"ecosystemSidebar"},"learn/collections-functions/collectors":{"id":"learn/collections-functions/collectors","title":"Collectors","description":"Better aggregation over sequences","sidebar":"learnSidebar"},"learn/collections-functions/eval":{"id":"learn/collections-functions/eval","title":"Control over evaluation","description":"Delaying computation and caching results","sidebar":"learnSidebar"},"learn/collections-functions/index":{"id":"learn/collections-functions/index","title":"Collections and functions","description":"In the quest to be the perfect companion to your Kotlin journey,","sidebar":"learnSidebar"},"learn/collections-functions/memoize":{"id":"learn/collections-functions/memoize","title":"Memoization","description":"Avoiding duplicate work for pure functions","sidebar":"learnSidebar"},"learn/collections-functions/non-empty":{"id":"learn/collections-functions/non-empty","title":"Non-empty collections","description":"Working with collections with at least one element","sidebar":"learnSidebar"},"learn/collections-functions/recursive":{"id":"learn/collections-functions/recursive","title":"Recursive functions","description":"Making functions stack-safe and efficient","sidebar":"learnSidebar"},"learn/collections-functions/utils":{"id":"learn/collections-functions/utils","title":"Utilities for functions","description":"Composition, partial application, and currying","sidebar":"learnSidebar"},"learn/coroutines/concurrency-primitives":{"id":"learn/coroutines/concurrency-primitives","title":"Concurrency primitives","description":"These types are not usually found in application code, but provide essential","sidebar":"learnSidebar"},"learn/coroutines/index":{"id":"learn/coroutines/index","title":"Coroutines","description":"Coroutines are one of the","sidebar":"learnSidebar"},"learn/coroutines/parallel":{"id":"learn/coroutines/parallel","title":"Parallelism","description":"We often have independent computations that we want to perform in parallel.","sidebar":"learnSidebar"},"learn/coroutines/racing":{"id":"learn/coroutines/racing","title":"Racing","description":"The parallelism operators describe the cases in which we are interested in the result","sidebar":"learnSidebar"},"learn/coroutines/resource-safety":{"id":"learn/coroutines/resource-safety","title":"Resource","description":"Allocation and release of resources is not easy, especially when","sidebar":"learnSidebar"},"learn/coroutines/stm":{"id":"learn/coroutines/stm","title":"Transactional memory (STM)","description":"Software transactional memory, or STM, is an abstraction for concurrent state modification.","sidebar":"learnSidebar"},"learn/coroutines/suspendapp/index":{"id":"learn/coroutines/suspendapp/index","title":"Graceful shutdown","description":"When building applications that require graceful shutdown it typically requires us to write a lot of platform-specific","sidebar":"learnSidebar"},"learn/coroutines/suspendapp/kafka":{"id":"learn/coroutines/suspendapp/kafka","title":"... with Kafka","description":"When streaming records from Kafka we need to commit (acknowledge) the offset of the records","sidebar":"learnSidebar"},"learn/coroutines/suspendapp/ktor":{"id":"learn/coroutines/suspendapp/ktor","title":"... with Ktor","description":"There are some cases where it is convenient to gracefully shutdown a Ktor server. Basically, it is about giving some","sidebar":"learnSidebar"},"learn/design/domain-modeling":{"id":"learn/design/domain-modeling","title":"Domain modeling","description":"The goal of functional domain modeling is to describe your business domain as accurately as possible to achieve more type-safety, maximize the use of the compiler with our domain and, thus, prevent bugs and reduce unit testing. Additionally, it makes communicating about the domain easier since the domain is the touchpoint with the real world. Kotlin is a good fit for functional domain modeling. It offers us data class, sealed class, enum class, and value class. And we have Arrow, which provides some interesting generic data types such as Either and Ior.","sidebar":"learnSidebar"},"learn/design/effects-contexts":{"id":"learn/design/effects-contexts","title":"Effects and contexts","description":"How you model data is an essential part of the design of your software. The other important side is how you model your behaviors. Today, we will talk about how to simplify your code with effects, avoiding heavyweight dependency injection frameworks on the go.","sidebar":"learnSidebar"},"learn/design/index":{"id":"learn/design/index","title":"Design","description":"Recipes for designing nice Kotlin code.","sidebar":"learnSidebar"},"learn/design/receivers-flatmap":{"id":"learn/design/receivers-flatmap","title":"Receivers vs. flatMap","description":"The Arrow project promotes a particular style of Kotlin to achieve the composability of effects. Functional programming patterns inspire many concepts, but the implementation differs significantly from Haskell\'s or Scala\'s typical way of doing things (monads, IO, and transformers). This article aims to clarify how this style works in Kotlin, compare it to other sibling languages, and discuss the main limitations.","sidebar":"learnSidebar"},"learn/design/suspend-io":{"id":"learn/design/suspend-io","title":"Why suspend over IO","description":"Other functional ecosystems, Scala and Haskell among others,","sidebar":"learnSidebar"},"learn/immutable-data/index":{"id":"learn/immutable-data/index","title":"Immutable Data","description":"Arrow Optics provide concise ways to handle immutable data.","sidebar":"learnSidebar"},"learn/immutable-data/intro":{"id":"learn/immutable-data/intro","title":"Introduction","description":"Data classes, sealed hierarchies, and above all, immutable data is","sidebar":"learnSidebar"},"learn/immutable-data/lens":{"id":"learn/immutable-data/lens","title":"Lenses","description":"Lenses are the most common type of optic you work with. This section discusses","sidebar":"learnSidebar"},"learn/immutable-data/optional":{"id":"learn/immutable-data/optional","title":"Optionals","description":"Optionals allow focusing on elements that may not be present. This includes","sidebar":"learnSidebar"},"learn/immutable-data/prism-iso":{"id":"learn/immutable-data/prism-iso","title":"Prisms & Isos","description":"Prisms extend the capabilities of optics from merely inspecting or modifying","sidebar":"learnSidebar"},"learn/immutable-data/reflection":{"id":"learn/immutable-data/reflection","title":"Reflection","description":"Although we strongly recommend generating optics using the DSL and @optics attribute, sometimes this is impossible. We provide the small utility package arrow-optics-reflect for those scenarios, which bridges Arrow Optics with Kotlin\'s reflection capabilities.","sidebar":"learnSidebar"},"learn/immutable-data/regex":{"id":"learn/immutable-data/regex","title":"Regular expressions","description":"Lenses, prisms, and basic traversals have an important limitation: the only","sidebar":"learnSidebar"},"learn/immutable-data/traversal":{"id":"learn/immutable-data/traversal","title":"Traversals","description":"The framework laid out by optics extends very nicely to values like lists, which","sidebar":"learnSidebar"},"learn/integrations":{"id":"learn/integrations","title":"Integrations","description":"Arrow comprises different libraries, each improving or extending one commonly-used library in the Kotlin ecosystem or a particular Kotlin language feature.","sidebar":"learnSidebar"},"learn/overview":{"id":"learn/overview","title":"overview","description":"","sidebar":"learnSidebar"},"learn/projects":{"id":"learn/projects","title":"Example projects","description":"Bigger projects where the design guidelines are put into practice","sidebar":"learnSidebar"},"learn/quickstart/compose":{"id":"learn/quickstart/compose","title":"Compose and UIs","description":"Arrow provides several features which are very interesting when developing","sidebar":"learnSidebar"},"learn/quickstart/from-fp":{"id":"learn/quickstart/from-fp","title":"From other FP languages","description":"Arrow is heavily influenced by functional programming. If you\'re used to working","sidebar":"learnSidebar"},"learn/quickstart/index":{"id":"learn/quickstart/index","title":"Quickstart","description":"Arrow aims to be the perfect companion to your Kotlin journey. That means it focuses on tasks most developers deal with, like modifying data or managing resources. Given these aims, Arrow strives to provide idiomatic solutions and integrate with core Kotlin concepts such as coroutines.","sidebar":"learnSidebar"},"learn/quickstart/libs":{"id":"learn/quickstart/libs","title":"Overview of libraries","description":"Arrow comprises different libraries, each improving or extending one commonly-used library in the Kotlin ecosystem or a particular Kotlin language feature.","sidebar":"learnSidebar"},"learn/quickstart/migration":{"id":"learn/quickstart/migration","title":"Migration to Arrow 2.0 / 1.2","description":"Migration guide to upgrade to Arrow 2.0 and 1.2.","sidebar":"learnSidebar"},"learn/quickstart/serialization":{"id":"learn/quickstart/serialization","title":"Serialization","description":"How to (de)serialize Arrow Core types.","sidebar":"learnSidebar"},"learn/resilience/circuitbreaker":{"id":"learn/resilience/circuitbreaker","title":"Circuit breaker","description":"Protect other services from being overloaded","sidebar":"learnSidebar"},"learn/resilience/index":{"id":"learn/resilience/index","title":"Resilience","description":"Most, if not all, of the systems we develop nowadays require the cooperation of","sidebar":"learnSidebar"},"learn/resilience/retry-and-repeat":{"id":"learn/resilience/retry-and-repeat","title":"Retry and repeat","description":"Retry and repeat computations using Schedule","sidebar":"learnSidebar"},"learn/resilience/saga":{"id":"learn/resilience/saga","title":"Saga","description":"Implement transactional behavior in distributed systems","sidebar":"learnSidebar"},"learn/summary":{"id":"learn/summary","title":"Summary","description":"Summary","sidebar":"learnSidebar"},"learn/typed-errors/either-and-ior":{"id":"learn/typed-errors/either-and-ior","title":"Either & Ior (& Result)","description":"Use cases for Either and Ior.","sidebar":"learnSidebar"},"learn/typed-errors/from-either-to-raise":{"id":"learn/typed-errors/from-either-to-raise","title":"From Either to Raise","description":"Learning about Raise from other FP ecosystems.","sidebar":"learnSidebar"},"learn/typed-errors/index":{"id":"learn/typed-errors/index","title":"Typed Errors","description":"Typed errors refer to a technique from functional programming in which we","sidebar":"learnSidebar"},"learn/typed-errors/nullable-and-option":{"id":"learn/typed-errors/nullable-and-option","title":"Why nullable types & Option?","description":"Difference between nullable types and Option, and when to use each.","sidebar":"learnSidebar"},"learn/typed-errors/outcome-progress":{"id":"learn/typed-errors/outcome-progress","title":"Outcomes and in-progress","description":"Describing more than success and failure.","sidebar":"learnSidebar"},"learn/typed-errors/own-error-types":{"id":"learn/typed-errors/own-error-types","title":"Your own error wrappers","description":"Writing your own DSLs with Raise.","sidebar":"learnSidebar"},"learn/typed-errors/validation":{"id":"learn/typed-errors/validation","title":"Validation","description":"Worked out example of validation.","sidebar":"learnSidebar"},"learn/typed-errors/working-with-typed-errors":{"id":"learn/typed-errors/working-with-typed-errors","title":"Working with typed errors","description":"Working, recovering, and accumulating errors in a typed and concise way.","sidebar":"learnSidebar"}}}}')}}]);