"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[4538],{47684:(t,e,o)=>{o.r(e),o.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>m});var a=o(85893),n=o(11151);const r={title:"What could possibly go wrong? - A safer programming with Arrow",image:"https://img.youtube.com/vi/C9SmleSSeGk/maxresdefault.jpg",category:"videos",tags:["core","videos"],link:"https://youtu.be/C9SmleSSeGk"},i=void 0,s={permalink:"/community/blog/2020/02/26/safer-programming-with-arrow",editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/blog/2020-02-26-safer-programming-with-arrow.md",source:"@site/content/blog/2020-02-26-safer-programming-with-arrow.md",title:"What could possibly go wrong? - A safer programming with Arrow",description:"Your Kotlin app grabs data from an API, transforms it and saves the processed data in a database. However, there are so many things that could go wrong at runtime treat your impure functions as computations with context, pass them around just like other values, and make the necessary unsafe invocation from a single point of your app, your main function.",date:"2020-02-26T00:00:00.000Z",tags:[{label:"core",permalink:"/community/blog/tags/core"},{label:"videos",permalink:"/community/blog/tags/videos"}],readingTime:.785,hasTruncateMarker:!1,authors:[],frontMatter:{title:"What could possibly go wrong? - A safer programming with Arrow",image:"https://img.youtube.com/vi/C9SmleSSeGk/maxresdefault.jpg",category:"videos",tags:["core","videos"],link:"https://youtu.be/C9SmleSSeGk"},unlisted:!1,prevItem:{title:"FP with Kotlin/Arrow: Monad Comprehensions & Parallel Processing",permalink:"/community/blog/2020/02/26/fp-with-kotlin-arrow"},nextItem:{title:"Kotlin Functional Programming: Cleaner Composition with Monad Comprehensions in Arrow Fx",permalink:"/community/blog/2020/01/29/cleaner-composition-with-monad-comprehensions-arrow-fx"}},c={authorsImageUrls:[]},m=[];function l(t){const e={p:"p",...(0,n.a)(),...t.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.p,{children:"Your Kotlin app grabs data from an API, transforms it and saves the processed data in a database. However, there are so many things that could go wrong at runtime: the API might be inaccessible, the data is not what you expected or the data can't be persisted in the database. You can start adding try catch blocks to your function in your objects, but there is a better way to do it: treat your impure functions as computations with context, pass them around just like other values, and make the necessary unsafe invocation from a single point of your app, your main function."}),"\n",(0,a.jsx)(e.p,{children:"This talk will walk you through the core functional concepts of Arrow, you will learn how Some, Either and even IO are functor, applicative and monad. You can use the code example from this talk as a starting point for your Arrow-learning, to write safer, simpler and more elegant functional code in Kotlin."})]})}function u(t={}){const{wrapper:e}={...(0,n.a)(),...t.components};return e?(0,a.jsx)(e,{...t,children:(0,a.jsx)(l,{...t})}):l(t)}},11151:(t,e,o)=>{o.d(e,{Z:()=>s,a:()=>i});var a=o(67294);const n={},r=a.createContext(n);function i(t){const e=a.useContext(r);return a.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function s(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(n):t.components||n:i(t.components),a.createElement(r.Provider,{value:e},t.children)}}}]);