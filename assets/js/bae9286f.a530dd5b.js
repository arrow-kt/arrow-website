"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([["2081"],{90981:function(e,t,n){n.r(t),n.d(t,{metadata:()=>s,default:()=>h,frontMatter:()=>r,contentTitle:()=>o,toc:()=>c,assets:()=>l});var s=JSON.parse('{"id":"ecosystem/analysis/laws","title":"3rd-party libraries (Laws)","description":"Is a library you use not compiled with Arrow Analysis? I could tell you to open an issue in their repository and convince their authors, but this is not always possible. For those cases Arrow Analysis provides a way to declare pre- and postconditions separately from the implementation, using @Law annotations. In fact, this is the way we package the analysis information related to Kotlin\'s stdlib.","source":"@site/content/docs/ecosystem/analysis/laws.md","sourceDirName":"ecosystem/analysis","slug":"/ecosystem/analysis/laws","permalink":"/ecosystem/analysis/laws","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"ecosystemSidebar","previous":{"title":"Fields and wrappers","permalink":"/ecosystem/analysis/wrappers"},"next":{"title":"Java support","permalink":"/ecosystem/analysis/java"}}'),i=n(74848),a=n(28453);let r={sidebar_position:7},o="3rd-party libraries (Laws)",l={},c=[{value:"Attaching laws",id:"attaching-laws",level:2},{value:"Organizing laws",id:"organizing-laws",level:3}];function d(e){let t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"3rd-party-libraries-laws",children:"3rd-party libraries (Laws)"})}),"\n",(0,i.jsxs)(t.p,{children:["Is a library you use not compiled with Arrow Analysis? I could tell you to open an issue in their repository and convince their authors, but this is not always possible. For those cases Arrow Analysis provides a way to declare pre- and postconditions separately from the implementation, using ",(0,i.jsx)(t.code,{children:"@Law"})," annotations. In fact, this is the way we package the analysis information related to Kotlin's ",(0,i.jsx)(t.code,{children:"stdlib"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["It might be the case that another 4rd-party provides the Arrow Analysis information for the 3rd-party library. In that case, just include ",(0,i.jsx)(t.strong,{children:"both"})," in your project. Oftentimes the Arrow Analysis information can be included as a ",(0,i.jsx)(t.code,{children:"compileOnly"})," dependency, since it's not used at run-time. You do ",(0,i.jsx)(t.strong,{children:"not"})," have to ",(0,i.jsx)(t.code,{children:"import"})," anything extra, just use the 3rd-party library as usual."]}),"\n",(0,i.jsx)(t.h2,{id:"attaching-laws",children:"Attaching laws"}),"\n",(0,i.jsxs)(t.p,{children:["To attach information about a 3rd-party function you declare a function somewhere else (it doesn't matter where), and annotate it with ",(0,i.jsx)(t.code,{children:"@Law"}),". Its body must follow a very restrictive form: it should only contain ",(0,i.jsx)(t.code,{children:"pre"})," and ",(0,i.jsx)(t.code,{children:"post"}),", and a ",(0,i.jsx)(t.strong,{children:"single"})," call to the 3rd-party function with the arguments in the ",(0,i.jsx)(t.strong,{children:"same order"})," they appeared in the original definition."]}),"\n",(0,i.jsx)(t.p,{children:"For example, this is the way to declare that an empty list has size 0:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'import arrow.analysis.Law\n\n@Law inline fun <T> emptyListLaw(): List<T> =\n  emptyList<T>().post({ it.size == 0 }) { "empty list has size 0" }\n'})}),"\n",(0,i.jsxs)(t.p,{children:["As a practical tip, we find useful to mark the function as ",(0,i.jsx)(t.code,{children:"inline"}),". That way you avoid the case in which you call the law instead of the function you want to decorate in the body, since inline functions cannot be recursive."]}),"\n",(0,i.jsx)(t.h3,{id:"organizing-laws",children:"Organizing laws"}),"\n",(0,i.jsxs)(t.p,{children:["If you want to define pre and post-conditions for an entire library, it's often useful to organize those by package or type. To help with this task, you can define several laws inside an ",(0,i.jsx)(t.code,{children:"object"})," marked with the ",(0,i.jsx)(t.code,{children:"@Laws"})," annotation (notice the final ",(0,i.jsx)(t.code,{children:"s"}),".)"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'import arrow.analysis.Law\nimport arrow.analysis.Laws\n\n@Laws object ListLaws {\n  @Law inline fun <T> emptyListLaw(): List<T> =\n    emptyList<T>().post({ it.size == 0 }) { "empty list has size 0" }\n  @Law inline fun <T> getLaw(index: Int): T {\n    pre(index >= 0 && index < this.size) { "index within bounds" }\n    return get(index)\n  }\n  // ... and many more!\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Note that each function must still be marked with ",(0,i.jsx)(t.code,{children:"@Law"}),"."]})]})}function h(e={}){let{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:function(e,t,n){n.d(t,{R:()=>r,x:()=>o});var s=n(96540);let i={},a=s.createContext(i);function r(e){let t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);