"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([["5347"],{42249:function(e,n,i){i.r(n),i.d(n,{metadata:()=>t,default:()=>h,frontMatter:()=>a,contentTitle:()=>s,toc:()=>l,assets:()=>c});var t=JSON.parse('{"id":"learn/collections-functions/utils","title":"Utilities for functions","description":"Composition, partial application, and currying","source":"@site/content/docs/learn/collections-functions/utils.md","sourceDirName":"learn/collections-functions","slug":"/learn/collections-functions/utils","permalink":"/learn/collections-functions/utils","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"description":"Composition, partial application, and currying"},"sidebar":"learnSidebar","previous":{"title":"Control over evaluation","permalink":"/learn/collections-functions/eval"},"next":{"title":"Design","permalink":"/learn/design/"}}'),o=i(74848),r=i(28453);let a={sidebar_position:5,description:"Composition, partial application, and currying"},s="Utilities for functions",c={},l=[{value:"Composition",id:"composition",level:2},{value:"Partial application",id:"partial-application",level:2},{value:"Currying",id:"currying",level:2}];function d(e){let n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"utilities-for-functions",children:"Utilities for functions"})}),"\n",(0,o.jsxs)(n.p,{children:["Functions are an important part of functional programming. Every time we use\n",(0,o.jsx)(n.code,{children:"map"})," or ",(0,o.jsx)(n.code,{children:"filter"})," we are using functions as arguments, every block is creating\na new anonymous function. Arrow brings some patterns which have proven useful\nin other programming language communities when manipulating functions as values."]}),"\n",(0,o.jsx)(n.admonition,{title:"Point-free style",type:"info",children:(0,o.jsxs)(n.p,{children:["The utilities described in this section are part of a particular style of\nprogramming called ",(0,o.jsx)(n.em,{children:"point-free"}),". The name stems from the fact that you never\nmention explicit arguments, or ",(0,o.jsx)(n.em,{children:"points"}),", in your code.\nSome functional programming communities, like Haskell, use this style quite\noften."]})}),"\n",(0,o.jsx)(n.admonition,{title:"Not idiomatic",type:"danger",children:(0,o.jsxs)(n.p,{children:["Although the following functions are very commonly used in other functional\nlanguages, they are not considered idiomatically Kotlin. Most Kotlin developers\nprefer a block with an explicit call, ",(0,o.jsx)(n.code,{children:"{ dance(2, it) }"}),", instead of\nmanipulating the function value as described in this section, ",(0,o.jsx)(n.code,{children:"::dance.partially1(2)"}),"."]})}),"\n",(0,o.jsx)(n.h2,{id:"composition",children:"Composition"}),"\n",(0,o.jsxs)(n.p,{children:["Composition is used to create a pipeline of functions, in which each of them\nconsume the result of the previous one. In particular, given two functions\n",(0,o.jsx)(n.code,{children:"f(a: A): B"})," and ",(0,o.jsx)(n.code,{children:"g(b: B): C"}),", the result of ",(0,o.jsx)(n.code,{children:"g compose f"})," is a new function\nof type ",(0,o.jsx)(n.code,{children:"(a: A) -> C"})," which executes ",(0,o.jsx)(n.code,{children:"f"})," over ",(0,o.jsx)(n.code,{children:"a"}),", and then ",(0,o.jsx)(n.code,{children:"g"})," over the result.\nIn graphical form it looks as follows:"]}),"\n",(0,o.jsx)(n.mermaid,{value:"graph LR;\n  A--\x3e|f|B;\n  B--\x3e|g|C;\n  A--\x3e|g compose f|C;"}),"\n",(0,o.jsx)(n.admonition,{title:"Order of composition",type:"caution",children:(0,o.jsxs)(n.p,{children:["When writing a composition pipeline ",(0,o.jsx)(n.code,{children:"f compose g compose h"}),", remember that\ncomputations are applied in ",(0,o.jsx)(n.strong,{children:"right-to-left"})," order; in this case we begin\nwith ",(0,o.jsx)(n.code,{children:"h"})," and finish with ",(0,o.jsx)(n.code,{children:"f"}),". This parallels the way you would write them\nusing explicit invocations, ",(0,o.jsx)(n.code,{children:"{ f(g(h(it))) }"}),"."]})}),"\n",(0,o.jsx)(n.h2,{id:"partial-application",children:"Partial application"}),"\n",(0,o.jsx)(n.p,{children:"Imagine you have a two-argument function, like this very useful one in a disco,"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun dance(rounds: Int, person: String): Unit { TODO() }\n"})}),"\n",(0,o.jsx)(n.p,{children:"and you want to apply it over a list, where everybody dances the same number of\nrounds,"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"fun List<String>.everybodyDancesTwo() = forEach { dance(2, it) }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The block given to ",(0,o.jsx)(n.code,{children:"forEach"})," is an example of a ",(0,o.jsx)(n.strong,{children:"partially-applied"})," function,\nthat is, an instance in which some arguments of the functions are fixed\n(in this case the ",(0,o.jsx)(n.code,{children:"rounds"}),"), and others are yet to be given. Instead of an\nexplicit invocation with ",(0,o.jsx)(n.code,{children:"it"}),", you can use ",(0,o.jsx)(n.code,{children:"partially1"})," from Arrow to inject\nthose fixed arguments, as follows."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"import arrow.core.partially1\n\nfun List<String>.everybodyDancesTwo() = forEach(::dance.partially1(2))\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Arrow provides ",(0,o.jsx)(n.code,{children:"partiallyN"})," functions up to a reasonable value of ",(0,o.jsx)(n.code,{children:"N"}),",\ndepending on the amount of values you inject."]}),"\n",(0,o.jsx)(n.admonition,{title:"Order of partial application",type:"caution",children:(0,o.jsx)(n.p,{children:'The functions provided by Arrow always start fixing arguments from the left,\nthat is, from the "first" parameter in the signature. At the moment of writing\nthere are no versions of partial application for functions with a receiver.'})}),"\n",(0,o.jsx)(n.admonition,{title:"Where to find it",type:"note",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"partiallyN"})," functions are a part of the ",(0,o.jsx)(n.code,{children:"arrow-functions"})," library."]})}),"\n",(0,o.jsx)(n.h2,{id:"currying",children:"Currying"}),"\n",(0,o.jsxs)(n.p,{children:["Functions in Kotlin take all arguments in one go; writing something like\n",(0,o.jsx)(n.code,{children:"dance(2)"})," is not allowed, hence the need of partial application above.\nBut for every function we can always define a variation which takes arguments\n",(0,o.jsx)(n.em,{children:"one at a time"}),". This process is called ",(0,o.jsx)(n.strong,{children:"currying"}),", and Arrow provides\nconversion back and forth. The types of the functions make this process quite\nexplicit: we go from ",(0,o.jsx)(n.code,{children:"(A, B) -> C"})," (two arguments at once) to ",(0,o.jsx)(n.code,{children:"(A) -> (B) -> C"}),"\n(after giving one argument, we have a function which expects the other one)."]}),"\n",(0,o.jsx)(n.mermaid,{value:'graph LR;\n  un["(A, B) -> C"];\n  cu["(A) -> (B) -> C"];\n  un--\x3e|".curried()"|cu;\n  cu--\x3e|".uncurried()"|un;'})]})}function h(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:function(e,n,i){i.d(n,{R:()=>a,x:()=>s});var t=i(96540);let o={},r=t.createContext(o);function a(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);