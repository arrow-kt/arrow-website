"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[810],{30517:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var a=o(85893),r=o(11151);const i={sidebar_position:7},t="Regular expressions",s={id:"learn/immutable-data/regex",title:"Regular expressions",description:"Lenses, prisms, and basic traversals have an important limitation: the only",source:"@site/content/docs/learn/immutable-data/regex.md",sourceDirName:"learn/immutable-data",slug:"/learn/immutable-data/regex",permalink:"/learn/immutable-data/regex",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/immutable-data/regex.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"learnSidebar",previous:{title:"Reflection",permalink:"/learn/immutable-data/reflection"},next:{title:"Collections and functions",permalink:"/learn/collections-functions/"}},l={},d=[{value:"Repetition",id:"repetition",level:2},{value:"Combination",id:"combination",level:2}];function c(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"regular-expressions",children:"Regular expressions"}),"\n",(0,a.jsxs)(n.p,{children:["Lenses, prisms, and basic traversals have an important limitation: the only\ngo ",(0,a.jsx)(n.em,{children:"one level deep"})," in the data structure. The functions in the\n",(0,a.jsx)(n.code,{children:"arrow.optics.regex"})," package remove that limitation, providing a great\nfoundation for querying and modifying hierarchical data, such as trees\nor JSON documents."]}),"\n",(0,a.jsx)(n.h2,{id:"repetition",children:"Repetition"}),"\n",(0,a.jsx)(n.p,{children:"We shall use different forms of trees in the examples below.\nThe first variation only has data in the leaves."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"@optics sealed interface BinaryTree1<out A> {\n    companion object\n}\n\n@optics data class Node1<out A>(\n    val children: List<BinaryTree1<A>>\n) : BinaryTree1<A> {\n    constructor(vararg children: BinaryTree1<A>) : this(children.toList())\n\n    companion object\n}\n\n@optics data class Leaf1<out A>(\n    val value: A\n) : BinaryTree1<A> {\n    companion object\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Suppose we want to increment all the numbers in a binary tree of integers.\nThe code below attempts to do that, but fails because it only traverses the\nchildren of nodes in one level -- this is why only the last ",(0,a.jsx)(n.code,{children:"Leaf1"})," is\nmodified after the call."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val exampleTree1 = Node1(Node1(Leaf1(1), Leaf1(2)), Leaf1(3))\n\nfun example() {\n    val path = BinaryTree1.node1<Int>().children().every.leaf1().value()\n    \n    val modifiedTree1 = path.modify(exampleTree1) { it + 1 }\n    modifiedTree1 shouldBe Node1(Node1(Leaf1(1), Leaf1(2)), Leaf1(4))\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["So how should be look at this problem? First, we know that we'll always\nend by traversing a final ",(0,a.jsx)(n.code,{children:"Leaf1"})," and the ",(0,a.jsx)(n.code,{children:"value"})," there. In the middle,\nwe may need to go down the children once or more. In fact, ",(0,a.jsx)(n.em,{children:"zero"}),"\ntimes should also be considered, as the binary tree could be just a\nsingle leaf. We can express this idea by wrapping the first segment\nof the previous path with ",(0,a.jsx)(n.code,{children:"zeroOrMore"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun example() {\n    val path = zeroOrMore(BinaryTree1.node1<Int>().children().every).leaf1().value()\n    \n    val modifiedTree1 = path.modify(exampleTree1) { it + 1 }\n    modifiedTree1 shouldBe Node1(Node1(Leaf1(2), Leaf1(3)), Leaf1(4))\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The functions ",(0,a.jsx)(n.code,{children:"zeroOrMore"})," and ",(0,a.jsx)(n.code,{children:"onceOrMore"})," provide ",(0,a.jsx)(n.em,{children:"repetition"})," of\na single lens, prims, or traversal, that is applied recursively.\nThese functions are available on every scenario in which you can\nconstruct an optics going from a type to itself -- in our example,\n",(0,a.jsx)(n.code,{children:"node1<Int>().children().every"})," focus from ",(0,a.jsx)(n.code,{children:"BinaryTree1"})," into\n",(0,a.jsx)(n.code,{children:"BinaryTree1"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"combination",children:"Combination"}),"\n",(0,a.jsx)(n.p,{children:"Let's now consider another variation of binary trees, in which now\nat every step (leaf or node) we find a value."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"@optics sealed interface BinaryTree2<out A> {\n    companion object\n}\n\n@optics data class Node2<out A>(\n    val innerValue: A,\n    val children: List<BinaryTree2<A>>\n) : BinaryTree2<A> {\n    constructor(value: A, vararg children: BinaryTree2<A>) : this(value, children.toList())\n\n    companion object\n}\n\n@optics data class Leaf2<out A>(\n    val value: A\n) : BinaryTree2<A> {\n    companion object\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"If we construct a path similar to the previous one, we shall only\nfocus on those values in leaves, as we can see in the example below."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val exampleTree2 = Node2(1, Node2(2, Leaf2(3), Leaf2(4)), Leaf2(5))\n\nfun example() {\n    val path = zeroOrMore(BinaryTree2.node2<Int>().children().every).leaf2().value()\n    \n    val modifiedTree2 = path.modify(exampleTree2) { it + 1 }\n    modifiedTree2 shouldBe Node2(1, Node2(2, Leaf2(4), Leaf2(5)), Leaf2(6))\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The solution in this case is to ",(0,a.jsx)(n.em,{children:"combine"})," two different traversals into a single one.\nIn the code below we build ",(0,a.jsx)(n.code,{children:"nodeValues"}),", that focuses on values found in nodes,\nand ",(0,a.jsx)(n.code,{children:"leafValues"}),", that focuses on those values in the leaves. Then we combine them\nusing the ",(0,a.jsx)(n.code,{children:"and"})," infix function from the library."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun example() {\n    val nodeValues = zeroOrMore(BinaryTree2.node2<Int>().children().every).node2().innerValue()\n    val leafValues = zeroOrMore(BinaryTree2.node2<Int>().children().every).leaf2().value()\n    val path = nodeValues and leafValues\n    \n    val modifiedTree2 = path.modify(exampleTree2) { it + 1 }\n    modifiedTree2 shouldBe Node2(2, Node2(3, Leaf2(4), Leaf2(5)), Leaf2(6))\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:['It is also possible to remove some of the duplication in the code above.\nIn particular, we can separate the "digging" in the binary tree (the part where\nwe use ',(0,a.jsx)(n.code,{children:"zeroOrMore"}),") from obtaining the value by either looking at the one\non a node or at the one on a leaf."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun example() {\n    val pathToValue = BinaryTree2.node2<Int>().innerValue() and BinaryTree2.leaf2<Int>().value()\n    val path = zeroOrMore(BinaryTree2.node2<Int>().children().every) compose pathToValue\n    \n    val modifiedTree2 = path.modify(exampleTree2) { it + 1 }\n    modifiedTree2 shouldBe Node2(2, Node2(3, Leaf2(4), Leaf2(5)), Leaf2(6))\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Unfortunately, with this refactor we no longer can use the chained syntax\nusing ",(0,a.jsx)(n.code,{children:"."})," all the time. We need to resort to ",(0,a.jsx)(n.code,{children:"compose"})," instead."]}),"\n",(0,a.jsxs)(n.admonition,{title:"Regular expressions?",type:"info",children:[(0,a.jsxs)(n.p,{children:["You might be wondering why we call ",(0,a.jsx)(n.code,{children:"zeroOrMore"}),", ",(0,a.jsx)(n.code,{children:"onceOrMore"}),", and ",(0,a.jsx)(n.code,{children:"and"})," the\n",(0,a.jsx)(n.em,{children:"regular expression"})," functions. To understand this, we need to view ",(0,a.jsx)(n.em,{children:"paths"}),'\nto data as "strings" in which each "letter" represent one single optic.']}),(0,a.jsxs)(n.p,{children:["For example, if we use ",(0,a.jsx)(n.code,{children:"n"})," for ",(0,a.jsx)(n.code,{children:"node1"}),", ",(0,a.jsx)(n.code,{children:"c"})," for ",(0,a.jsx)(n.code,{children:"children"}),", ",(0,a.jsx)(n.code,{children:"e"})," for ",(0,a.jsx)(n.code,{children:"every"}),",\n",(0,a.jsx)(n.code,{children:"l"})," for ",(0,a.jsx)(n.code,{children:"leaf1"}),", and ",(0,a.jsx)(n.code,{children:"v"})," for ",(0,a.jsx)(n.code,{children:"value"}),', the "strings" we want to use to access\nall the values are those of the form:']}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"lv\nncelv\nncencelv\nncencencelv\n...\n"})}),(0,a.jsxs)(n.p,{children:["From that point of view, the regular expression that matches all the possible\npaths we want to take is ",(0,a.jsx)(n.code,{children:"(nce)*lv"}),", where ",(0,a.jsx)(n.code,{children:"*"})," is the regular expression\noperator that matches that string zero or more times."]}),(0,a.jsxs)(n.p,{children:["Similarly, ",(0,a.jsx)(n.code,{children:"onceOrMore"})," corresponds to ",(0,a.jsx)(n.code,{children:"+"}),". The ",(0,a.jsx)(n.code,{children:"and"})," functions corresponds\nto ",(0,a.jsx)(n.code,{children:"+"}),", since it allows choosing between several matches, that in turn\ncorrespond to different possible paths to focus on the data."]})]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},11151:(e,n,o)=>{o.d(n,{Z:()=>s,a:()=>t});var a=o(67294);const r={},i=a.createContext(r);function t(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);